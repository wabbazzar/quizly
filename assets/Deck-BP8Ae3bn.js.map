{"version":3,"file":"Deck-BP8Ae3bn.js","sources":["../../src/components/deck/DeckHeader.tsx","../../src/components/deck/ModeSelector.tsx","../../src/components/deck/CardManagement.tsx","../../src/pages/Deck.tsx"],"sourcesContent":["import { FC, memo } from 'react';\nimport { DeckHeaderProps } from './types';\nimport { PageHeader } from '@/components/common/PageHeader';\n\nexport const DeckHeader: FC<DeckHeaderProps> = memo(({ deck, onBackClick, onSettingsClick }) => {\n  // Add safety check for deck\n  if (!deck || !deck.content || !deck.metadata) {\n    return null;\n  }\n\n  const statsText = `${deck.content.length} cards${deck.metadata.difficulty ? ` • ${deck.metadata.difficulty.replace('_', ' ')}` : ''}${deck.metadata.tags && deck.metadata.tags.length > 0 ? ` • ${deck.metadata.tags.slice(0, 2).join(', ')}` : ''}`;\n\n  return (\n    <PageHeader\n      title={deck.metadata.deck_name}\n      subtitle={deck.metadata.deck_subtitle || deck.metadata.description || statsText}\n      onBackClick={onBackClick}\n      backLabel=\"Home\"\n      onSettingsClick={onSettingsClick}\n      showSettings={true}\n    />\n  );\n});\n\nDeckHeader.displayName = 'DeckHeader';\n","import { FC, memo } from 'react';\nimport { motion } from 'framer-motion';\nimport { ModeSelectorProps } from './types';\nimport styles from './ModeSelector.module.css';\n\nexport const ModeSelector: FC<ModeSelectorProps> = memo(({ modes, onModeClick }) => {\n  return (\n    <section className={styles.modesSection}>\n      <motion.div\n        className={styles.modesGrid}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        transition={{ duration: 0.3 }}\n      >\n        {modes.map(mode => (\n          <motion.div\n            key={mode.id}\n            className={`${styles.modeCard} ${styles[mode.color]}`}\n            whileHover={{ scale: 1.02, y: -2 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={() => onModeClick(mode)}\n          >\n            <div className={styles.modeIconWrapper}>\n              <mode.icon className={styles.modeIcon} size={32} />\n            </div>\n            <h3 className={styles.modeName}>{mode.label}</h3>\n            <p className={styles.modeDescription}>{mode.description}</p>\n            <div className={styles.modeAction}>\n              <span className={styles.startText}>Start →</span>\n            </div>\n          </motion.div>\n        ))}\n      </motion.div>\n    </section>\n  );\n});\n\nModeSelector.displayName = 'ModeSelector';\n","import { FC, memo, useState, useRef } from 'react';\nimport { Card } from '@/types';\nimport { CardManagementProps } from './types';\nimport {\n  BookOpenIcon,\n  CheckCircleIcon,\n  RefreshIcon,\n  DragHandleIcon,\n  TrophyIcon,\n} from '@/components/icons/StatusIcons';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport styles from './CardManagement.module.css';\n\nexport const CardManagement: FC<CardManagementProps> = memo(\n  ({ deck, learningCards, masteredCards, onCardClick, onToggleMastered }) => {\n    const { showNotification } = useNotificationStore();\n    const { markCardMastered, unmarkCardMastered } = useCardMasteryStore();\n    const [draggedCard, setDraggedCard] = useState<number | null>(null);\n    const [dragOverSection, setDragOverSection] = useState<'learning' | 'mastered' | null>(null);\n    const dragCardRef = useRef<number | null>(null);\n\n    // Add safety check for deck\n    if (!deck || !deck.content || !deck.metadata) {\n      return null;\n    }\n\n    const handleDragStart = (cardIdx: number) => {\n      setDraggedCard(cardIdx);\n      dragCardRef.current = cardIdx;\n    };\n\n    const handleDragEnd = () => {\n      setDraggedCard(null);\n      dragCardRef.current = null;\n      setDragOverSection(null);\n    };\n\n    const handleDragOver = (section: 'learning' | 'mastered') => (e: React.DragEvent) => {\n      e.preventDefault();\n      setDragOverSection(section);\n    };\n\n    const handleDragLeave = () => {\n      setDragOverSection(null);\n    };\n\n    const handleDrop = (section: 'learning' | 'mastered') => (e: React.DragEvent) => {\n      e.preventDefault();\n      const draggedIdx = dragCardRef.current;\n\n      const deckId = deck.metadata.deck_name; // Use deck_name as ID\n      if (draggedIdx === null || !deckId) return;\n\n      const isMastered = masteredCards.some(card => card.idx === draggedIdx);\n\n      if (section === 'mastered' && !isMastered) {\n        markCardMastered(deckId, draggedIdx, deck.content.length);\n        showNotification({\n          message: 'Card marked as mastered!',\n          type: 'success',\n          duration: 2000,\n        });\n      } else if (section === 'learning' && isMastered) {\n        unmarkCardMastered(deckId, draggedIdx);\n        showNotification({\n          message: 'Card moved back to learning',\n          type: 'info',\n          duration: 2000,\n        });\n      }\n\n      setDragOverSection(null);\n      handleDragEnd();\n    };\n\n    // Check if device supports touch (mobile/tablet)\n    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\n    // Get side labels from deck metadata, fallback to Side A/Side B\n    const sideALabel = deck.metadata.side_labels?.side_a || 'Side A';\n    const sideBLabel = deck.metadata.side_labels?.side_b || 'Side B';\n\n    const renderCard = (card: Card, isMastered: boolean) => (\n      <div\n        key={card.idx}\n        className={`${styles.cardItem} ${isMastered ? styles.masteredCard : ''} ${draggedCard === card.idx ? styles.dragging : ''}`}\n        draggable={!isTouchDevice}\n        onDragStart={!isTouchDevice ? () => handleDragStart(card.idx) : undefined}\n        onDragEnd={!isTouchDevice ? handleDragEnd : undefined}\n        onClick={() => onCardClick(card)}\n      >\n        {!isTouchDevice && <DragHandleIcon className={styles.cardDragHandle} size={20} />}\n        <div className={styles.cardNumber}>{card.idx + 1}</div>\n        <div className={styles.cardContent}>\n          <div className={styles.cardSide}>\n            <span className={styles.sideLabel}>{sideALabel}:</span>\n            <span className={styles.sideText}>{card.side_a}</span>\n          </div>\n          <div className={styles.cardSide}>\n            <span className={styles.sideLabel}>{sideBLabel}:</span>\n            <span className={styles.sideText}>{card.side_b}</span>\n          </div>\n        </div>\n        <button\n          className={isMastered ? styles.unmasterButton : styles.masterButton}\n          onClick={e => {\n            e.stopPropagation();\n            onToggleMastered(card.idx);\n          }}\n          title={isMastered ? 'Move back to learning' : 'Mark as mastered'}\n        >\n          {isMastered ? <RefreshIcon size={16} /> : <CheckCircleIcon size={16} />}\n        </button>\n      </div>\n    );\n\n    return (\n      <section className={styles.cardsSection}>\n        <div className={styles.sectionHeader}>\n          <h2 className={styles.sectionTitle}>Cards Management ({deck.content.length} total)</h2>\n          <div className={styles.cardActions}>\n            {'ontouchstart' in window || navigator.maxTouchPoints > 0 ? null : (\n              <span className={styles.dragHint}>Drag cards to categorize them</span>\n            )}\n          </div>\n        </div>\n\n        <div className={styles.cardsManagement}>\n          {/* Learning Cards Section */}\n          <div\n            className={`${styles.cardCategory} ${styles.learningSection} ${dragOverSection === 'learning' ? styles.dragOver : ''}`}\n            onDragOver={handleDragOver('learning')}\n            onDrop={handleDrop('learning')}\n            onDragLeave={handleDragLeave}\n          >\n            <h3 className={styles.categoryTitle}>\n              <BookOpenIcon size={20} className={styles.categoryIcon} />\n              Learning ({learningCards.length})\n            </h3>\n            <div className={styles.cardsList}>\n              {learningCards.length > 0 ? (\n                learningCards.map(card => renderCard(card, false))\n              ) : (\n                <div className={styles.emptyState}>\n                  <p>No cards in learning</p>\n                  <span>\n                    {'ontouchstart' in window || navigator.maxTouchPoints > 0\n                      ? 'Tap cards to categorize them'\n                      : 'Drag cards here to start learning'}\n                  </span>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Mastered Cards Section */}\n          <div\n            className={`${styles.cardCategory} ${styles.masteredSection} ${dragOverSection === 'mastered' ? styles.dragOver : ''}`}\n            onDragOver={handleDragOver('mastered')}\n            onDrop={handleDrop('mastered')}\n            onDragLeave={handleDragLeave}\n          >\n            <h3 className={styles.categoryTitle}>\n              <TrophyIcon size={20} className={styles.categoryIcon} />\n              Mastered ({masteredCards.length})\n            </h3>\n            <div className={styles.cardsList}>\n              {masteredCards.length > 0 ? (\n                masteredCards.map(card => renderCard(card, true))\n              ) : (\n                <div className={styles.emptyState}>\n                  <p>No mastered cards</p>\n                  <span>\n                    {'ontouchstart' in window || navigator.maxTouchPoints > 0\n                      ? 'Cards appear here when marked as mastered'\n                      : 'Cards auto-populate here during learn mode or drag to mark as mastered'}\n                  </span>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </section>\n    );\n  }\n);\n\nCardManagement.displayName = 'CardManagement';\n","import { FC, useEffect, useState, useMemo, useCallback } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { motion } from 'framer-motion';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { Card } from '@/types';\nimport { DeckHeader } from '@/components/deck/DeckHeader';\nimport { ModeSelector } from '@/components/deck/ModeSelector';\nimport { CardManagement } from '@/components/deck/CardManagement';\nimport { ModeCard } from '@/components/deck/types';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport { FlashcardsIcon, LearnIcon, MatchIcon, ReadIcon } from '@/components/icons/ModeIcons';\nimport { hasTranscriptsForDeck } from '@/services/transcriptService';\nimport styles from './Deck.module.css';\n\nconst Deck: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n\n  // Use selectors to prevent re-renders from unrelated store changes\n  const currentDeck = useDeckStore(state => state.currentDeck);\n  const loadDeck = useDeckStore(state => state.loadDeck);\n  const isLoading = useDeckStore(state => state.isLoading);\n  const error = useDeckStore(state => state.error);\n\n  // Only subscribe to this specific deck's mastery changes via lastUpdated timestamp\n  const deckMasteryVersion = useCardMasteryStore(\n    state => state.mastery[deckId ?? '']?.lastUpdated?.getTime() ?? 0\n  );\n  const getMasteredCards = useCardMasteryStore(state => state.getMasteredCards);\n  const resetDeckMastery = useCardMasteryStore(state => state.resetDeckMastery);\n\n  const { showNotification } = useNotificationStore();\n  const { getSettingsForMode } = useSettingsStore();\n  const [selectedCard, setSelectedCard] = useState<Card | null>(null);\n  const [showCardModal, setShowCardModal] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [hasTranscripts, setHasTranscripts] = useState(false);\n\n  useEffect(() => {\n    if (deckId) {\n      loadDeck(deckId);\n      // Check for transcripts availability\n      hasTranscriptsForDeck(deckId).then(setHasTranscripts);\n    }\n  }, [deckId, loadDeck]);\n\n  // Calculate mastered cards - only recalculates when this deck's mastery changes\n  const masteredCardIndices = useMemo(() => {\n    return deckId ? getMasteredCards(deckId) : [];\n  }, [deckId, getMasteredCards, deckMasteryVersion]);\n\n  const learningCards = useMemo(() => {\n    if (!currentDeck?.content) return [];\n    return currentDeck.content.filter(card => !masteredCardIndices.includes(card.idx));\n  }, [currentDeck, masteredCardIndices]);\n\n  const masteredCardsList = useMemo(() => {\n    if (!currentDeck?.content) return [];\n    return currentDeck.content.filter(card => masteredCardIndices.includes(card.idx));\n  }, [currentDeck, masteredCardIndices]);\n\n  const modes: ModeCard[] = useMemo(\n    () => [\n      {\n        id: 'flashcards',\n        label: 'Flashcards',\n        icon: FlashcardsIcon,\n        color: 'primary',\n        description: 'Classic flip cards for memorization',\n        route: `/flashcards/${deckId}`,\n      },\n      {\n        id: 'learn',\n        label: 'Learn',\n        icon: LearnIcon,\n        color: 'secondary',\n        description: 'Interactive questions with smart scheduling',\n        route: `/learn/${deckId}`,\n      },\n      {\n        id: 'match',\n        label: 'Match',\n        icon: MatchIcon,\n        color: 'purple',\n        description: 'Memory game to match terms and definitions',\n        route: `/match/${deckId}`,\n      },\n      {\n        id: 'read',\n        label: 'Read',\n        icon: ReadIcon,\n        color: 'orange',\n        description: 'Structured reading with line-by-line translation',\n        route: `/read/${deckId}`,\n      },\n    ],\n    [deckId]\n  );\n\n  const handleModeClick = useCallback(\n    (mode: ModeCard) => {\n      // Check if Read mode is available for this deck\n      if (mode.id === 'read') {\n        const hasReadingContent = currentDeck?.reading && Object.keys(currentDeck.reading.dialogues).length > 0;\n        if (!hasReadingContent && !hasTranscripts) {\n          showNotification({\n            message: 'No reading content available for this deck',\n            type: 'info',\n            duration: 3000,\n          });\n          return;\n        }\n      }\n      navigate(mode.route);\n    },\n    [navigate, showNotification, currentDeck, hasTranscripts]\n  );\n\n  const handleCardClick = useCallback((card: Card) => {\n    setSelectedCard(card);\n    setShowCardModal(true);\n  }, []);\n\n  const closeCardModal = useCallback(() => {\n    setShowCardModal(false);\n    setTimeout(() => setSelectedCard(null), 300);\n  }, []);\n\n  const handleToggleMastered = useCallback(\n    (cardIdx: number) => {\n      if (!deckId || !currentDeck) return;\n\n      const { markCardMastered, unmarkCardMastered } = useCardMasteryStore.getState();\n      const isMastered = masteredCardIndices.includes(cardIdx);\n\n      if (isMastered) {\n        unmarkCardMastered(deckId, cardIdx);\n      } else {\n        // Always use the actual current deck's card count\n        markCardMastered(deckId, cardIdx, currentDeck.content.length);\n      }\n\n      showNotification({\n        message: isMastered ? 'Card moved back to learning' : 'Card marked as mastered!',\n        type: isMastered ? 'info' : 'success',\n        duration: 2000,\n      });\n    },\n    [deckId, masteredCardIndices, currentDeck, showNotification]\n  );\n\n  if (isLoading) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  if (error || !currentDeck) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>Error Loading Deck</h2>\n        <p>{error || 'Deck not found'}</p>\n        <button onClick={() => navigate('/')} className={styles.backButton}>\n          Back to Home\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.deckPage}>\n      <DeckHeader\n        deck={currentDeck}\n        onBackClick={() => navigate('/')}\n        onSettingsClick={() => setShowSettings(true)}\n      />\n\n      <ModeSelector modes={modes} onModeClick={handleModeClick} />\n\n      <CardManagement\n        deck={currentDeck}\n        learningCards={learningCards}\n        masteredCards={masteredCardsList}\n        onCardClick={handleCardClick}\n        onToggleMastered={handleToggleMastered}\n      />\n\n      {/* Card Modal */}\n      {showCardModal && selectedCard && (\n        <motion.div\n          className={styles.modalOverlay}\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          onClick={closeCardModal}\n        >\n          <motion.div\n            className={styles.modalContent}\n            initial={{ scale: 0.9, opacity: 0 }}\n            animate={{ scale: 1, opacity: 1 }}\n            exit={{ scale: 0.9, opacity: 0 }}\n            onClick={e => e.stopPropagation()}\n          >\n            <button className={styles.closeButton} onClick={closeCardModal}>\n              ×\n            </button>\n            <h3 className={styles.modalTitle}>Card Details</h3>\n            <div className={styles.modalCard}>\n              <div className={styles.modalSide}>\n                <h4>\n                  {currentDeck?.metadata?.side_labels?.side_a\n                    ? currentDeck.metadata.side_labels.side_a.charAt(0).toUpperCase() +\n                      currentDeck.metadata.side_labels.side_a.slice(1)\n                    : 'Side A (Front)'}\n                </h4>\n                <p>{selectedCard.side_a}</p>\n              </div>\n              <div className={styles.modalSide}>\n                <h4>\n                  {currentDeck?.metadata?.side_labels?.side_b\n                    ? currentDeck.metadata.side_labels.side_b.charAt(0).toUpperCase() +\n                      currentDeck.metadata.side_labels.side_b.slice(1)\n                    : 'Side B (Back)'}\n                </h4>\n                <p>{selectedCard.side_b}</p>\n              </div>\n              {selectedCard.side_c && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_c\n                      ? currentDeck.metadata.side_labels.side_c.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_c.slice(1)\n                      : 'Side C (Extra)'}\n                  </h4>\n                  <p>{selectedCard.side_c}</p>\n                </div>\n              )}\n              {selectedCard.side_d && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_d\n                      ? currentDeck.metadata.side_labels.side_d.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_d.slice(1)\n                      : 'Side D'}\n                  </h4>\n                  <p>{selectedCard.side_d}</p>\n                </div>\n              )}\n              {selectedCard.side_e && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_e\n                      ? currentDeck.metadata.side_labels.side_e.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_e.slice(1)\n                      : 'Side E'}\n                  </h4>\n                  <p>{selectedCard.side_e}</p>\n                </div>\n              )}\n              {selectedCard.side_f && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_f\n                      ? currentDeck.metadata.side_labels.side_f.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_f.slice(1)\n                      : 'Side F'}\n                  </h4>\n                  <p>{selectedCard.side_f}</p>\n                </div>\n              )}\n            </div>\n          </motion.div>\n        </motion.div>\n      )}\n\n      {/* Deck Settings Modal */}\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={() => setShowSettings(false)}\n        deck={currentDeck}\n        mode=\"deck\"\n        settings={\n          deckId\n            ? getSettingsForMode(deckId, 'deck')\n            : {\n                frontSides: [],\n                backSides: [],\n                cardsPerRound: 10,\n                enableTimer: false,\n                enableAudio: false,\n                randomize: false,\n                progressionMode: 'sequential' as const,\n              }\n        }\n        onUpdateSettings={() => {}}\n        onResetMastery={() => {\n          if (!deckId) return;\n          resetDeckMastery(deckId);\n          showNotification({\n            message: 'Mastered cards reset for this deck.',\n            type: 'info',\n            duration: 2000,\n          });\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Deck;\n"],"names":["DeckHeader","memo","deck","onBackClick","onSettingsClick","content","metadata","statsText","length","difficulty","replace","tags","slice","join","jsx","PageHeader","title","deck_name","subtitle","deck_subtitle","description","backLabel","showSettings","displayName","ModeSelector","modes","onModeClick","className","styles","modesSection","children","motion","div","modesGrid","initial","opacity","animate","transition","duration","map","mode","jsxs","modeCard","color","whileHover","scale","y","whileTap","onClick","modeIconWrapper","icon","modeIcon","size","modeName","label","modeDescription","modeAction","startText","id","CardManagement","learningCards","masteredCards","onCardClick","onToggleMastered","showNotification","useNotificationStore","markCardMastered","unmarkCardMastered","useCardMasteryStore","draggedCard","setDraggedCard","useState","dragOverSection","setDragOverSection","dragCardRef","useRef","handleDragEnd","current","handleDragOver","section","e","preventDefault","handleDragLeave","handleDrop","draggedIdx","deckId","isMastered","some","card","idx","message","type","isTouchDevice","window","navigator","maxTouchPoints","sideALabel","side_labels","side_a","sideBLabel","side_b","renderCard","draggable","onDragStart","handleDragStart","cardIdx","onDragEnd","DragHandleIcon","stopPropagation","RefreshIcon","CheckCircleIcon","onDragOver","onDrop","onDragLeave","BookOpenIcon","TrophyIcon","Deck","useParams","navigate","useNavigate","currentDeck","useDeckStore","state","loadDeck","isLoading","error","deckMasteryVersion","mastery","lastUpdated","getTime","getMasteredCards","resetDeckMastery","getSettingsForMode","useSettingsStore","selectedCard","setSelectedCard","showCardModal","setShowCardModal","setShowSettings","hasTranscripts","setHasTranscripts","useEffect","hasTranscriptsForDeck","then","masteredCardIndices","useMemo","filter","includes","masteredCardsList","FlashcardsIcon","route","LearnIcon","MatchIcon","ReadIcon","handleModeClick","useCallback","reading","Object","keys","dialogues","handleCardClick","closeCardModal","setTimeout","handleToggleMastered","getState","exit","charAt","toUpperCase","side_c","side_d","side_e","side_f","UnifiedSettings","visible","onClose","settings","frontSides","backSides","cardsPerRound","enableTimer","enableAudio","randomize","progressionMode","onUpdateSettings","onResetMastery"],"mappings":"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"}