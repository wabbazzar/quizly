{"version":3,"file":"Match-CVDv3uZD.js","sources":["../../src/components/modes/match/types.ts","../../src/store/matchSessionStore.ts","../../src/store/matchBestTimesStore.ts","../../src/components/ui/Modal.tsx","../../src/components/ui/Input.tsx","../../src/components/ui/ProgressBar.tsx","../../src/components/ui/LoadingScreen.tsx","../../src/components/modes/match/animations/matchAnimations.ts","../../src/components/modes/match/MatchCard.tsx","../../src/components/modes/match/MatchGrid.tsx","../../src/components/modes/match/MatchResults.tsx","../../src/utils/soundUtils.ts","../../src/components/modes/match/MatchContainer.tsx","../../src/pages/Match.tsx"],"sourcesContent":["import { Card, Deck } from '@/types';\n\n// Match-specific settings interface with required properties\nexport interface MatchSettings {\n  gridSize: { rows: number; cols: number };\n  matchType: 'two_way' | 'three_way' | 'custom';\n  cardSides: MatchCardSide[];\n  enableTimer: boolean;\n  includeMastered: boolean;\n  enableAudio: boolean;\n  timerSeconds: number; // 0 for count-up timer\n}\n\n// Configuration for card side groupings in match mode\nexport interface MatchCardSide {\n  sides: string[]; // e.g., ['side_a'] or ['side_b', 'side_c']\n  label: string; // Display label for this grouping\n  count: number; // Number of cards showing this side combination\n}\n\n// Individual match card in the grid\nexport interface MatchCard {\n  id: string;\n  cardIndex: number; // Original card index from deck\n  displaySides: string[]; // Which sides are shown (e.g., ['side_a'])\n  content: string; // Rendered content for display\n  groupId: string; // Cards with same groupId should match\n  isMatched: boolean;\n  isSelected: boolean;\n  position: { row: number; col: number };\n}\n\n// Complete match session state\nexport interface MatchSessionState {\n  deckId: string;\n  currentRound: number;\n  startTime: number;\n  pausedTime: number;\n  isPaused: boolean;\n  grid: MatchCard[];\n  selectedCards: string[]; // IDs of currently selected cards\n  matchedPairs: string[][]; // Groups of matched card IDs\n  missedCardIndices: number[]; // Original card indices that were missed\n  roundStartTime: number;\n  bestTime: number | null; // Best completion time in milliseconds\n  settings: MatchSettings;\n}\n\n// Match session store interface\nexport interface MatchSessionStore {\n  session: MatchSessionState | null;\n\n  // Session management\n  startSession: (deckId: string, settings: MatchSettings) => void;\n  pauseSession: () => void;\n  resumeSession: () => void;\n  endSession: () => void;\n\n  // Game actions\n  selectCard: (cardId: string) => void;\n  clearSelection: () => void;\n  processMatch: () => { isMatch: boolean; matchedCards?: string[] };\n\n  // Round management\n  startNewRound: (missedCards?: number[]) => void;\n  generateGrid: (cards: Card[], settings: MatchSettings) => MatchCard[];\n\n  // Persistence\n  saveSession: () => void;\n  loadSession: (deckId: string) => MatchSessionState | null;\n}\n\n// Match container component props\nexport interface MatchContainerProps {\n  deck: Deck;\n}\n\n// Match grid component props\nexport interface MatchGridProps {\n  cards: MatchCard[];\n  onCardSelect: (cardId: string) => void;\n  selectedCards: string[];\n  matchedCards: string[][];\n  gridSize: { rows: number; cols: number };\n  isAnimating: boolean;\n  animatingCards?: string[]; // Cards currently in animation state\n  isMobile?: boolean; // Mobile device detection for optimizations\n}\n\n// Individual match card component props\nexport interface MatchCardProps {\n  card: MatchCard;\n  isSelected: boolean;\n  isMatched: boolean;\n  isAnimating: boolean;\n  isCurrentlyAnimating?: boolean; // Whether this specific card is animating\n  onSelect: (cardId: string) => void;\n  position: { row: number; col: number };\n  isMobile?: boolean; // Mobile device detection for optimizations\n  prefersReducedMotion?: boolean; // Accessibility setting for reduced motion\n}\n\n// Match timer component props\nexport interface MatchTimerProps {\n  startTime: number;\n  pausedTime: number;\n  isPaused: boolean;\n  isComplete: boolean;\n  onPause?: () => void;\n  onResume?: () => void;\n}\n\n// Match results interface\nexport interface MatchResults {\n  deckId: string;\n  totalTime: number; // Time in milliseconds\n  bestTime: number | null; // Previous best time\n  isNewBest: boolean;\n  totalMatches: number;\n  missedCardIndices: number[];\n  roundNumber: number;\n  startTime: number;\n  endTime: number;\n}\n\n// Match completion modal props\nexport interface MatchResultsProps {\n  visible: boolean;\n  results: MatchResults | null;\n  onContinueWithMissed: () => void;\n  onStartNewRound: () => void;\n  onBackToDeck: () => void;\n  onClose: () => void;\n}\n\n// Default match settings\nexport const DEFAULT_MATCH_SETTINGS: MatchSettings = {\n  gridSize: { rows: 3, cols: 4 },\n  matchType: 'two_way',\n  cardSides: [\n    { sides: ['side_a'], label: 'Front', count: 6 },\n    { sides: ['side_b'], label: 'Back', count: 6 },\n  ],\n  enableTimer: true,\n  includeMastered: false,\n  enableAudio: false,\n  timerSeconds: 0, // Count-up timer\n};\n\n// Match validation utility types\nexport interface MatchValidationResult {\n  isValid: boolean;\n  matchedCards: string[];\n  matchType: 'two_way' | 'three_way' | 'custom';\n}\n\n// Card generation utility types\nexport interface CardGenerationOptions {\n  deck: Deck;\n  settings: MatchSettings;\n  excludeMastered: boolean;\n  masteredIndices: number[];\n}\n\n// Grid layout utility types\nexport interface GridPosition {\n  row: number;\n  col: number;\n  index: number;\n}\n\n// Animation state management\nexport interface MatchAnimationState {\n  isAnimating: boolean;\n  animationType: 'select' | 'match' | 'mismatch' | 'complete' | null;\n  animatingCards: string[];\n}\n\n// Sound feedback types\nexport interface MatchSoundEvents {\n  onSelect: () => void;\n  onMatch: () => void;\n  onMismatch: () => void;\n  onComplete: () => void;\n}\n\n// Error types for match mode\nexport interface MatchError {\n  type: 'GENERATION_ERROR' | 'VALIDATION_ERROR' | 'PERSISTENCE_ERROR' | 'GRID_ERROR';\n  message: string;\n  code?: string;\n  details?: any;\n}\n\n// Session restoration types\nexport interface SessionRestoration {\n  shouldRestore: boolean;\n  session: MatchSessionState | null;\n  isExpired: boolean;\n  errorMessage?: string;\n}","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport {\n  MatchSessionState,\n  MatchSessionStore,\n  MatchSettings,\n  MatchCard,\n  DEFAULT_MATCH_SETTINGS,\n  MatchValidationResult,\n} from '@/components/modes/match/types';\nimport { Card } from '@/types';\n\nconst SESSION_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n// Utility function to generate unique card IDs\nconst generateCardId = (cardIndex: number, sideGroup: string, position: number): string => {\n  return `${cardIndex}-${sideGroup}-${position}`;\n};\n\n// Utility function to generate group ID for matching\nconst generateGroupId = (cardIndex: number): string => {\n  return `group-${cardIndex}`;\n};\n\n// Utility function to shuffle array\nconst shuffleArray = <T>(array: T[]): T[] => {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n};\n\n// Generate match cards from deck cards\nconst generateMatchCards = (\n  cards: Card[],\n  settings: MatchSettings,\n  excludeMastered: boolean = false,\n  masteredIndices: number[] = []\n): MatchCard[] => {\n  const { gridSize, matchType } = settings;\n  const totalSlots = gridSize.rows * gridSize.cols;\n\n  // Filter cards if excluding mastered\n  let availableCards = excludeMastered\n    ? cards.filter((_, index) => !masteredIndices.includes(index))\n    : cards;\n\n  // Calculate how many source cards we need based on match type\n  let cardsPerGroup = 2; // Default for two_way\n  if (matchType === 'three_way') {\n    cardsPerGroup = 3;\n  }\n\n  const maxGroups = Math.floor(totalSlots / cardsPerGroup);\n\n  // Ensure we have enough cards\n  if (availableCards.length < maxGroups) {\n    // If not enough cards, use all available and potentially repeat some\n    const needed = maxGroups - availableCards.length;\n    const repeated = shuffleArray(availableCards).slice(0, needed);\n    availableCards = [...availableCards, ...repeated];\n  }\n\n  // Select cards for this round\n  const selectedCards = shuffleArray(availableCards).slice(0, maxGroups);\n  const matchCards: MatchCard[] = [];\n\n  // Generate match cards based on match type\n  selectedCards.forEach((card) => {\n    const groupId = generateGroupId(card.idx);\n\n    if (matchType === 'two_way') {\n      // Create two cards: one showing side_a, one showing side_b\n      // Card 1: Shows side_a (the question/term)\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_a', 0),\n        cardIndex: card.idx,\n        displaySides: ['side_a'],\n        content: (card.side_a || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 2: Shows side_b (the answer/definition)\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_b', 1),\n        cardIndex: card.idx,\n        displaySides: ['side_b'],\n        content: (card.side_b || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n    } else if (matchType === 'three_way') {\n      // Create three cards: showing side_a, side_b, and side_c\n      // Card 1: Shows side_a\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_a', 0),\n        cardIndex: card.idx,\n        displaySides: ['side_a'],\n        content: (card.side_a || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 2: Shows side_b\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_b', 1),\n        cardIndex: card.idx,\n        displaySides: ['side_b'],\n        content: (card.side_b || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 3: Shows side_c\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_c', 2),\n        cardIndex: card.idx,\n        displaySides: ['side_c'],\n        content: (card.side_c || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n    } else {\n      // Custom mode: use the cardSides configuration from settings\n      if (settings.cardSides && settings.cardSides.length > 0) {\n        settings.cardSides.forEach((cardSide, index) => {\n          const sideKey = cardSide.sides[0]; // e.g., 'side_a', 'side_b', 'side_c'\n          const sideContent = (card as any)[sideKey] || '';\n\n          matchCards.push({\n            id: generateCardId(card.idx, sideKey, index),\n            cardIndex: card.idx,\n            displaySides: [sideKey],\n            content: sideContent.trim(),\n            groupId,\n            isMatched: false,\n            isSelected: false,\n            position: { row: 0, col: 0 },\n          });\n        });\n      } else {\n        // Fallback to two-way if not properly configured\n        matchCards.push({\n          id: generateCardId(card.idx, 'side_a', 0),\n          cardIndex: card.idx,\n          displaySides: ['side_a'],\n          content: (card.side_a || '').trim(),\n          groupId,\n          isMatched: false,\n          isSelected: false,\n          position: { row: 0, col: 0 },\n        });\n\n        matchCards.push({\n          id: generateCardId(card.idx, 'side_b', 1),\n          cardIndex: card.idx,\n          displaySides: ['side_b'],\n          content: (card.side_b || '').trim(),\n          groupId,\n          isMatched: false,\n          isSelected: false,\n          position: { row: 0, col: 0 },\n        });\n      }\n    }\n  });\n\n  // Shuffle and place cards on grid\n  const shuffledCards = shuffleArray(matchCards);\n\n  // Assign grid positions\n  shuffledCards.forEach((card, index) => {\n    const row = Math.floor(index / gridSize.cols);\n    const col = index % gridSize.cols;\n    card.position = { row, col };\n  });\n\n  return shuffledCards.slice(0, totalSlots);\n};\n\n// Validate if selected cards form a match\nconst validateMatch = (\n  selectedCards: MatchCard[],\n  matchType: 'two_way' | 'three_way' | 'custom'\n): MatchValidationResult => {\n  if (selectedCards.length < 2) {\n    return { isValid: false, matchedCards: [], matchType };\n  }\n\n  // Check if all selected cards have the same group ID\n  const firstGroupId = selectedCards[0].groupId;\n  const allSameGroup = selectedCards.every(card => card.groupId === firstGroupId);\n\n  // Check for match type requirements\n  let isValidCount = false;\n  switch (matchType) {\n    case 'two_way':\n      isValidCount = selectedCards.length === 2;\n      break;\n    case 'three_way':\n      isValidCount = selectedCards.length === 3;\n      break;\n    case 'custom':\n      isValidCount = selectedCards.length >= 2;\n      break;\n  }\n\n  const isValid = allSameGroup && isValidCount;\n  const matchedCards = isValid ? selectedCards.map(card => card.id) : [];\n\n  return { isValid, matchedCards, matchType };\n};\n\nexport const useMatchSessionStore = create<MatchSessionStore>()(\n  persist(\n    (set, get) => ({\n      session: null,\n\n      startSession: (deckId: string, settings: MatchSettings = DEFAULT_MATCH_SETTINGS) => {\n        const startTime = Date.now();\n        const newSession: MatchSessionState = {\n          deckId,\n          currentRound: 1,\n          startTime,\n          pausedTime: 0,\n          isPaused: false,\n          grid: [],\n          selectedCards: [],\n          matchedPairs: [],\n          missedCardIndices: [],\n          roundStartTime: startTime,\n          bestTime: null,\n          settings,\n        };\n\n        set({ session: newSession });\n      },\n\n      pauseSession: () => {\n        const { session } = get();\n        if (session && !session.isPaused) {\n          set({\n            session: {\n              ...session,\n              isPaused: true,\n              pausedTime: Date.now(),\n            },\n          });\n        }\n      },\n\n      resumeSession: () => {\n        const { session } = get();\n        if (session && session.isPaused) {\n          const pauseDuration = Date.now() - session.pausedTime;\n          set({\n            session: {\n              ...session,\n              isPaused: false,\n              pausedTime: 0,\n              roundStartTime: session.roundStartTime + pauseDuration,\n            },\n          });\n        }\n      },\n\n      endSession: () => {\n        set({ session: null });\n      },\n\n      selectCard: (cardId: string) => {\n        const { session } = get();\n        if (!session || session.isPaused) return;\n\n        const card = session.grid.find(c => c.id === cardId);\n        if (!card || card.isMatched) return;\n\n        let newSelectedCards: string[];\n        let newGrid = [...session.grid];\n\n        if (session.selectedCards.includes(cardId)) {\n          // Deselect card\n          newSelectedCards = session.selectedCards.filter(id => id !== cardId);\n          newGrid = newGrid.map(c =>\n            c.id === cardId ? { ...c, isSelected: false } : c\n          );\n        } else {\n          // Select card\n          newSelectedCards = [...session.selectedCards, cardId];\n          newGrid = newGrid.map(c =>\n            c.id === cardId ? { ...c, isSelected: true } : c\n          );\n        }\n\n        set({\n          session: {\n            ...session,\n            selectedCards: newSelectedCards,\n            grid: newGrid,\n          },\n        });\n      },\n\n      clearSelection: () => {\n        const { session } = get();\n        if (!session) return;\n\n        const newGrid = session.grid.map(card => ({\n          ...card,\n          isSelected: false,\n        }));\n\n        set({\n          session: {\n            ...session,\n            selectedCards: [],\n            grid: newGrid,\n          },\n        });\n      },\n\n      processMatch: () => {\n        const { session } = get();\n        if (!session || session.selectedCards.length === 0) {\n          return { isMatch: false };\n        }\n\n        const selectedCardObjects = session.grid.filter(card =>\n          session.selectedCards.includes(card.id)\n        );\n\n        const validationResult = validateMatch(\n          selectedCardObjects,\n          session.settings.matchType\n        );\n\n        if (validationResult.isValid) {\n          // Mark cards as matched\n          const newGrid = session.grid.map(card =>\n            validationResult.matchedCards.includes(card.id)\n              ? { ...card, isMatched: true, isSelected: false }\n              : { ...card, isSelected: false }\n          );\n\n          const newMatchedPairs = [...session.matchedPairs, validationResult.matchedCards];\n\n          set({\n            session: {\n              ...session,\n              grid: newGrid,\n              selectedCards: [],\n              matchedPairs: newMatchedPairs,\n            },\n          });\n\n          return { isMatch: true, matchedCards: validationResult.matchedCards };\n        } else {\n          // Clear selection for mismatch\n          get().clearSelection();\n          return { isMatch: false };\n        }\n      },\n\n      startNewRound: (missedCards?: number[]) => {\n        const { session } = get();\n        if (!session) return;\n\n        set({\n          session: {\n            ...session,\n            currentRound: session.currentRound + 1,\n            roundStartTime: Date.now(),\n            grid: [],\n            selectedCards: [],\n            matchedPairs: [],\n            missedCardIndices: missedCards || [],\n          },\n        });\n      },\n\n      generateGrid: (cards: Card[], settings: MatchSettings) => {\n        const { session } = get();\n        if (!session) return [];\n\n        const newGrid = generateMatchCards(cards, settings);\n\n        set({\n          session: {\n            ...session,\n            grid: newGrid,\n          },\n        });\n\n        return newGrid;\n      },\n\n      saveSession: () => {\n        // Session is automatically saved via persist middleware\n      },\n\n      loadSession: (deckId: string) => {\n        const { session } = get();\n        if (session && session.deckId === deckId) {\n          // Check if session is expired\n          if (Date.now() - session.startTime > SESSION_EXPIRY_MS) {\n            set({ session: null });\n            return null;\n          }\n          return session;\n        }\n        return null;\n      },\n    }),\n    {\n      name: 'match-session-store',\n      // Custom storage to handle complex objects\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          try {\n            const { state } = JSON.parse(str);\n            return { state };\n          } catch (error) {\n            console.warn('Failed to parse match session storage:', error);\n            return null;\n          }\n        },\n        setItem: (name, value) => {\n          try {\n            const { state } = value;\n            localStorage.setItem(name, JSON.stringify({ state }));\n          } catch (error) {\n            console.warn('Failed to save match session storage:', error);\n          }\n        },\n        removeItem: name => localStorage.removeItem(name),\n      },\n      // Only persist essential session data\n      partialize: state => ({\n        session: state.session,\n      }),\n    }\n  )\n);\n\n// Utility functions for external use\nexport {\n  generateMatchCards,\n  validateMatch,\n  shuffleArray,\n  generateCardId,\n  generateGroupId,\n};","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport interface MatchBestTime {\n  deckId: string;\n  bestTimeMs: number;\n  achievedAt: Date;\n  gridSize: { rows: number; cols: number };\n  matchType: 'two_way' | 'three_way' | 'custom';\n  totalMatches: number;\n}\n\ninterface MatchBestTimesStore {\n  // Best times data by deck ID\n  bestTimes: Record<string, MatchBestTime>;\n\n  // Actions\n  updateBestTime: (\n    deckId: string,\n    timeMs: number,\n    gridSize: { rows: number; cols: number },\n    matchType: 'two_way' | 'three_way' | 'custom',\n    totalMatches: number\n  ) => boolean; // Returns true if new best time was set\n  getBestTime: (deckId: string) => MatchBestTime | null;\n  hasBestTime: (deckId: string) => boolean;\n  clearBestTime: (deckId: string) => void;\n  clearAllBestTimes: () => void;\n  getAllBestTimes: () => MatchBestTime[];\n  getDeckStats: (deckId: string) => {\n    bestTime: MatchBestTime | null;\n    formattedTime: string;\n    hasRecord: boolean;\n  };\n}\n\n// Utility function to format time in MM:SS format\nexport const formatMatchTime = (timeMs: number): string => {\n  const totalSeconds = Math.floor(timeMs / 1000);\n  const minutes = Math.floor(totalSeconds / 60);\n  const seconds = totalSeconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n};\n\nexport const useMatchBestTimesStore = create<MatchBestTimesStore>()(\n  persist(\n    (set, get) => ({\n      bestTimes: {},\n\n      updateBestTime: (\n        deckId: string,\n        timeMs: number,\n        gridSize: { rows: number; cols: number },\n        matchType: 'two_way' | 'three_way' | 'custom',\n        totalMatches: number\n      ) => {\n        const currentBest = get().bestTimes[deckId];\n        const isNewBest = !currentBest || timeMs < currentBest.bestTimeMs;\n\n        if (isNewBest) {\n          set(state => ({\n            bestTimes: {\n              ...state.bestTimes,\n              [deckId]: {\n                deckId,\n                bestTimeMs: timeMs,\n                achievedAt: new Date(),\n                gridSize: { ...gridSize },\n                matchType,\n                totalMatches,\n              },\n            },\n          }));\n          return true;\n        }\n\n        return false;\n      },\n\n      getBestTime: (deckId: string) => {\n        return get().bestTimes[deckId] || null;\n      },\n\n      hasBestTime: (deckId: string) => {\n        return deckId in get().bestTimes;\n      },\n\n      clearBestTime: (deckId: string) => {\n        set(state => {\n          const newBestTimes = { ...state.bestTimes };\n          delete newBestTimes[deckId];\n          return { bestTimes: newBestTimes };\n        });\n      },\n\n      clearAllBestTimes: () => {\n        set({ bestTimes: {} });\n      },\n\n      getAllBestTimes: () => {\n        return Object.values(get().bestTimes);\n      },\n\n      getDeckStats: (deckId: string) => {\n        const bestTime = get().bestTimes[deckId] || null;\n        return {\n          bestTime,\n          formattedTime: bestTime ? formatMatchTime(bestTime.bestTimeMs) : '--:--',\n          hasRecord: !!bestTime,\n        };\n      },\n    }),\n    {\n      name: 'match-best-times-store',\n      // Custom storage to handle Date objects\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          const parsed = JSON.parse(str);\n          if (parsed.state && parsed.state.bestTimes) {\n            // Convert date strings back to Date objects\n            Object.keys(parsed.state.bestTimes).forEach(deckId => {\n              const bestTime = parsed.state.bestTimes[deckId];\n              if (bestTime.achievedAt) {\n                bestTime.achievedAt = new Date(bestTime.achievedAt);\n              }\n            });\n          }\n          return parsed;\n        },\n        setItem: (name, value) => {\n          localStorage.setItem(name, JSON.stringify(value));\n        },\n        removeItem: name => {\n          localStorage.removeItem(name);\n        },\n      },\n    }\n  )\n);","import { FC, memo, useEffect, useCallback, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { ModalProps } from './types';\nimport { Button } from './Button';\nimport styles from './Modal.module.css';\n\nexport const Modal: FC<ModalProps> = memo(\n  ({\n    isOpen,\n    onClose,\n    title,\n    children,\n    size = 'medium',\n    showCloseButton = true,\n    closeOnOverlayClick = true,\n    className = '',\n    footer,\n  }) => {\n    const modalRef = useRef<HTMLDivElement>(null);\n    const previousActiveElement = useRef<Element | null>(null);\n\n    // Handle escape key\n    const handleEscape = useCallback(\n      (e: KeyboardEvent) => {\n        if (e.key === 'Escape') {\n          onClose();\n        }\n      },\n      [onClose]\n    );\n\n    // Handle overlay click\n    const handleOverlayClick = useCallback(\n      (e: React.MouseEvent) => {\n        if (closeOnOverlayClick && e.target === e.currentTarget) {\n          onClose();\n        }\n      },\n      [closeOnOverlayClick, onClose]\n    );\n\n    // Focus management\n    useEffect(() => {\n      if (isOpen) {\n        // Store currently focused element\n        previousActiveElement.current = document.activeElement;\n\n        // Add escape listener\n        document.addEventListener('keydown', handleEscape);\n\n        // Prevent body scroll\n        document.body.style.overflow = 'hidden';\n\n        // Focus modal\n        if (modalRef.current) {\n          modalRef.current.focus();\n        }\n\n        return () => {\n          document.removeEventListener('keydown', handleEscape);\n          document.body.style.overflow = '';\n\n          // Restore focus to previous element\n          if (previousActiveElement.current instanceof HTMLElement) {\n            previousActiveElement.current.focus();\n          }\n        };\n      }\n      return undefined;\n    }, [isOpen, handleEscape]);\n\n    if (!isOpen) return null;\n\n    const modalClasses = [styles.modal, styles[size], className].filter(Boolean).join(' ');\n\n    const modalContent = (\n      <div className={styles.overlay} onClick={handleOverlayClick} aria-modal=\"true\" role=\"dialog\">\n        <div\n          className={modalClasses}\n          ref={modalRef}\n          tabIndex={-1}\n          role=\"document\"\n          aria-labelledby={title ? 'modal-title' : undefined}\n        >\n          {(title || showCloseButton) && (\n            <header className={styles.header}>\n              {title && (\n                <h2 id=\"modal-title\" className={styles.title}>\n                  {title}\n                </h2>\n              )}\n              {showCloseButton && (\n                <Button\n                  variant=\"tertiary\"\n                  size=\"small\"\n                  onClick={onClose}\n                  className={styles.closeButton}\n                  aria-label=\"Close modal\"\n                >\n                  <svg\n                    width=\"20\"\n                    height=\"20\"\n                    viewBox=\"0 0 20 20\"\n                    fill=\"none\"\n                    xmlns=\"http://www.w3.org/2000/svg\"\n                    aria-hidden=\"true\"\n                  >\n                    <path\n                      d=\"M15 5L5 15M5 5L15 15\"\n                      stroke=\"currentColor\"\n                      strokeWidth=\"2\"\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                    />\n                  </svg>\n                </Button>\n              )}\n            </header>\n          )}\n          <div className={styles.content}>{children}</div>\n          {footer && <footer className={styles.footer}>{footer}</footer>}\n        </div>\n      </div>\n    );\n\n    // Portal to body\n    return createPortal(modalContent, document.body);\n  }\n);\n\nModal.displayName = 'Modal';\n","import { FC, memo, forwardRef } from 'react';\nimport { InputProps } from './types';\nimport styles from './Input.module.css';\n\nexport const Input: FC<InputProps> = memo(\n  forwardRef<HTMLInputElement, InputProps>(\n    (\n      {\n        label,\n        error,\n        helperText,\n        variant = 'default',\n        fullWidth = false,\n        startIcon,\n        endIcon,\n        className = '',\n        id,\n        ...rest\n      },\n      ref\n    ) => {\n      const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`;\n\n      const containerClasses = [styles.container, fullWidth && styles.fullWidth, className]\n        .filter(Boolean)\n        .join(' ');\n\n      const inputWrapperClasses = [\n        styles.inputWrapper,\n        styles[variant],\n        error && styles.error,\n        (startIcon || endIcon) && styles.withIcon,\n      ]\n        .filter(Boolean)\n        .join(' ');\n\n      return (\n        <div className={containerClasses}>\n          {label && (\n            <label htmlFor={inputId} className={styles.label}>\n              {label}\n            </label>\n          )}\n          <div className={inputWrapperClasses}>\n            {startIcon && (\n              <span className={styles.startIcon} aria-hidden=\"true\">\n                {startIcon}\n              </span>\n            )}\n            <input\n              ref={ref}\n              id={inputId}\n              className={styles.input}\n              aria-invalid={!!error}\n              aria-describedby={\n                error ? `${inputId}-error` : helperText ? `${inputId}-helper` : undefined\n              }\n              {...rest}\n            />\n            {endIcon && (\n              <span className={styles.endIcon} aria-hidden=\"true\">\n                {endIcon}\n              </span>\n            )}\n          </div>\n          {error && (\n            <span id={`${inputId}-error`} className={styles.errorText} role=\"alert\">\n              {error}\n            </span>\n          )}\n          {helperText && !error && (\n            <span id={`${inputId}-helper`} className={styles.helperText}>\n              {helperText}\n            </span>\n          )}\n        </div>\n      );\n    }\n  )\n);\n\nInput.displayName = 'Input';\n","import { FC, memo } from 'react';\nimport { ProgressBarProps } from './types';\nimport styles from './ProgressBar.module.css';\n\nexport const ProgressBar: FC<ProgressBarProps> = memo(\n  ({\n    value,\n    max = 100,\n    variant = 'default',\n    size = 'medium',\n    showLabel = false,\n    animated = true,\n  }) => {\n    const percentage = Math.min(Math.max((value / max) * 100, 0), 100);\n\n    const containerClasses = [styles.container, styles[size]].filter(Boolean).join(' ');\n\n    const barClasses = [styles.bar, styles[variant], animated && styles.animated]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={containerClasses}>\n        <div\n          className={styles.track}\n          role=\"progressbar\"\n          aria-valuenow={value}\n          aria-valuemin={0}\n          aria-valuemax={max}\n        >\n          <div className={barClasses} style={{ width: `${percentage}%` }} />\n        </div>\n        {showLabel && <span className={styles.label}>{Math.round(percentage)}%</span>}\n      </div>\n    );\n  }\n);\n\nProgressBar.displayName = 'ProgressBar';\n","import { FC, memo } from 'react';\nimport { LoadingScreenProps } from './types';\nimport { Spinner } from './Spinner';\nimport styles from './LoadingScreen.module.css';\n\nexport const LoadingScreen: FC<LoadingScreenProps> = memo(\n  ({ message = 'Loading...', fullScreen = true }) => {\n    const containerClasses = [styles.container, fullScreen && styles.fullScreen]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={containerClasses} role=\"status\" aria-live=\"polite\">\n        <div className={styles.content}>\n          <Spinner size=\"large\" variant=\"primary\" />\n          <p className={styles.message}>{message}</p>\n        </div>\n      </div>\n    );\n  }\n);\n\nLoadingScreen.displayName = 'LoadingScreen';\n","import { Variants, Transition } from 'framer-motion';\n\n/**\n * Animation configurations for Match Mode components\n *\n * Provides smooth, 60 FPS animations optimized for mobile performance:\n * - Match success feedback with celebration effects\n * - Card removal animations for successful matches\n * - Grid state transitions and updates\n * - Mobile performance optimizations using GPU acceleration\n */\n\n// Common transition settings optimized for performance\nconst FAST_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 300,\n  damping: 30,\n  mass: 0.8,\n};\n\nconst SMOOTH_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 200,\n  damping: 25,\n  mass: 1,\n};\n\nconst CELEBRATION_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 400,\n  damping: 20,\n  mass: 0.6,\n};\n\n/**\n * Card match success animation variants\n * Provides satisfying feedback when cards are successfully matched\n */\nexport const matchSuccessVariants: Variants = {\n  initial: {\n    scale: 1,\n    rotate: 0,\n    opacity: 1,\n    filter: 'brightness(1) saturate(1)',\n    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',\n  },\n  matching: {\n    scale: [1, 1.05, 1.1],\n    rotate: [0, -2, 2, 0],\n    filter: 'brightness(1.2) saturate(1.3)',\n    boxShadow: [\n      '0 2px 8px rgba(0, 0, 0, 0.1)',\n      '0 8px 25px rgba(74, 144, 226, 0.3)',\n      '0 12px 35px rgba(74, 144, 226, 0.4)',\n    ],\n    transition: {\n      duration: 0.4,\n      times: [0, 0.5, 1],\n      ease: 'easeOut',\n    },\n  },\n  matched: {\n    scale: 0.95,\n    opacity: 0.7,\n    filter: 'brightness(0.9) saturate(0.8)',\n    borderColor: 'var(--semantic-success)',\n    backgroundColor: 'rgba(16, 185, 129, 0.1)',\n    transition: SMOOTH_TRANSITION,\n  },\n  removing: {\n    scale: [0.95, 1.1, 0],\n    rotate: [0, 5, -5, 0],\n    opacity: [0.7, 1, 0],\n    filter: 'brightness(1.3) saturate(1.5)',\n    y: [0, -10, -20],\n    transition: {\n      duration: 0.6,\n      times: [0, 0.3, 1],\n      ease: [0.4, 0, 0.2, 1],\n    },\n  },\n};\n\n/**\n * Card mismatch feedback animation variants\n * Subtle shake animation for incorrect matches\n */\nexport const matchMismatchVariants: Variants = {\n  initial: {\n    x: 0,\n    scale: 1,\n    filter: 'brightness(1)',\n  },\n  mismatch: {\n    x: [-2, 2, -2, 2, 0],\n    scale: [1, 0.98, 1],\n    filter: ['brightness(1)', 'brightness(1.1)', 'brightness(1)'],\n    transition: {\n      duration: 0.5,\n      times: [0, 0.25, 0.5, 0.75, 1],\n      ease: 'easeInOut',\n    },\n  },\n};\n\n/**\n * Card selection animation variants\n * Visual feedback for card tap/click interactions\n */\nexport const cardSelectionVariants: Variants = {\n  unselected: {\n    scale: 1,\n    borderColor: 'var(--border-color)',\n    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',\n    filter: 'brightness(1)',\n    y: 0,\n    transition: FAST_TRANSITION,\n  },\n  selected: {\n    scale: 1.02,\n    borderColor: 'var(--primary-main)',\n    boxShadow: '0 6px 20px rgba(74, 144, 226, 0.25)',\n    filter: 'brightness(1.05)',\n    y: -2,\n    transition: FAST_TRANSITION,\n  },\n  hover: {\n    scale: 1.01,\n    y: -1,\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Grid layout animation variants\n * Smooth transitions when grid content changes\n */\nexport const gridLayoutVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.9,\n  },\n  animate: {\n    opacity: 1,\n    scale: 1,\n    transition: {\n      duration: 0.3,\n      staggerChildren: 0.05,\n      delayChildren: 0.1,\n    },\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.95,\n    transition: {\n      duration: 0.2,\n      staggerChildren: 0.03,\n      staggerDirection: -1,\n    },\n  },\n};\n\n/**\n * Individual card entry animation variants\n * Staggered entrance for grid cards\n */\nexport const cardEntryVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.8,\n    y: 20,\n    rotateY: -90,\n  },\n  animate: {\n    opacity: 1,\n    scale: 1,\n    y: 0,\n    rotateY: 0,\n    transition: SMOOTH_TRANSITION,\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.8,\n    y: -10,\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Match celebration animation variants\n * Particles and effects for successful matches\n */\nexport const celebrationVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0,\n    rotate: 0,\n  },\n  celebrate: {\n    opacity: [0, 1, 1, 0],\n    scale: [0, 1.2, 1.5, 0],\n    rotate: [0, 180, 360],\n    transition: {\n      duration: 1,\n      times: [0, 0.2, 0.8, 1],\n      ease: 'easeOut',\n    },\n  },\n};\n\n/**\n * Progress bar animation variants\n * Smooth progress updates with elastic feel\n */\nexport const progressVariants: Variants = {\n  initial: {\n    scaleX: 0,\n    originX: 0,\n  },\n  animate: {\n    scaleX: 1,\n    transition: {\n      ...CELEBRATION_TRANSITION,\n      duration: 0.8,\n    },\n  },\n};\n\n/**\n * Game completion animation variants\n * Final celebration when all matches are found\n */\nexport const gameCompleteVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.5,\n    y: 50,\n  },\n  animate: {\n    opacity: 1,\n    scale: [0.5, 1.1, 1],\n    y: 0,\n    transition: {\n      duration: 0.6,\n      times: [0, 0.6, 1],\n      ease: 'easeOut',\n    },\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.9,\n    y: -20,\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Pause overlay animation variants\n * Smooth fade for pause state\n */\nexport const pauseOverlayVariants: Variants = {\n  initial: {\n    opacity: 0,\n    backdropFilter: 'blur(0px)',\n  },\n  animate: {\n    opacity: 1,\n    backdropFilter: 'blur(8px)',\n    transition: {\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  },\n  exit: {\n    opacity: 0,\n    backdropFilter: 'blur(0px)',\n    transition: {\n      duration: 0.2,\n      ease: 'easeIn',\n    },\n  },\n};\n\n/**\n * Performance-optimized spring configuration\n * Reduces motion for lower-end devices\n */\nexport const getOptimizedTransition = (isLowPerformance = false): Transition => {\n  if (isLowPerformance) {\n    return {\n      type: 'tween',\n      duration: 0.2,\n      ease: 'easeOut',\n    };\n  }\n\n  return SMOOTH_TRANSITION;\n};\n\n/**\n * Utility function to create staggered animations\n */\nexport const createStaggeredAnimation = (\n  delay = 0.05,\n  duration = 0.3\n): Transition => ({\n  duration,\n  staggerChildren: delay,\n  delayChildren: delay,\n});\n\n/**\n * Mobile performance optimizations\n * Reduces complexity for touch devices\n */\nexport const getMobileOptimizedVariants = (\n  variants: Variants,\n  isMobile = false\n): Variants => {\n  if (!isMobile) return variants;\n\n  // Simplify animations for mobile\n  return Object.entries(variants).reduce((acc, [key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      const mobileValue = { ...value };\n\n      // Remove complex transformations\n      if ('filter' in mobileValue) delete mobileValue.filter;\n      if ('boxShadow' in mobileValue && Array.isArray(mobileValue.boxShadow)) {\n        mobileValue.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';\n      }\n\n      // Reduce scale changes\n      if ('scale' in mobileValue && Array.isArray(mobileValue.scale)) {\n        const scaleArray = mobileValue.scale as number[];\n        mobileValue.scale = [scaleArray[0], scaleArray[scaleArray.length - 1]];\n      }\n\n      acc[key] = mobileValue;\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {} as Variants);\n};\n\n/**\n * Reduced motion variants for accessibility\n */\nexport const getReducedMotionVariants = (variants: Variants): Variants => {\n  return Object.entries(variants).reduce((acc, [key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      const reducedValue = { ...value };\n\n      // Remove scale and rotation animations\n      if ('scale' in reducedValue) reducedValue.scale = 1;\n      if ('rotate' in reducedValue) reducedValue.rotate = 0;\n      if ('rotateY' in reducedValue) reducedValue.rotateY = 0;\n\n      // Keep only opacity and basic position changes\n      const allowedProps = ['opacity', 'x', 'y', 'backgroundColor', 'borderColor'];\n      Object.keys(reducedValue).forEach(prop => {\n        if (!allowedProps.includes(prop) && prop !== 'transition') {\n          delete reducedValue[prop as keyof typeof reducedValue];\n        }\n      });\n\n      // Simplify transitions\n      if (reducedValue.transition) {\n        reducedValue.transition = { duration: 0.1 };\n      }\n\n      acc[key] = reducedValue;\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {} as Variants);\n};\n\nexport default {\n  matchSuccessVariants,\n  matchMismatchVariants,\n  cardSelectionVariants,\n  gridLayoutVariants,\n  cardEntryVariants,\n  celebrationVariants,\n  progressVariants,\n  gameCompleteVariants,\n  pauseOverlayVariants,\n  getOptimizedTransition,\n  createStaggeredAnimation,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n};","import { FC, memo, useCallback } from 'react';\nimport { motion } from 'framer-motion';\nimport { MatchCardProps } from './types';\nimport {\n  cardSelectionVariants,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n} from './animations/matchAnimations';\nimport styles from './MatchCard.module.css';\n\nconst MatchCard: FC<MatchCardProps> = memo(({\n  card,\n  isSelected,\n  isMatched,\n  isAnimating,\n  isCurrentlyAnimating = false,\n  onSelect,\n  position,\n  isMobile = false,\n  prefersReducedMotion = false,\n}) => {\n  // Handle card selection with haptic feedback for mobile devices\n  const handleCardClick = useCallback(() => {\n    if (isMatched || isAnimating) return;\n\n    onSelect(card.id);\n  }, [card.id, isMatched, isAnimating, onSelect]);\n\n  // Handle keyboard interaction\n  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      handleCardClick();\n    }\n  }, [handleCardClick]);\n\n  // Get appropriate animation variants\n  const getCardVariants = () => {\n    let variants = cardSelectionVariants;\n\n    if (prefersReducedMotion) {\n      variants = getReducedMotionVariants(variants);\n    } else if (isMobile) {\n      variants = getMobileOptimizedVariants(variants, true);\n    }\n\n    return variants;\n  };\n\n  // Determine current animation state\n  const getAnimationState = () => {\n    if (isCurrentlyAnimating) {\n      return isMatched ? 'removing' : 'matching';\n    }\n    if (isMatched) {\n      return 'matched';\n    }\n    if (isSelected) {\n      return 'selected';\n    }\n    return 'unselected';\n  };\n\n  const cardVariants = getCardVariants();\n  const animationState = getAnimationState();\n\n  return (\n    <motion.div\n      className={`${styles.card} ${isSelected ? styles.selected : ''} ${isMatched ? styles.matched : ''} ${isCurrentlyAnimating ? styles.animating : ''}`}\n      style={{\n        gridRow: position.row + 1,\n        gridColumn: position.col + 1,\n      }}\n      onClick={handleCardClick}\n      onKeyDown={handleKeyDown}\n      role=\"button\"\n      tabIndex={isMatched ? -1 : 0}\n      aria-label={`Match card: ${card.content}`}\n      aria-pressed={isSelected}\n      aria-disabled={isMatched}\n      data-testid={`match-card-${card.id}`}\n      // Enhanced Framer Motion animations\n      variants={cardVariants}\n      initial=\"unselected\"\n      animate={animationState}\n      exit=\"exit\"\n      whileHover={!isMatched && !prefersReducedMotion ? 'hover' : undefined}\n      whileTap={!isMatched && !prefersReducedMotion ? { scale: 0.98 } : undefined}\n      layout\n      layoutId={card.id}\n    >\n      <div className={styles.content}>\n        {card.content}\n      </div>\n\n      {/* Selection indicator */}\n      {isSelected && (\n        <motion.div\n          className={styles.selectionIndicator}\n          initial={{ scale: 0, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          exit={{ scale: 0, opacity: 0 }}\n          transition={{ duration: 0.2 }}\n        />\n      )}\n\n      {/* Match indicator */}\n      {isMatched && (\n        <motion.div\n          className={styles.matchIndicator}\n          initial={{ scale: 0, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          transition={{ duration: 0.3, delay: 0.1 }}\n        >\n          ✓\n        </motion.div>\n      )}\n\n      {/* Touch target overlay for better mobile interaction */}\n      <div className={styles.touchTarget} />\n    </motion.div>\n  );\n});\n\nMatchCard.displayName = 'MatchCard';\n\nexport default MatchCard;","import { FC, memo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { MatchGridProps } from './types';\nimport MatchCard from './MatchCard';\nimport {\n  gridLayoutVariants,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n} from './animations/matchAnimations';\nimport styles from './MatchGrid.module.css';\n\nconst MatchGrid: FC<MatchGridProps> = memo(({\n  cards,\n  onCardSelect,\n  selectedCards,\n  matchedCards,\n  gridSize,\n  isAnimating,\n  animatingCards = [],\n  isMobile = false,\n}) => {\n  // Flatten matched cards array for easier lookup\n  const matchedCardIds = new Set(matchedCards.flat());\n\n  // Check for reduced motion preference\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n  // Get appropriate animation variants\n  let gridVariants = gridLayoutVariants;\n  if (prefersReducedMotion) {\n    gridVariants = getReducedMotionVariants(gridLayoutVariants);\n  } else if (isMobile) {\n    gridVariants = getMobileOptimizedVariants(gridLayoutVariants, true);\n  }\n\n  return (\n    <motion.div\n      className={styles.grid}\n      style={{\n        gridTemplateRows: `repeat(${gridSize.rows}, 1fr)`,\n        gridTemplateColumns: `repeat(${gridSize.cols}, 1fr)`,\n      }}\n      variants={gridVariants}\n      initial=\"initial\"\n      animate=\"animate\"\n      exit=\"exit\"\n      role=\"grid\"\n      aria-label=\"Match game grid\"\n      data-testid=\"match-grid\"\n    >\n      <AnimatePresence mode=\"popLayout\">\n        {cards.map((card) => (\n          <MatchCard\n            key={card.id}\n            card={card}\n            isSelected={selectedCards.includes(card.id)}\n            isMatched={matchedCardIds.has(card.id)}\n            isAnimating={isAnimating}\n            isCurrentlyAnimating={animatingCards.includes(card.id)}\n            onSelect={onCardSelect}\n            position={card.position}\n            isMobile={isMobile}\n            prefersReducedMotion={prefersReducedMotion}\n          />\n        ))}\n      </AnimatePresence>\n    </motion.div>\n  );\n});\n\nMatchGrid.displayName = 'MatchGrid';\n\nexport default MatchGrid;","import { FC, memo, useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { motion } from 'framer-motion';\nimport { MatchResultsProps } from './types';\nimport { useMatchBestTimesStore, formatMatchTime } from '@/store/matchBestTimesStore';\nimport styles from './MatchResults.module.css';\n\nconst MatchResults: FC<MatchResultsProps> = memo(({\n  visible,\n  results,\n  onContinueWithMissed,\n  onStartNewRound,\n  onBackToDeck\n}) => {\n  const navigate = useNavigate();\n  const { updateBestTime, getBestTime } = useMatchBestTimesStore();\n  const [isNewBest, setIsNewBest] = useState(false);\n  const [previousBest, setPreviousBest] = useState<string | null>(null);\n\n  // Update best time and check if it's a new record\n  useEffect(() => {\n    if (!results || !visible) return;\n\n    const existingBest = getBestTime(results.deckId);\n    const wasNewBest = updateBestTime(\n      results.deckId,\n      results.totalTime,\n      { rows: 3, cols: 4 }, // Default grid size\n      'two_way', // Default match type\n      results.totalMatches\n    );\n\n    setIsNewBest(wasNewBest);\n    setPreviousBest(existingBest ? formatMatchTime(existingBest.bestTimeMs) : null);\n  }, [results, visible, updateBestTime, getBestTime]);\n\n  // Keyboard shortcuts: 1 = Play Again, 2 = Back to Deck, 3 = Home\n  useEffect(() => {\n    if (!visible) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      if (e.key === '1') {\n        e.preventDefault();\n        if (results?.missedCardIndices && results.missedCardIndices.length > 0) {\n          onContinueWithMissed();\n        } else {\n          onStartNewRound();\n        }\n      } else if (e.key === '2') {\n        e.preventDefault();\n        onBackToDeck();\n      } else if (e.key === '3') {\n        e.preventDefault();\n        navigate('/');\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [visible, results, onContinueWithMissed, onStartNewRound, onBackToDeck, navigate]);\n\n  if (!visible || !results) return null;\n\n  const getPerformanceMessage = () => {\n    const averageTimePerMatch = results.totalTime / results.totalMatches;\n\n    if (isNewBest) {\n      return { message: 'New Best Time!', emoji: '🏆', color: 'excellent' };\n    } else if (averageTimePerMatch < 3000) { // Less than 3 seconds per match\n      return { message: 'Lightning Fast!', emoji: '⚡', color: 'excellent' };\n    } else if (averageTimePerMatch < 5000) {\n      return { message: 'Great Speed!', emoji: '🌟', color: 'great' };\n    } else if (averageTimePerMatch < 8000) {\n      return { message: 'Good Work!', emoji: '👍', color: 'good' };\n    } else {\n      return { message: 'Complete!', emoji: '🎉', color: 'fair' };\n    }\n  };\n\n  const performance = getPerformanceMessage();\n  const currentTime = formatMatchTime(results.totalTime);\n  const hasMissedCards = results.missedCardIndices && results.missedCardIndices.length > 0;\n\n  return (\n    <motion.div\n      className={styles.sessionComplete}\n      initial={{ opacity: 0, scale: 0.9 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n      data-testid=\"match-results\"\n    >\n      <div className={styles.container}>\n        {/* Header */}\n        <header className={styles.header}>\n          <motion.div\n            className={styles.emoji}\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            transition={{ delay: 0.2, type: 'spring', stiffness: 200 }}\n          >\n            {performance.emoji}\n          </motion.div>\n          <h1 className={`${styles.title} ${styles[performance.color]}`}>\n            {performance.message}\n          </h1>\n          <p className={styles.subtitle}>\n            You completed Round {results.roundNumber} of matching!\n          </p>\n        </header>\n\n        {/* Results Summary */}\n        <div className={styles.resultsGrid}>\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.3 }}\n          >\n            <div className={styles.resultValue}>{currentTime}</div>\n            <div className={styles.resultLabel}>Time</div>\n          </motion.div>\n\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.4 }}\n          >\n            <div className={styles.resultValue}>{results.totalMatches}</div>\n            <div className={styles.resultLabel}>Matches</div>\n          </motion.div>\n\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.5 }}\n          >\n            <div className={styles.resultValue}>{results.roundNumber}</div>\n            <div className={styles.resultLabel}>Round</div>\n          </motion.div>\n\n          {previousBest && (\n            <motion.div\n              className={styles.resultCard}\n              initial={{ y: 20, opacity: 0 }}\n              animate={{ y: 0, opacity: 1 }}\n              transition={{ delay: 0.6 }}\n            >\n              <div className={styles.resultValue}>\n                {isNewBest ? previousBest : formatMatchTime(getBestTime(results.deckId)?.bestTimeMs || 0)}\n              </div>\n              <div className={styles.resultLabel}>\n                {isNewBest ? 'Previous Best' : 'Your Best'}\n              </div>\n            </motion.div>\n          )}\n        </div>\n\n        {/* Best Time Achievement */}\n        {isNewBest && previousBest && (\n          <motion.div\n            className={styles.achievementSection}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.7 }}\n          >\n            <div className={styles.achievementItem}>\n              <span className={`${styles.achievementIcon} ${styles.newBest}`}>🏆</span>\n              <span className={styles.achievementText}>\n                New personal best! You beat your previous time by{' '}\n                <strong>{formatMatchTime(getBestTime(results.deckId)?.bestTimeMs! - results.totalTime)}</strong>\n              </span>\n            </div>\n          </motion.div>\n        )}\n\n        {/* Missed Cards Info */}\n        {hasMissedCards && (\n          <motion.div\n            className={styles.missedSection}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.8 }}\n          >\n            <div className={styles.missedItem}>\n              <span className={`${styles.missedIcon} ${styles.review}`}>📚</span>\n              <span className={styles.missedText}>\n                <strong>{results.missedCardIndices.length}</strong> cards need more practice\n              </span>\n            </div>\n          </motion.div>\n        )}\n\n        {/* Action Buttons */}\n        <motion.div\n          className={styles.actions}\n          initial={{ y: 20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.9 }}\n        >\n          {hasMissedCards ? (\n            <>\n              <button\n                className={`${styles.actionButton} ${styles.primary}`}\n                onClick={onContinueWithMissed}\n                data-testid=\"practice-missed-button\"\n              >\n                Practice Missed Cards\n              </button>\n              <button\n                className={`${styles.actionButton} ${styles.secondary}`}\n                onClick={onStartNewRound}\n                data-testid=\"new-round-button\"\n              >\n                New Full Round\n              </button>\n            </>\n          ) : (\n            <button\n              className={`${styles.actionButton} ${styles.primary}`}\n              onClick={onStartNewRound}\n              data-testid=\"play-again-button\"\n            >\n              Play Again\n            </button>\n          )}\n          <button\n            className={`${styles.actionButton} ${styles.secondary}`}\n            onClick={onBackToDeck}\n            data-testid=\"back-button\"\n          >\n            Back to Deck\n          </button>\n          <button\n            className={`${styles.actionButton} ${styles.tertiary}`}\n            onClick={() => navigate('/')}\n            data-testid=\"home-button\"\n          >\n            Home\n          </button>\n        </motion.div>\n\n        {/* Speed tip for slower times */}\n        {results.totalTime / results.totalMatches > 8000 && (\n          <motion.p\n            className={styles.motivationalMessage}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 1 }}\n          >\n            Tip: Try to improve your speed with each round. The more you practice, the faster you'll get!\n          </motion.p>\n        )}\n      </div>\n    </motion.div>\n  );\n});\n\nMatchResults.displayName = 'MatchResults';\n\nexport default MatchResults;","/**\n * Sound utilities for game feedback and audio interactions\n *\n * Provides:\n * - Match success and failure sound feedback\n * - Volume control and audio settings integration\n * - Web Audio API optimizations for performance\n * - Cross-browser compatibility and fallbacks\n * - Audio pool management for simultaneous sounds\n */\n\n// Sound effect types\nexport type SoundEffect =\n  | 'match_success'\n  | 'match_failure'\n  | 'card_select'\n  | 'card_flip'\n  | 'game_complete'\n  | 'timer_tick'\n  | 'button_click'\n  | 'notification';\n\n// Audio settings interface\nexport interface AudioSettings {\n  enabled: boolean;\n  volume: number; // 0.0 to 1.0\n  soundEffects: boolean;\n  backgroundMusic: boolean;\n}\n\n// Sound configuration\ninterface SoundConfig {\n  frequency?: number;\n  duration: number;\n  type: OscillatorType;\n  volume: number;\n  envelope?: {\n    attack: number;\n    decay: number;\n    sustain: number;\n    release: number;\n  };\n}\n\n// Pre-defined sound configurations\nconst SOUND_CONFIGS: Record<SoundEffect, SoundConfig> = {\n  match_success: {\n    frequency: 523.25, // C5\n    duration: 0.3,\n    type: 'sine',\n    volume: 0.6,\n    envelope: {\n      attack: 0.01,\n      decay: 0.1,\n      sustain: 0.3,\n      release: 0.2,\n    },\n  },\n  match_failure: {\n    frequency: 146.83, // D3\n    duration: 0.2,\n    type: 'sawtooth',\n    volume: 0.4,\n    envelope: {\n      attack: 0.01,\n      decay: 0.05,\n      sustain: 0.1,\n      release: 0.05,\n    },\n  },\n  card_select: {\n    frequency: 659.25, // E5\n    duration: 0.1,\n    type: 'triangle',\n    volume: 0.3,\n    envelope: {\n      attack: 0.01,\n      decay: 0.02,\n      sustain: 0.1,\n      release: 0.05,\n    },\n  },\n  card_flip: {\n    frequency: 440, // A4\n    duration: 0.15,\n    type: 'square',\n    volume: 0.25,\n    envelope: {\n      attack: 0.01,\n      decay: 0.05,\n      sustain: 0.05,\n      release: 0.05,\n    },\n  },\n  game_complete: {\n    frequency: 783.99, // G5\n    duration: 0.8,\n    type: 'sine',\n    volume: 0.8,\n    envelope: {\n      attack: 0.1,\n      decay: 0.2,\n      sustain: 0.4,\n      release: 0.3,\n    },\n  },\n  timer_tick: {\n    frequency: 1000, // High tick\n    duration: 0.05,\n    type: 'square',\n    volume: 0.2,\n    envelope: {\n      attack: 0.001,\n      decay: 0.01,\n      sustain: 0.01,\n      release: 0.02,\n    },\n  },\n  button_click: {\n    frequency: 400,\n    duration: 0.1,\n    type: 'triangle',\n    volume: 0.3,\n    envelope: {\n      attack: 0.01,\n      decay: 0.02,\n      sustain: 0.02,\n      release: 0.05,\n    },\n  },\n  notification: {\n    frequency: 800,\n    duration: 0.2,\n    type: 'sine',\n    volume: 0.5,\n    envelope: {\n      attack: 0.05,\n      decay: 0.1,\n      sustain: 0.05,\n      release: 0.1,\n    },\n  },\n};\n\n// Audio context and pool management\nclass SoundManager {\n  private audioContext: AudioContext | null = null;\n  private audioPool: Map<SoundEffect, AudioBuffer[]> = new Map();\n  private settings: AudioSettings = {\n    enabled: true,\n    volume: 0.7,\n    soundEffects: true,\n    backgroundMusic: false,\n  };\n\n  constructor() {\n    this.initializeAudioContext();\n  }\n\n  private async initializeAudioContext(): Promise<void> {\n    try {\n      // Create audio context with user gesture handling\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n\n      // Handle browser autoplay policies\n      if (this.audioContext.state === 'suspended') {\n        document.addEventListener('click', this.resumeAudioContext.bind(this), { once: true });\n        document.addEventListener('touchstart', this.resumeAudioContext.bind(this), { once: true });\n      }\n    } catch (error) {\n      console.warn('Audio context initialization failed:', error);\n      this.audioContext = null;\n    }\n  }\n\n  private async resumeAudioContext(): Promise<void> {\n    if (this.audioContext && this.audioContext.state === 'suspended') {\n      try {\n        await this.audioContext.resume();\n        console.log('Audio context resumed');\n      } catch (error) {\n        console.warn('Failed to resume audio context:', error);\n      }\n    }\n  }\n\n  /**\n   * Update audio settings\n   */\n  updateSettings(newSettings: Partial<AudioSettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n  }\n\n  /**\n   * Get current audio settings\n   */\n  getSettings(): AudioSettings {\n    return { ...this.settings };\n  }\n\n  /**\n   * Play a sound effect using Web Audio API\n   */\n  async playSound(soundEffect: SoundEffect, volumeMultiplier = 1): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects || !this.audioContext) {\n      return;\n    }\n\n    try {\n      const config = SOUND_CONFIGS[soundEffect];\n      const volume = Math.min(1, this.settings.volume * volumeMultiplier * config.volume);\n\n      await this.synthesizeAndPlay(config, volume);\n    } catch (error) {\n      console.warn(`Failed to play sound ${soundEffect}:`, error);\n    }\n  }\n\n  /**\n   * Synthesize and play sound using Web Audio API\n   */\n  private async synthesizeAndPlay(config: SoundConfig, volume: number): Promise<void> {\n    if (!this.audioContext) return;\n\n    const { frequency = 440, duration, type, envelope } = config;\n    const ctx = this.audioContext;\n    const currentTime = ctx.currentTime;\n\n    // Create oscillator and gain nodes\n    const oscillator = ctx.createOscillator();\n    const gainNode = ctx.createGain();\n\n    // Configure oscillator\n    oscillator.type = type;\n    oscillator.frequency.setValueAtTime(frequency, currentTime);\n\n    // Configure envelope (ADSR)\n    if (envelope) {\n      const { attack, decay, sustain, release } = envelope;\n      const sustainLevel = volume * sustain;\n      const attackTime = currentTime + attack;\n      const decayTime = attackTime + decay;\n      const releaseTime = currentTime + duration - release;\n\n      gainNode.gain.setValueAtTime(0, currentTime);\n      gainNode.gain.linearRampToValueAtTime(volume, attackTime);\n      gainNode.gain.linearRampToValueAtTime(sustainLevel, decayTime);\n      gainNode.gain.setValueAtTime(sustainLevel, releaseTime);\n      gainNode.gain.linearRampToValueAtTime(0, currentTime + duration);\n    } else {\n      // Simple volume envelope\n      gainNode.gain.setValueAtTime(volume, currentTime);\n      gainNode.gain.linearRampToValueAtTime(0, currentTime + duration);\n    }\n\n    // Connect audio graph\n    oscillator.connect(gainNode);\n    gainNode.connect(ctx.destination);\n\n    // Start and stop oscillator\n    oscillator.start(currentTime);\n    oscillator.stop(currentTime + duration);\n\n    // Clean up\n    oscillator.addEventListener('ended', () => {\n      oscillator.disconnect();\n      gainNode.disconnect();\n    });\n  }\n\n  /**\n   * Play match success sound with celebration effect\n   */\n  async playMatchSuccess(intensity = 1): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play ascending chord for celebration\n      const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5\n      const delays = [0, 0.1, 0.2];\n\n      for (let i = 0; i < frequencies.length; i++) {\n        setTimeout(() => {\n          this.synthesizeAndPlay({\n            frequency: frequencies[i],\n            duration: 0.4,\n            type: 'sine',\n            volume: 0.6 * intensity,\n            envelope: {\n              attack: 0.02,\n              decay: 0.1,\n              sustain: 0.4,\n              release: 0.3,\n            },\n          }, this.settings.volume);\n        }, delays[i] * 1000);\n      }\n    } catch (error) {\n      console.warn('Failed to play match success sound:', error);\n    }\n  }\n\n  /**\n   * Play match failure sound with disappointment effect\n   */\n  async playMatchFailure(): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play descending tone for failure\n      await this.synthesizeAndPlay({\n        frequency: 220, // A3\n        duration: 0.3,\n        type: 'sawtooth',\n        volume: 0.4,\n        envelope: {\n          attack: 0.01,\n          decay: 0.1,\n          sustain: 0.1,\n          release: 0.2,\n        },\n      }, this.settings.volume);\n    } catch (error) {\n      console.warn('Failed to play match failure sound:', error);\n    }\n  }\n\n  /**\n   * Play game completion sound with fanfare\n   */\n  async playGameComplete(): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play victory fanfare\n      const melody = [\n        { freq: 523.25, delay: 0 },    // C5\n        { freq: 659.25, delay: 0.2 },  // E5\n        { freq: 783.99, delay: 0.4 },  // G5\n        { freq: 1046.5, delay: 0.6 },  // C6\n      ];\n\n      melody.forEach(({ freq, delay }) => {\n        setTimeout(() => {\n          this.synthesizeAndPlay({\n            frequency: freq,\n            duration: 0.5,\n            type: 'sine',\n            volume: 0.8,\n            envelope: {\n              attack: 0.05,\n              decay: 0.2,\n              sustain: 0.5,\n              release: 0.3,\n            },\n          }, this.settings.volume);\n        }, delay * 1000);\n      });\n    } catch (error) {\n      console.warn('Failed to play game complete sound:', error);\n    }\n  }\n\n  /**\n   * Enable haptic feedback for supported devices\n   */\n  vibrate(pattern: number | number[] = 50): void {\n    if ('vibrate' in navigator && this.settings.enabled) {\n      try {\n        navigator.vibrate(pattern);\n      } catch (error) {\n        console.warn('Haptic feedback failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Preload audio resources (if using audio files in the future)\n   */\n  async preload(): Promise<void> {\n    // Reserved for future audio file loading\n    console.log('Audio system initialized');\n  }\n\n  /**\n   * Cleanup audio resources\n   */\n  cleanup(): void {\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    this.audioPool.clear();\n  }\n}\n\n// Singleton instance\nconst soundManager = new SoundManager();\n\n// Export convenience functions\nexport const playSound = (effect: SoundEffect, volume = 1) =>\n  soundManager.playSound(effect, volume);\n\nexport const playMatchSuccess = (intensity = 1) =>\n  soundManager.playMatchSuccess(intensity);\n\nexport const playMatchFailure = () =>\n  soundManager.playMatchFailure();\n\nexport const playGameComplete = () =>\n  soundManager.playGameComplete();\n\nexport const updateAudioSettings = (settings: Partial<AudioSettings>) =>\n  soundManager.updateSettings(settings);\n\nexport const getAudioSettings = () =>\n  soundManager.getSettings();\n\nexport const vibrate = (pattern: number | number[] = 50) =>\n  soundManager.vibrate(pattern);\n\nexport const preloadAudio = () =>\n  soundManager.preload();\n\nexport const cleanupAudio = () =>\n  soundManager.cleanup();\n\n// Initialize audio system\nif (typeof window !== 'undefined') {\n  // Auto-initialize when imported in browser environment\n  soundManager.preload();\n}\n\nexport default soundManager;","import { FC, memo, useEffect, useState, useCallback, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { motion, AnimatePresence } from 'framer-motion';\n// import { useDeckStore } from '@/store/deckStore'; // Will be used in later phases\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport { useMatchSessionStore } from '@/store/matchSessionStore';\nimport { useMatchBestTimesStore } from '@/store/matchBestTimesStore';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { SharedModeHeader } from '@/components/common/SharedModeHeader';\nimport { LoadingScreen } from '@/components/ui';\nimport { UnifiedSettings } from '@/components/modals/UnifiedSettings';\nimport MatchGrid from './MatchGrid';\n// Timer disabled for now\n// import MatchTimer from './MatchTimer';\nimport MatchResults from './MatchResults';\n// import useMatchLogic from './hooks/useMatchLogic'; // Will be used in later phases\nimport {\n  MatchContainerProps,\n  DEFAULT_MATCH_SETTINGS,\n  MatchResults as MatchResultsData,\n  MatchSettings,\n} from './types';\nimport {\n  pauseOverlayVariants,\n} from './animations/matchAnimations';\nimport {\n  playMatchSuccess,\n  playMatchFailure,\n  playGameComplete,\n  playSound,\n  vibrate,\n  updateAudioSettings,\n} from '@/utils/soundUtils';\nimport styles from './MatchContainer.module.css';\n\nconst MatchContainer: FC<MatchContainerProps> = memo(({ deck }) => {\n  const navigate = useNavigate();\n  const { getMasteredCards } = useCardMasteryStore();\n  const { updateBestTime } = useMatchBestTimesStore();\n  const { showNotification } = useNotificationStore();\n  const {\n    session,\n    startSession,\n    pauseSession,\n    resumeSession,\n    selectCard,\n    clearSelection,\n    processMatch,\n    generateGrid,\n    loadSession,\n    startNewRound,\n  } = useMatchSessionStore();\n\n  // Match logic hook (will be used in later phases)\n  // const { checkMatch, validateCardSelection } = useMatchLogic();\n\n  // Local state\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [showResults, setShowResults] = useState(false);\n  const [results, setResults] = useState<MatchResultsData | null>(null);\n  const [showSettings, setShowSettings] = useState(false);\n  const [animatingCards, setAnimatingCards] = useState<string[]>([]);\n  const [gameCompleted, setGameCompleted] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  // Audio settings (sync with session settings)\n  const isAudioEnabled = session?.settings.enableAudio ?? false;\n\n  // Initialize or restore session\n  useEffect(() => {\n    if (!deck || isInitialized) return;\n\n    const existingSession = loadSession(deck.id);\n\n    if (existingSession) {\n      // Check if the existing session is already complete\n      const allCardsMatched = existingSession.grid.every(card => card.isMatched);\n\n      if (allCardsMatched && existingSession.grid.length > 0) {\n        // Session is complete, show results immediately\n        const completionTime = Date.now() - existingSession.roundStartTime;\n        const gameResults: MatchResultsData = {\n          deckId: existingSession.deckId,\n          totalTime: completionTime,\n          bestTime: null,\n          isNewBest: false,\n          totalMatches: existingSession.matchedPairs.length,\n          missedCardIndices: existingSession.missedCardIndices,\n          roundNumber: existingSession.currentRound,\n          startTime: existingSession.roundStartTime,\n          endTime: Date.now(),\n        };\n\n        setResults(gameResults);\n        setShowResults(true);\n        setIsInitialized(true);\n      } else {\n        // Session exists but not complete, continue playing\n        setIsInitialized(true);\n      }\n    } else {\n      // Start new session\n      const masteredIndices = getMasteredCards(deck.id);\n      const settings = {\n        ...DEFAULT_MATCH_SETTINGS,\n        includeMastered: masteredIndices.length === 0, // Include mastered only if none exist\n      };\n\n      startSession(deck.id, settings);\n\n      // Generate initial grid\n      setTimeout(() => {\n        generateGrid(deck.content, settings);\n        setIsInitialized(true);\n      }, 100);\n    }\n  }, [deck, isInitialized, loadSession, startSession, generateGrid, getMasteredCards]);\n\n  // Check for mobile device\n  useEffect(() => {\n    const checkMobile = () => {\n      const mobile = window.innerWidth < 768 || 'ontouchstart' in window;\n      setIsMobile(mobile);\n    };\n\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  // Sync audio settings with match settings\n  useEffect(() => {\n    if (session?.settings.enableAudio !== undefined) {\n      updateAudioSettings({\n        enabled: session.settings.enableAudio,\n        soundEffects: session.settings.enableAudio,\n      });\n    }\n  }, [session?.settings.enableAudio]);\n\n  // Handle card selection\n  const handleCardSelect = useCallback(async (cardId: string) => {\n    if (!session || animatingCards.length > 0 || gameCompleted) return;\n\n    // Play card selection sound if audio is enabled\n    if (isAudioEnabled) {\n      playSound('card_select', 0.8);\n      vibrate(30);\n    }\n\n    selectCard(cardId);\n\n    // Check for match when we have the right number of cards selected\n    const expectedCards = session.settings.matchType === 'three_way' ? 3 : 2;\n\n    if (session.selectedCards.length + 1 === expectedCards) {\n      // We've selected enough cards, check for a match\n      setTimeout(async () => {\n        const result = processMatch();\n\n        if (result.isMatch && result.matchedCards) {\n          // Play match success sound if audio is enabled\n          if (isAudioEnabled) {\n            await playMatchSuccess(1.2);\n            vibrate([50, 50, 50]);\n          }\n\n          // Show success notification\n          showNotification({\n            message: 'Match found! 🎉',\n            type: 'success',\n            duration: 1500,\n          });\n\n          setAnimatingCards(result.matchedCards);\n\n          // Clear animation after match animation completes\n          setTimeout(() => {\n            setAnimatingCards([]);\n\n            // Check if game is complete\n            const remainingCards = session.grid.filter(\n              card => !card.isMatched && !result.matchedCards?.includes(card.id)\n            );\n\n            if (remainingCards.length === 0) {\n              handleGameComplete();\n            }\n          }, 600);\n        } else {\n          // Play match failure sound if audio is enabled\n          if (isAudioEnabled) {\n            await playMatchFailure();\n            vibrate(100);\n          }\n\n          // Show mismatch notification\n          showNotification({\n            message: 'No match! Try again.',\n            type: 'error',\n            duration: 1500,\n          });\n\n          // Clear selection after showing the mismatch\n          setTimeout(() => {\n            clearSelection();\n          }, 800);\n        }\n      }, 150);\n    }\n  }, [session, selectCard, processMatch, clearSelection, animatingCards, gameCompleted, showNotification]);\n\n  // Handle game completion\n  const handleGameComplete = useCallback(async () => {\n    if (!session || gameCompleted) return;\n\n    setGameCompleted(true);\n\n    // Play game completion sound if audio is enabled\n    if (isAudioEnabled) {\n      await playGameComplete();\n      vibrate([100, 50, 100, 50, 200]);\n    }\n\n    const completionTime = Date.now() - session.roundStartTime;\n    const endTime = Date.now();\n\n    // Update best time\n    const isNewBest = updateBestTime(\n      session.deckId,\n      completionTime,\n      session.settings.gridSize,\n      session.settings.matchType,\n      session.matchedPairs.length\n    );\n\n    // Create results data\n    const gameResults: MatchResultsData = {\n      deckId: session.deckId,\n      totalTime: completionTime,\n      bestTime: null, // Will be populated by MatchResults component\n      isNewBest,\n      totalMatches: session.matchedPairs.length,\n      missedCardIndices: session.missedCardIndices,\n      roundNumber: session.currentRound,\n      startTime: session.roundStartTime,\n      endTime,\n    };\n\n    setResults(gameResults);\n\n    // Show results modal immediately\n    setGameCompleted(false);\n    setShowResults(true);\n  }, [session, gameCompleted, updateBestTime]);\n\n  // Timer disabled - formatTime removed\n\n  // Handle pause/resume\n  const handlePause = useCallback(() => {\n    if (session?.isPaused) {\n      resumeSession();\n    } else {\n      pauseSession();\n    }\n  }, [session, pauseSession, resumeSession]);\n\n  // Handle back navigation\n  const handleBack = useCallback(() => {\n    navigate(`/deck/${deck.id}`);\n  }, [navigate, deck.id]);\n\n  // Results modal handlers\n  const handleContinueWithMissed = useCallback(() => {\n    if (!session || !results) return;\n\n    setShowResults(false);\n    setResults(null);\n\n    // Start new round with missed cards only\n    startNewRound(results.missedCardIndices);\n  }, [session, results, startNewRound]);\n\n  const handleStartNewRound = useCallback(() => {\n    if (!session || !deck) return;\n\n    setShowResults(false);\n    setResults(null);\n\n    // Start completely new round\n    startNewRound();\n\n    // Generate new grid for the new round\n    setTimeout(() => {\n      generateGrid(deck.content, session.settings);\n    }, 100);\n  }, [session, deck, startNewRound, generateGrid]);\n\n  const handleCloseResults = useCallback(() => {\n    setShowResults(false);\n    setResults(null);\n  }, []);\n\n  // Settings handlers\n  const handleShowSettings = useCallback(() => {\n    setShowSettings(true);\n  }, []);\n\n  const handleCloseSettings = useCallback(() => {\n    setShowSettings(false);\n  }, []);\n\n  const handleUpdateSettings = useCallback((newSettings: any) => {\n    const matchSettings = newSettings as MatchSettings;\n    if (!session) return;\n\n    // Update session settings and regenerate grid if needed\n    const gridSizeChanged =\n      session.settings.gridSize.rows !== matchSettings.gridSize.rows ||\n      session.settings.gridSize.cols !== matchSettings.gridSize.cols;\n\n    const cardSidesChanged =\n      JSON.stringify(session.settings.cardSides) !== JSON.stringify(matchSettings.cardSides);\n\n    // If significant changes were made, regenerate grid\n    if (gridSizeChanged || cardSidesChanged) {\n      // Store updated settings\n      session.settings = matchSettings;\n\n      // Regenerate grid with new settings\n      generateGrid(deck.content, matchSettings);\n    } else {\n      // Just update settings for non-grid affecting changes\n      session.settings = matchSettings;\n    }\n  }, [session, deck, generateGrid]);\n\n  // Memoized grid calculations\n  const gridMetrics = useMemo(() => {\n    if (!session || !session.grid.length) {\n      return {\n        totalCards: 0,\n        matchedCards: 0,\n        progressPercentage: 0,\n        selectedCount: session?.selectedCards.length || 0,\n      };\n    }\n\n    const totalCards = session.grid.length;\n    const matchedCards = session.grid.filter(card => card.isMatched).length;\n    const progressPercentage = (matchedCards / totalCards) * 100;\n    const selectedCount = session.selectedCards.length;\n\n    return {\n      totalCards,\n      matchedCards,\n      progressPercentage,\n      selectedCount,\n    };\n  }, [session]);\n\n  // Timer functionality disabled for now\n\n  // Calculate matched card pairs for MatchGrid\n  const matchedCardPairs = useMemo(() => {\n    if (!session) return [];\n    return session.matchedPairs;\n  }, [session]);\n\n  // Loading state\n  if (!isInitialized || !session) {\n    return <LoadingScreen />;\n  }\n\n  return (\n    <div className={styles.container}>\n      <SharedModeHeader\n        deckName={deck.metadata.deck_name}\n        currentCard={gridMetrics.matchedCards}\n        totalCards={gridMetrics.totalCards}\n        onBackClick={handleBack}\n        onSettingsClick={handleShowSettings}\n        showSettings={true}\n        subtitle={session.currentRound > 1 ? `Round ${session.currentRound}` : undefined}\n      />\n\n      {/* Game stats */}\n      <div className={styles.gameStats}>\n        <div className={styles.progressSection}>\n          <div className={styles.progressBar}>\n            <motion.div\n              className={styles.progressFill}\n              initial={{ width: 0 }}\n              animate={{ width: `${gridMetrics.progressPercentage}%` }}\n              transition={{ duration: 0.3 }}\n            />\n          </div>\n          <div className={styles.statsText}>\n            <span>{gridMetrics.matchedCards} / {gridMetrics.totalCards} matched</span>\n          </div>\n\n          {/* Timer disabled for now */}\n          {/* <MatchTimer\n            isEnabled={timerData.enabled}\n            isPaused={timerData.isPaused}\n            initialTime={timerData.elapsedTime}\n            onTimeChange={handleTimerUpdate}\n            compact={isMobile}\n            theme=\"primary\"\n            className={styles.matchTimer}\n          /> */}\n        </div>\n\n        {/* Game controls */}\n        <div className={styles.gameControls}>\n          {/* Timer/Pause disabled for now */}\n          {/* {session.settings.enableTimer && (\n            <button\n              className={styles.pauseButton}\n              onClick={handlePause}\n              aria-label={session.isPaused ? 'Resume game' : 'Pause game'}\n            >\n              {session.isPaused ? '▶️' : '⏸️'}\n            </button>\n          )} */}\n\n          {session.selectedCards.length > 0 && (\n            <button\n              className={styles.clearButton}\n              onClick={clearSelection}\n              aria-label=\"Clear selection\"\n            >\n              Clear Selection\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* Match grid */}\n      <main className={styles.gridContainer}>\n        <AnimatePresence mode=\"wait\">\n          {session.isPaused ? (\n            <motion.div\n              key=\"paused\"\n              className={styles.pausedOverlay}\n              variants={pauseOverlayVariants}\n              initial=\"initial\"\n              animate=\"animate\"\n              exit=\"exit\"\n            >\n              <div className={styles.pausedContent}>\n                <h2>Game Paused</h2>\n                <button\n                  className={styles.resumeButton}\n                  onClick={handlePause}\n                >\n                  Resume Game\n                </button>\n              </div>\n            </motion.div>\n          ) : (\n            <MatchGrid\n              key=\"grid\"\n              cards={session.grid}\n              onCardSelect={handleCardSelect}\n              selectedCards={session.selectedCards}\n              matchedCards={matchedCardPairs}\n              gridSize={session.settings.gridSize}\n              isAnimating={animatingCards.length > 0}\n              animatingCards={animatingCards}\n              isMobile={isMobile}\n            />\n          )}\n        </AnimatePresence>\n      </main>\n\n      {/* Game completion handled by MatchResults modal */}\n\n      {/* Selection feedback */}\n      {gridMetrics.selectedCount > 0 && (\n        <motion.div\n          className={styles.selectionFeedback}\n          initial={{ y: 50, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          exit={{ y: 50, opacity: 0 }}\n        >\n          {gridMetrics.selectedCount} card{gridMetrics.selectedCount > 1 ? 's' : ''} selected\n        </motion.div>\n      )}\n\n      {/* Results Modal */}\n      <MatchResults\n        visible={showResults}\n        results={results}\n        onContinueWithMissed={handleContinueWithMissed}\n        onStartNewRound={handleStartNewRound}\n        onBackToDeck={handleBack}\n        onClose={handleCloseResults}\n      />\n\n      {/* Settings Modal */}\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={handleCloseSettings}\n        deck={deck}\n        mode=\"match\"\n        settings={session?.settings || DEFAULT_MATCH_SETTINGS}\n        onUpdateSettings={handleUpdateSettings}\n      />\n    </div>\n  );\n});\n\nMatchContainer.displayName = 'MatchContainer';\n\nexport default MatchContainer;","import { FC, useEffect, useState, useCallback } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\n// import { useMatchSessionStore } from '@/store/matchSessionStore'; // Will be used in later phases\n// import { useProgressStore } from '@/store/progressStore'; // Will be used in Phase 4\nimport MatchContainer from '@/components/modes/match/MatchContainer';\n// import { MatchResults } from '@/components/modes/match/types'; // Will be used in Phase 4\nimport styles from './Match.module.css';\n\nconst Match: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n  const { decks, activeDeck, selectDeck, isLoading: deckLoading } = useDeckStore();\n  const { getMasteredCards } = useCardMasteryStore();\n  // const { loadSession } = useMatchSessionStore(); // Will be used in later phases\n  // const { updateDeckProgress } = useProgressStore(); // Will be used in Phase 4\n\n  // Local state\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load deck and initialize\n  useEffect(() => {\n    if (!deckId) {\n      setError('No deck ID provided');\n      return;\n    }\n\n    // Find deck in loaded decks\n    const deck = decks.find(d => d.id === deckId);\n\n    if (deck) {\n      // Deck is available, select it\n      selectDeck(deckId);\n      setIsInitialized(true);\n      setError(null);\n    } else if (!deckLoading) {\n      // Deck not found and not loading\n      setError('Deck not found');\n    }\n    // If still loading, wait for decks to load\n  }, [deckId, decks, selectDeck, deckLoading]);\n\n  // Prevent body scrolling on mobile\n  useEffect(() => {\n    document.body.classList.add('no-scroll');\n\n    return () => {\n      document.body.classList.remove('no-scroll');\n    };\n  }, []);\n\n  // TODO: Handle session completion and progress tracking in Phase 4\n  // const handleSessionComplete = useCallback((results: MatchResults) => {\n  //   if (!deckId || !activeDeck) return;\n  //   // Implementation will be added in Phase 4 with results modal\n  // }, [deckId, activeDeck, updateDeckProgress]);\n\n  // Handle navigation back to deck\n  const handleBackToDeck = useCallback(() => {\n    if (deckId) {\n      navigate(`/deck/${deckId}`);\n    } else {\n      navigate('/');\n    }\n  }, [navigate, deckId]);\n\n  // Error handling\n  if (error) {\n    return (\n      <div className={styles.errorContainer}>\n        <div className={styles.errorContent}>\n          <h1>Match Mode Error</h1>\n          <p>{error}</p>\n          <button\n            onClick={() => navigate('/')}\n            className={styles.errorButton}\n          >\n            Return to Home\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // Loading state - removed LoadingScreen to avoid duplicate with PageLazyBoundary\n  if (deckLoading || !isInitialized || !activeDeck) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  // Check if deck has enough cards for match mode\n  if (activeDeck.content.length < 2) {\n    return (\n      <div className={styles.errorContainer}>\n        <div className={styles.errorContent}>\n          <h1>Insufficient Cards</h1>\n          <p>\n            This deck needs at least 2 cards to play Match mode.\n            Current deck has {activeDeck.content.length} card{activeDeck.content.length === 1 ? '' : 's'}.\n          </p>\n          <button\n            onClick={handleBackToDeck}\n            className={styles.errorButton}\n          >\n            Back to Deck\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // Check for mastered cards scenario\n  const masteredIndices = getMasteredCards(deckId!);\n  const availableCards = activeDeck.content.length - masteredIndices.length;\n\n  if (availableCards < 2 && masteredIndices.length > 0) {\n    return (\n      <div className={styles.errorContainer}>\n        <div className={styles.errorContent}>\n          <h1>All Cards Mastered</h1>\n          <p>\n            You've mastered most cards in this deck!\n            Only {availableCards} unmastered card{availableCards === 1 ? '' : 's'} remaining.\n          </p>\n          <p>\n            Enable \"Include Mastered Cards\" in settings to continue playing.\n          </p>\n          <button\n            onClick={handleBackToDeck}\n            className={styles.errorButton}\n          >\n            Back to Deck\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <MatchContainer\n        deck={activeDeck}\n      />\n    </div>\n  );\n};\n\nexport default Match;"],"names":["DEFAULT_MATCH_SETTINGS","gridSize","rows","cols","matchType","cardSides","sides","label","count","enableTimer","includeMastered","enableAudio","timerSeconds","generateCardId","cardIndex","sideGroup","position","shuffleArray","array","shuffled","i","length","j","Math","floor","random","useMatchSessionStore","create","persist","set","get","session","startSession","deckId","settings","startTime","Date","now","currentRound","pausedTime","isPaused","grid","selectedCards","matchedPairs","missedCardIndices","roundStartTime","bestTime","pauseSession","resumeSession","pauseDuration","endSession","selectCard","cardId","card","find","c","id","isMatched","newSelectedCards","newGrid","includes","filter","map","isSelected","clearSelection","processMatch","isMatch","selectedCardObjects","validationResult","isValid","matchedCards","firstGroupId","groupId","allSameGroup","every","isValidCount","validateMatch","newMatchedPairs","startNewRound","missedCards","generateGrid","cards","excludeMastered","masteredIndices","totalSlots","availableCards","_","index","cardsPerGroup","maxGroups","needed","repeated","slice","matchCards","forEach","idx","push","displaySides","content","side_a","trim","row","col","side_b","side_c","cardSide","sideKey","sideContent","shuffledCards","generateMatchCards","saveSession","loadSession","name","storage","getItem","str","localStorage","state","JSON","parse","error","setItem","value","stringify","removeItem","partialize","formatMatchTime","timeMs","totalSeconds","seconds","toString","padStart","useMatchBestTimesStore","bestTimes","updateBestTime","totalMatches","currentBest","bestTimeMs","achievedAt","getBestTime","hasBestTime","clearBestTime","newBestTimes","clearAllBestTimes","getAllBestTimes","Object","values","getDeckStats","formattedTime","hasRecord","parsed","keys","Modal","memo","isOpen","onClose","title","children","size","showCloseButton","closeOnOverlayClick","className","footer","modalRef","useRef","previousActiveElement","handleEscape","useCallback","e","key","handleOverlayClick","target","currentTarget","useEffect","current","document","activeElement","addEventListener","body","style","overflow","focus","removeEventListener","HTMLElement","modalClasses","styles","modal","Boolean","join","modalContent","jsx","overlay","onClick","role","jsxs","ref","tabIndex","header","Button","variant","closeButton","width","height","viewBox","fill","xmlns","d","stroke","strokeWidth","strokeLinecap","strokeLinejoin","createPortal","displayName","Input","forwardRef","helperText","fullWidth","startIcon","endIcon","rest","inputId","substr","containerClasses","container","inputWrapperClasses","inputWrapper","withIcon","htmlFor","input","errorText","ProgressBar","max","showLabel","animated","percentage","min","barClasses","bar","track","round","LoadingScreen","message","fullScreen","Spinner","FAST_TRANSITION","type","stiffness","damping","mass","cardSelectionVariants","unselected","scale","borderColor","boxShadow","y","transition","selected","hover","gridLayoutVariants","initial","opacity","animate","duration","staggerChildren","delayChildren","exit","staggerDirection","pauseOverlayVariants","backdropFilter","ease","getMobileOptimizedVariants","variants","isMobile","entries","reduce","acc","mobileValue","Array","isArray","scaleArray","getReducedMotionVariants","reducedValue","rotate","rotateY","allowedProps","prop","MatchCard","isAnimating","isCurrentlyAnimating","onSelect","prefersReducedMotion","handleCardClick","handleKeyDown","event","preventDefault","cardVariants","getCardVariants","animationState","motion","div","matched","animating","gridRow","gridColumn","onKeyDown","whileHover","whileTap","layout","layoutId","selectionIndicator","matchIndicator","delay","touchTarget","MatchGrid","onCardSelect","animatingCards","matchedCardIds","Set","flat","window","matchMedia","matches","gridVariants","gridTemplateRows","gridTemplateColumns","AnimatePresence","mode","has","MatchResults","visible","results","onContinueWithMissed","onStartNewRound","onBackToDeck","navigate","useNavigate","isNewBest","setIsNewBest","useState","previousBest","setPreviousBest","existingBest","wasNewBest","totalTime","tagName","isContentEditable","performance","averageTimePerMatch","emoji","color","getPerformanceMessage","currentTime","hasMissedCards","sessionComplete","subtitle","roundNumber","resultsGrid","resultCard","resultValue","resultLabel","achievementSection","achievementItem","achievementIcon","newBest","achievementText","missedSection","missedItem","missedIcon","review","missedText","actions","Fragment","actionButton","primary","secondary","tertiary","p","motivationalMessage","SOUND_CONFIGS","match_success","frequency","volume","envelope","attack","decay","sustain","release","match_failure","card_select","card_flip","game_complete","timer_tick","button_click","notification","soundManager","audioContext","audioPool","Map","enabled","soundEffects","backgroundMusic","constructor","this","initializeAudioContext","AudioContext","webkitAudioContext","resumeAudioContext","bind","once","resume","updateSettings","newSettings","getSettings","playSound","soundEffect","volumeMultiplier","config","synthesizeAndPlay","ctx","oscillator","createOscillator","gainNode","createGain","setValueAtTime","sustainLevel","attackTime","decayTime","releaseTime","gain","linearRampToValueAtTime","connect","destination","start","stop","disconnect","playMatchSuccess","intensity","frequencies","delays","setTimeout","playMatchFailure","playGameComplete","freq","vibrate","pattern","navigator","preload","cleanup","close","clear","MatchContainer","deck","getMasteredCards","useCardMasteryStore","showNotification","useNotificationStore","isInitialized","setIsInitialized","showResults","setShowResults","setResults","showSettings","setShowSettings","setAnimatingCards","gameCompleted","setGameCompleted","setIsMobile","isAudioEnabled","existingSession","allCardsMatched","completionTime","gameResults","endTime","checkMobile","mobile","innerWidth","handleCardSelect","async","effect","expectedCards","result","remainingCards","handleGameComplete","handlePause","handleBack","handleContinueWithMissed","handleStartNewRound","handleCloseResults","handleShowSettings","handleCloseSettings","handleUpdateSettings","matchSettings","gridSizeChanged","cardSidesChanged","gridMetrics","useMemo","totalCards","progressPercentage","selectedCount","matchedCardPairs","SharedModeHeader","deckName","metadata","deck_name","currentCard","onBackClick","onSettingsClick","UnifiedSettings","onUpdateSettings","Match","useParams","decks","activeDeck","selectDeck","isLoading","deckLoading","useDeckStore","setError","classList","add","remove","handleBackToDeck"],"mappings":"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"}