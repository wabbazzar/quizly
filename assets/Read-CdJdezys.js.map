{"version":3,"file":"Read-CdJdezys.js","sources":["../../src/store/readStore.ts","../../src/components/read/ReadDialoguePicker.tsx","../../src/store/transcriptStore.ts","../../src/components/read/TranscriptPicker.tsx","../../src/components/read/ReadSidebar.tsx","../../src/components/icons/CopyIcon.tsx","../../src/components/read/TranscriptModal.tsx","../../src/utils/sentenceTranslation.ts","../../src/utils/wordAlignments.ts","../../src/components/read/SentenceTranslation.tsx","../../src/utils/tokenize.ts","../../src/components/read/ReadToken.tsx","../../src/components/read/AlignedReadLine.tsx","../../src/components/read/EnhancedReadLine.tsx","../../src/components/read/ReadControls.tsx","../../src/components/read/ReadProgress.tsx","../../src/pages/Read.tsx"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { ReadModeSettings } from '@/types';\n\ninterface ReadProgress {\n  dialogueId: string;\n  lineIndex: number;\n  tokenIndex: number;\n  completedTokens: Set<string>; // dialogueId:lineIndex:tokenIndex\n  masteredTokens: Set<string>;\n}\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface ReadStore {\n  // Progress tracking\n  progress: Record<string, ReadProgress>; // deckId -> progress\n\n  // Current session\n  session: ReadSessionState | null;\n\n  // Settings\n  settings: ReadModeSettings;\n\n  // Actions\n  initSession: (deckId: string, dialogueId: string) => void;\n  setCurrentDialogue: (dialogueId: string) => void;\n  setCurrentLine: (lineIndex: number) => void;\n  setCurrentToken: (tokenIndex: number) => void;\n  markTokenComplete: (dialogueId: string, lineIndex: number, tokenIndex: number) => void;\n  markTokenMastered: (dialogueId: string, lineIndex: number, tokenIndex: number) => void;\n  togglePinyin: () => void;\n  toggleTranslation: () => void;\n  updateSettings: (settings: Partial<ReadModeSettings>) => void;\n  recordAnswer: (correct: boolean, responseTime: number) => void;\n  clearSession: () => void;\n  resetProgress: (deckId: string) => void;\n  getProgress: (deckId: string) => ReadProgress | null;\n}\n\nconst defaultSettings: ReadModeSettings = {\n  answerType: 'free_text',\n  checkMode: 'wait',\n  translationDirection: { from: 'b', to: 'c' },  // pinyin → english\n  optionsCount: 4,\n  showPinyinDefault: false,\n  multipleChoiceDifficulty: 'medium',\n  unit: 'character',\n  translationMode: 'sentence',\n  accuracyThreshold: 70,\n  showWordHints: true\n};\n\nexport const useReadStore = create<ReadStore>()(\n  persist(\n    (set, get) => ({\n      progress: {},\n      session: null,\n      settings: defaultSettings,\n\n      initSession: (deckId: string, dialogueId: string) => {\n        set(state => {\n          console.log('Initializing session with showPinyinDefault:', state.settings.showPinyinDefault);\n          return {\n            session: {\n              deckId,\n              currentDialogueId: dialogueId,\n              currentLineIndex: 0,\n              currentTokenIndex: 0,\n              showPinyin: state.settings.showPinyinDefault,\n              showTranslation: false,\n              correctCount: 0,\n              incorrectCount: 0,\n              startTime: Date.now(),\n              responseStartTime: Date.now(),\n              responseTimes: []\n            }\n          };\n        });\n      },\n\n      setCurrentDialogue: (dialogueId: string) => {\n        set(state => {\n          if (!state.session) return state;\n\n          // Save progress for current deck\n          const deckId = state.session.deckId;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                dialogueId\n              }\n            },\n            session: {\n              ...state.session,\n              currentDialogueId: dialogueId,\n              currentLineIndex: 0,\n              currentTokenIndex: 0\n            }\n          };\n        });\n      },\n\n      setCurrentLine: (lineIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const dialogueId = state.session.currentDialogueId || '';\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                lineIndex\n              }\n            },\n            session: {\n              ...state.session,\n              currentLineIndex: lineIndex,\n              currentTokenIndex: 0\n            }\n          };\n        });\n      },\n\n      setCurrentToken: (tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const dialogueId = state.session.currentDialogueId || '';\n          const lineIndex = state.session.currentLineIndex;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                tokenIndex\n              }\n            },\n            session: {\n              ...state.session,\n              currentTokenIndex: tokenIndex,\n              responseStartTime: Date.now()\n            }\n          };\n        });\n      },\n\n      markTokenComplete: (dialogueId: string, lineIndex: number, tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const tokenKey = `${dialogueId}:${lineIndex}:${tokenIndex}`;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          const newCompletedTokens = new Set(currentProgress.completedTokens);\n          newCompletedTokens.add(tokenKey);\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                completedTokens: newCompletedTokens\n              }\n            }\n          };\n        });\n      },\n\n      markTokenMastered: (dialogueId: string, lineIndex: number, tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const tokenKey = `${dialogueId}:${lineIndex}:${tokenIndex}`;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          const newMasteredTokens = new Set(currentProgress.masteredTokens);\n          newMasteredTokens.add(tokenKey);\n\n          const newCompletedTokens = new Set(currentProgress.completedTokens);\n          newCompletedTokens.add(tokenKey);\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                completedTokens: newCompletedTokens,\n                masteredTokens: newMasteredTokens\n              }\n            }\n          };\n        });\n      },\n\n      togglePinyin: () => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              showPinyin: !state.session.showPinyin\n            }\n          };\n        });\n      },\n\n      toggleTranslation: () => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              showTranslation: !state.session.showTranslation\n            }\n          };\n        });\n      },\n\n      updateSettings: (settings: Partial<ReadModeSettings>) => {\n        console.log('Updating settings:', settings);\n        set(state => ({\n          settings: {\n            ...state.settings,\n            ...settings\n          },\n          // Update session if showPinyinDefault changes\n          session: state.session && settings.showPinyinDefault !== undefined\n            ? {\n                ...state.session,\n                showPinyin: settings.showPinyinDefault\n              }\n            : state.session\n        }));\n      },\n\n      recordAnswer: (correct: boolean, responseTime: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              correctCount: state.session.correctCount + (correct ? 1 : 0),\n              incorrectCount: state.session.incorrectCount + (correct ? 0 : 1),\n              responseTimes: [...state.session.responseTimes, responseTime]\n            }\n          };\n        });\n      },\n\n      clearSession: () => {\n        set({ session: null });\n      },\n\n      resetProgress: (deckId: string) => {\n        set(state => {\n          const newProgress = { ...state.progress };\n          delete newProgress[deckId];\n          return { progress: newProgress };\n        });\n      },\n\n      getProgress: (deckId: string) => {\n        return get().progress[deckId] || null;\n      }\n    }),\n    {\n      name: 'read-store',\n      version: 3,\n      partialize: state => ({\n        progress: state.progress,\n        settings: state.settings\n      }),\n      migrate: (persistedState: any, version: number) => {\n        if (version < 2) {\n          // Add new sentence mode settings to existing persisted state\n          persistedState = {\n            ...persistedState,\n            settings: {\n              ...defaultSettings,\n              ...persistedState.settings,\n              translationMode: persistedState.settings?.translationMode || 'sentence',\n              accuracyThreshold: persistedState.settings?.accuracyThreshold || 70,\n              showWordHints: persistedState.settings?.showWordHints !== false\n            }\n          };\n        }\n        if (version < 3) {\n          // Update default translation direction from characters→english to pinyin→english\n          // Only migrate if user was on the old default (a→c)\n          const currentFrom = persistedState.settings?.translationDirection?.from;\n          const currentTo = persistedState.settings?.translationDirection?.to;\n          if (currentFrom === 'a' && currentTo === 'c') {\n            persistedState = {\n              ...persistedState,\n              settings: {\n                ...persistedState.settings,\n                translationDirection: { from: 'b', to: 'c' }\n              }\n            };\n          }\n        }\n        return persistedState;\n      }\n    }\n  )\n);","import { FC, useMemo } from 'react';\nimport { Deck } from '@/types';\nimport { Button } from '@/components/ui/Button';\n// CheckIcon inline SVG\nimport styles from './ReadDialoguePicker.module.css';\n\ninterface ReadProgress {\n  dialogueId: string;\n  lineIndex: number;\n  tokenIndex: number;\n  completedTokens: Set<string>;\n  masteredTokens: Set<string>;\n}\n\ninterface Props {\n  deck: Deck;\n  selectedDialogueId: string | null;\n  onSelectDialogue: (dialogueId: string) => void;\n  progress: ReadProgress | null;\n}\n\nexport const ReadDialoguePicker: FC<Props> = ({\n  deck,\n  selectedDialogueId,\n  onSelectDialogue,\n  progress\n}) => {\n  // Calculate progress for each dialogue\n  const dialogueProgress = useMemo(() => {\n    if (!deck.reading) return {};\n\n    const result: Record<string, { completed: number; total: number }> = {};\n\n    Object.entries(deck.reading.dialogues).forEach(([dialogueId, dialogue]) => {\n      const totalTokens = dialogue.lines.reduce((acc, line) => {\n        // Count tokens based on available sides\n        let tokenCount = 0;\n        if (line.a) tokenCount++;\n        if (line.b) tokenCount++;\n        if (line.c) tokenCount++;\n        return acc + tokenCount;\n      }, 0);\n\n      const completedTokens = progress?.completedTokens\n        ? Array.from(progress.completedTokens).filter(key =>\n            key.startsWith(`${dialogueId}:`)\n          ).length\n        : 0;\n\n      result[dialogueId] = {\n        completed: completedTokens,\n        total: totalTokens\n      };\n    });\n\n    return result;\n  }, [deck, progress]);\n\n  if (!deck.reading) return null;\n\n  const dialogueEntries = Object.entries(deck.reading.dialogues);\n\n  return (\n    <div className={styles.container}>\n      <h3 className={styles.title}>Practice</h3>\n      <div className={styles.dialogueList}>\n        {dialogueEntries.map(([dialogueId, dialogue]) => {\n          const isSelected = selectedDialogueId === dialogueId;\n          const dialogueStats = dialogueProgress[dialogueId];\n          const progressPercentage = dialogueStats\n            ? (dialogueStats.completed / dialogueStats.total) * 100\n            : 0;\n\n          // Create a friendly display name\n          const displayName = dialogueId\n            .replace(/dialogue(\\d+)/, 'Dialogue $1')\n            .replace(/_/g, ' ')\n            .replace(/\\b\\w/g, l => l.toUpperCase());\n\n          return (\n            <Button\n              key={dialogueId}\n              variant={isSelected ? 'primary' : 'secondary'}\n              className={`${styles.dialogueButton} ${isSelected ? styles.selected : ''}`}\n              onClick={() => onSelectDialogue(dialogueId)}\n            >\n              <div className={styles.dialogueContent}>\n                <div className={styles.dialogueHeader}>\n                  <span className={styles.dialogueName}>{displayName}</span>\n                  {progressPercentage === 100 && (\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" className={styles.completeIcon}>\n                      <path d=\"M20 6L9 17L4 12\" />\n                    </svg>\n                  )}\n                </div>\n                <div className={styles.dialogueInfo}>\n                  <span className={styles.lineCount}>\n                    {dialogue.lines.length} lines\n                  </span>\n                  {dialogueStats && dialogueStats.completed > 0 && (\n                    <span className={styles.progress}>\n                      {dialogueStats.completed}/{dialogueStats.total} tokens\n                    </span>\n                  )}\n                </div>\n                {progressPercentage > 0 && progressPercentage < 100 && (\n                  <div className={styles.progressBar}>\n                    <div\n                      className={styles.progressFill}\n                      style={{ width: `${progressPercentage}%` }}\n                    />\n                  </div>\n                )}\n              </div>\n            </Button>\n          );\n        })}\n      </div>\n    </div>\n  );\n};","/**\n * Zustand store for transcript state management\n * Handles loading, selecting, and displaying transcript files\n */\n\nimport { create } from 'zustand';\nimport { TranscriptFile } from '@/types';\nimport {\n  getTranscriptsForDeck,\n  loadTranscriptContent,\n} from '@/services/transcriptService';\n\ninterface TranscriptState {\n  // State\n  availableTranscripts: TranscriptFile[];\n  selectedTranscript: TranscriptFile | null;\n  transcriptContent: string | null;\n  isLoading: boolean;\n  isLoadingContent: boolean;\n  error: string | null;\n  isModalOpen: boolean;\n\n  // Actions\n  loadTranscriptsForDeck: (deckId: string) => Promise<void>;\n  selectTranscript: (transcript: TranscriptFile) => Promise<void>;\n  closeModal: () => void;\n  clearError: () => void;\n  reset: () => void;\n}\n\nconst initialState = {\n  availableTranscripts: [],\n  selectedTranscript: null,\n  transcriptContent: null,\n  isLoading: false,\n  isLoadingContent: false,\n  error: null,\n  isModalOpen: false,\n};\n\nexport const useTranscriptStore = create<TranscriptState>((set) => ({\n  ...initialState,\n\n  loadTranscriptsForDeck: async (deckId: string) => {\n    set({ isLoading: true, error: null });\n    try {\n      const transcripts = await getTranscriptsForDeck(deckId);\n      set({ availableTranscripts: transcripts, isLoading: false });\n    } catch (error) {\n      set({\n        error: error instanceof Error ? error.message : 'Failed to load transcripts',\n        isLoading: false,\n        availableTranscripts: [],\n      });\n    }\n  },\n\n  selectTranscript: async (transcript: TranscriptFile) => {\n    set({\n      selectedTranscript: transcript,\n      isLoadingContent: true,\n      error: null,\n      isModalOpen: true,\n      transcriptContent: null,\n    });\n    try {\n      const content = await loadTranscriptContent(transcript.filename);\n      set({ transcriptContent: content, isLoadingContent: false });\n    } catch (error) {\n      set({\n        error: error instanceof Error ? error.message : 'Failed to load transcript content',\n        isLoadingContent: false,\n      });\n    }\n  },\n\n  closeModal: () => {\n    set({\n      isModalOpen: false,\n      selectedTranscript: null,\n      transcriptContent: null,\n      error: null,\n    });\n  },\n\n  clearError: () => set({ error: null }),\n\n  reset: () => set(initialState),\n}));\n","import { FC, useEffect } from 'react';\nimport { useTranscriptStore } from '@/store/transcriptStore';\nimport { Button } from '@/components/ui/Button';\nimport styles from './TranscriptPicker.module.css';\n\ninterface Props {\n  deckId: string;\n}\n\nexport const TranscriptPicker: FC<Props> = ({ deckId }) => {\n  const {\n    availableTranscripts,\n    isLoading,\n    loadTranscriptsForDeck,\n    selectTranscript,\n  } = useTranscriptStore();\n\n  useEffect(() => {\n    loadTranscriptsForDeck(deckId);\n  }, [deckId, loadTranscriptsForDeck]);\n\n  // Don't render anything while loading initially\n  if (isLoading) {\n    return (\n      <div className={styles.container}>\n        <h3 className={styles.title}>Transcripts</h3>\n        <div className={styles.loading}>Loading...</div>\n      </div>\n    );\n  }\n\n  // Don't show section if no transcripts available for this deck\n  if (availableTranscripts.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={styles.container}>\n      <h3 className={styles.title}>Transcripts</h3>\n      <p className={styles.subtitle}>Raw text for external readers</p>\n      <div className={styles.transcriptList}>\n        {availableTranscripts.map((transcript) => (\n          <Button\n            key={transcript.id}\n            variant=\"secondary\"\n            className={styles.transcriptButton}\n            onClick={() => selectTranscript(transcript)}\n          >\n            <div className={styles.transcriptContent}>\n              <span className={styles.transcriptName}>\n                {transcript.displayName}\n              </span>\n              <svg\n                width=\"16\"\n                height=\"16\"\n                viewBox=\"0 0 24 24\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeWidth=\"2\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                className={styles.icon}\n                aria-hidden=\"true\"\n              >\n                <path d=\"M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6\" />\n                <polyline points=\"15,3 21,3 21,9\" />\n                <line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\" />\n              </svg>\n            </div>\n          </Button>\n        ))}\n      </div>\n    </div>\n  );\n};\n","import { FC } from 'react';\nimport { Deck } from '@/types';\nimport { ReadDialoguePicker } from './ReadDialoguePicker';\nimport { TranscriptPicker } from './TranscriptPicker';\nimport styles from './ReadSidebar.module.css';\n\ninterface ReadProgress {\n  dialogueId: string;\n  lineIndex: number;\n  tokenIndex: number;\n  completedTokens: Set<string>;\n  masteredTokens: Set<string>;\n}\n\ninterface Props {\n  deck: Deck;\n  selectedDialogueId: string | null;\n  onSelectDialogue: (dialogueId: string) => void;\n  progress: ReadProgress | null;\n}\n\nexport const ReadSidebar: FC<Props> = ({\n  deck,\n  selectedDialogueId,\n  onSelectDialogue,\n  progress,\n}) => {\n  const hasDialogues = deck.reading && Object.keys(deck.reading.dialogues).length > 0;\n\n  return (\n    <div className={styles.sidebar}>\n      {hasDialogues && (\n        <ReadDialoguePicker\n          deck={deck}\n          selectedDialogueId={selectedDialogueId}\n          onSelectDialogue={onSelectDialogue}\n          progress={progress}\n        />\n      )}\n\n      <div className={styles.divider} />\n\n      <TranscriptPicker deckId={deck.id} />\n    </div>\n  );\n};\n","import { FC } from 'react';\n\ninterface CopyIconProps {\n  size?: number;\n  color?: string;\n  className?: string;\n}\n\nconst CopyIcon: FC<CopyIconProps> = ({\n  size = 24,\n  color = 'currentColor',\n  className = '',\n}) => {\n  return (\n    <svg\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke={color}\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={className}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      aria-hidden=\"true\"\n    >\n      <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\" />\n      <path d=\"M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1\" />\n    </svg>\n  );\n};\n\nexport default CopyIcon;\n","import { FC, useCallback, useState, useRef, useEffect } from 'react';\nimport { Modal } from '@/components/ui/Modal';\nimport CopyIcon from '@/components/icons/CopyIcon';\nimport { PlayIcon, PauseIcon, SkipBackIcon, SkipForwardIcon, RestartIcon } from '@/components/icons/ModeIcons';\nimport { useTranscriptStore } from '@/store/transcriptStore';\nimport styles from './TranscriptModal.module.css';\n\nexport const TranscriptModal: FC = () => {\n  const {\n    isModalOpen,\n    selectedTranscript,\n    transcriptContent,\n    isLoadingContent,\n    error,\n    closeModal,\n  } = useTranscriptStore();\n\n  const [copySuccess, setCopySuccess] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackRate, setPlaybackRate] = useState(100);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n\n  const audioFile = selectedTranscript?.audioFile;\n  const audioUrl = audioFile ? `${import.meta.env.BASE_URL}data/audio/${audioFile}` : null;\n\n  // Cleanup audio when modal closes\n  useEffect(() => {\n    if (!isModalOpen && audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n      setIsPlaying(false);\n      setCurrentTime(0);\n    }\n  }, [isModalOpen]);\n\n  // Handle audio events\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n\n    const handleEnded = () => setIsPlaying(false);\n    const handleTimeUpdate = () => setCurrentTime(audio.currentTime);\n    const handleLoadedMetadata = () => setDuration(audio.duration);\n\n    audio.addEventListener('ended', handleEnded);\n    audio.addEventListener('timeupdate', handleTimeUpdate);\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n\n    return () => {\n      audio.removeEventListener('ended', handleEnded);\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n    };\n  }, [audioUrl]);\n\n  // Update playback rate when slider changes\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.playbackRate = playbackRate / 100;\n    }\n  }, [playbackRate]);\n\n  const handlePlayPause = useCallback(() => {\n    if (!audioRef.current) return;\n\n    if (isPlaying) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    } else {\n      audioRef.current.play();\n      setIsPlaying(true);\n    }\n  }, [isPlaying]);\n\n  const handleSkipBack = useCallback(() => {\n    if (!audioRef.current) return;\n    audioRef.current.currentTime = Math.max(0, audioRef.current.currentTime - 10);\n  }, []);\n\n  const handleSkipForward = useCallback(() => {\n    if (!audioRef.current) return;\n    audioRef.current.currentTime = Math.min(duration, audioRef.current.currentTime + 10);\n  }, [duration]);\n\n  const handleRestart = useCallback(() => {\n    if (!audioRef.current) return;\n    audioRef.current.currentTime = 0;\n    if (!isPlaying) {\n      audioRef.current.play();\n      setIsPlaying(true);\n    }\n  }, [isPlaying]);\n\n  const handleSeek = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!audioRef.current) return;\n    const newTime = Number(e.target.value);\n    audioRef.current.currentTime = newTime;\n    setCurrentTime(newTime);\n  }, []);\n\n  const formatTime = (time: number) => {\n    const mins = Math.floor(time / 60);\n    const secs = Math.floor(time % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const handleSpeedDecrease = useCallback(() => {\n    setPlaybackRate(prev => Math.max(75, prev - 5));\n  }, []);\n\n  const handleSpeedIncrease = useCallback(() => {\n    setPlaybackRate(prev => Math.min(100, prev + 5));\n  }, []);\n\n  const handleCopy = useCallback(async () => {\n    if (!transcriptContent) return;\n\n    try {\n      await navigator.clipboard.writeText(transcriptContent);\n      setCopySuccess(true);\n      setTimeout(() => setCopySuccess(false), 2000);\n    } catch (err) {\n      // Fallback for older browsers\n      try {\n        const textArea = document.createElement('textarea');\n        textArea.value = transcriptContent;\n        textArea.style.position = 'fixed';\n        textArea.style.left = '-9999px';\n        document.body.appendChild(textArea);\n        textArea.select();\n        document.execCommand('copy');\n        document.body.removeChild(textArea);\n        setCopySuccess(true);\n        setTimeout(() => setCopySuccess(false), 2000);\n      } catch (fallbackErr) {\n        console.error('Failed to copy text:', fallbackErr);\n      }\n    }\n  }, [transcriptContent]);\n\n  const modalTitle = selectedTranscript\n    ? `${selectedTranscript.displayName} Transcript`\n    : 'Transcript';\n\n  return (\n    <Modal\n      isOpen={isModalOpen}\n      onClose={closeModal}\n      title={modalTitle}\n      size=\"large\"\n      className={styles.transcriptModal}\n    >\n      <div className={styles.modalContent}>\n        {audioUrl ? (\n          <>\n            <audio ref={audioRef} src={audioUrl} preload=\"metadata\" />\n            <div className={styles.audioPlayer}>\n              <div className={styles.progressContainer}>\n                <span className={styles.time}>{formatTime(currentTime)}</span>\n                <input\n                  type=\"range\"\n                  min=\"0\"\n                  max={duration || 100}\n                  value={currentTime}\n                  onChange={handleSeek}\n                  className={styles.progressBar}\n                  aria-label=\"Seek\"\n                />\n                <span className={styles.time}>{formatTime(duration)}</span>\n              </div>\n              <div className={styles.controls}>\n                <button\n                  onClick={handleRestart}\n                  className={styles.controlBtn}\n                  aria-label=\"Restart\"\n                  disabled={isLoadingContent}\n                >\n                  <RestartIcon size={26} />\n                </button>\n                <button\n                  onClick={handleSkipBack}\n                  className={styles.skipBtn}\n                  aria-label=\"Skip back 10 seconds\"\n                  disabled={isLoadingContent}\n                >\n                  <SkipBackIcon size={36} />\n                </button>\n                <button\n                  onClick={handlePlayPause}\n                  className={styles.playBtn}\n                  aria-label={isPlaying ? 'Pause' : 'Play'}\n                  disabled={isLoadingContent}\n                >\n                  {isPlaying ? <PauseIcon size={32} /> : <PlayIcon size={32} />}\n                </button>\n                <button\n                  onClick={handleSkipForward}\n                  className={styles.skipBtn}\n                  aria-label=\"Skip forward 10 seconds\"\n                  disabled={isLoadingContent}\n                >\n                  <SkipForwardIcon size={36} />\n                </button>\n                <div className={styles.copyContainer}>\n                  {copySuccess && <span className={styles.copiedText}>Copied!</span>}\n                  <button\n                    onClick={handleCopy}\n                    className={styles.copyBtn}\n                    aria-label={copySuccess ? 'Copied!' : 'Copy transcript'}\n                    title={copySuccess ? 'Copied!' : 'Copy'}\n                    disabled={!transcriptContent || isLoadingContent}\n                  >\n                    <CopyIcon size={22} />\n                  </button>\n                </div>\n              </div>\n              <div className={styles.speedControl}>\n                <button\n                  onClick={handleSpeedDecrease}\n                  className={styles.speedBtn}\n                  aria-label=\"Decrease speed\"\n                  disabled={playbackRate <= 75}\n                >\n                  -\n                </button>\n                <span className={styles.speedLabel}>{playbackRate}%</span>\n                <input\n                  type=\"range\"\n                  min=\"75\"\n                  max=\"100\"\n                  step=\"5\"\n                  value={playbackRate}\n                  onChange={(e) => setPlaybackRate(Number(e.target.value))}\n                  className={styles.speedSlider}\n                  aria-label=\"Playback speed\"\n                />\n                <button\n                  onClick={handleSpeedIncrease}\n                  className={styles.speedBtn}\n                  aria-label=\"Increase speed\"\n                  disabled={playbackRate >= 100}\n                >\n                  +\n                </button>\n              </div>\n            </div>\n          </>\n        ) : (\n          <div className={styles.textToolbar}>\n            <div className={styles.copyContainer}>\n              {copySuccess && <span className={styles.copiedText}>Copied!</span>}\n              <button\n                onClick={handleCopy}\n                className={styles.copyBtn}\n                aria-label={copySuccess ? 'Copied!' : 'Copy transcript'}\n                title={copySuccess ? 'Copied!' : 'Copy'}\n                disabled={!transcriptContent || isLoadingContent}\n              >\n                <CopyIcon size={22} />\n              </button>\n            </div>\n          </div>\n        )}\n\n        <div className={styles.contentContainer}>\n          {isLoadingContent ? (\n            <div className={styles.loading}>\n              <div className={styles.spinner} />\n              <span>Loading transcript...</span>\n            </div>\n          ) : error ? (\n            <div className={styles.error}>\n              <p>Failed to load transcript content.</p>\n              <p className={styles.errorDetail}>{error}</p>\n            </div>\n          ) : transcriptContent ? (\n            <pre className={styles.transcriptText}>{transcriptContent}</pre>\n          ) : (\n            <div className={styles.empty}>No content available.</div>\n          )}\n        </div>\n      </div>\n    </Modal>\n  );\n};\n","import { SentenceTranslationResult, ReadingLine } from '@/types';\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));\n\n  for (let i = 0; i <= a.length; i += 1) {\n    matrix[0][i] = i;\n  }\n\n  for (let j = 0; j <= b.length; j += 1) {\n    matrix[j][0] = j;\n  }\n\n  for (let j = 1; j <= b.length; j += 1) {\n    for (let i = 1; i <= a.length; i += 1) {\n      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;\n      matrix[j][i] = Math.min(\n        matrix[j][i - 1] + 1, // deletion\n        matrix[j - 1][i] + 1, // insertion\n        matrix[j - 1][i - 1] + indicator // substitution\n      );\n    }\n  }\n\n  return matrix[b.length][a.length];\n}\n\n/**\n * Calculate similarity percentage between two strings\n */\nfunction calculateSimilarity(str1: string, str2: string): number {\n  const normalizedStr1 = normalizeText(str1);\n  const normalizedStr2 = normalizeText(str2);\n\n  if (normalizedStr1 === normalizedStr2) return 100;\n  if (normalizedStr1.length === 0 && normalizedStr2.length === 0) return 100;\n  if (normalizedStr1.length === 0 || normalizedStr2.length === 0) return 0;\n\n  const maxLength = Math.max(normalizedStr1.length, normalizedStr2.length);\n  const distance = levenshteinDistance(normalizedStr1, normalizedStr2);\n\n  return Math.max(0, (maxLength - distance) / maxLength * 100);\n}\n\n/**\n * Normalize text for comparison (lowercase, trim, remove extra spaces)\n */\nfunction normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[.,!?;:()\\[\\]{}\"'`~@#$%^&*+=\\-\\/\\\\|<>]/g, '') // Remove punctuation\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n\n/**\n * Extract individual words from text for word-level matching\n */\nfunction extractWords(text: string): string[] {\n  return normalizeText(text)\n    .split(/\\s+/)\n    .filter(word => word.length > 0);\n}\n\n/**\n * Calculate word-level matches between user answer and correct answer\n */\nfunction calculateWordMatches(userAnswer: string, correctAnswer: string): Array<{\n  word: string;\n  matched: boolean;\n  similarity?: number;\n}> {\n  const userWords = extractWords(userAnswer);\n  const correctWords = extractWords(correctAnswer);\n  const matchedCorrectWords = new Set<string>();\n\n  return userWords.map(userWord => {\n    // Find best match among correct words\n    let bestMatch: string | null = null;\n    let bestSimilarity = 0;\n\n    correctWords.forEach(correctWord => {\n      if (matchedCorrectWords.has(correctWord)) return; // Already matched\n\n      const similarity = calculateSimilarity(userWord, correctWord);\n      if (similarity > bestSimilarity && similarity >= 70) { // 70% threshold for word matching\n        bestMatch = correctWord;\n        bestSimilarity = similarity;\n      }\n    });\n\n    if (bestMatch) {\n      matchedCorrectWords.add(bestMatch);\n      return {\n        word: userWord,\n        matched: true,\n        similarity: bestSimilarity\n      };\n    }\n\n    return {\n      word: userWord,\n      matched: false\n    };\n  });\n}\n\n/**\n * Generate alternative answers from word alignments\n */\nfunction generateAlternativeAnswers(line: ReadingLine, targetSide: string): string[] {\n  const alternatives: string[] = [];\n\n  // Add the main target side text\n  const mainText = line[targetSide as keyof ReadingLine] as string;\n  if (mainText) {\n    alternatives.push(mainText);\n  }\n\n  // Generate alternatives from word alignments if available\n  if (line.wordAlignments && targetSide === 'c') { // English translations\n    const words = line.wordAlignments\n      .filter(alignment => alignment.english.trim().length > 0)\n      .map(alignment => alignment.english.trim());\n\n    if (words.length > 0) {\n      alternatives.push(words.join(' '));\n    }\n  }\n\n  return [...new Set(alternatives)]; // Remove duplicates\n}\n\n/**\n * Check sentence translation and provide detailed feedback\n */\nexport function checkSentenceTranslation(\n  userAnswer: string,\n  line: ReadingLine,\n  targetSide: string,\n  accuracyThreshold: number = 70\n): SentenceTranslationResult {\n  const alternatives = generateAlternativeAnswers(line, targetSide);\n  const correctAnswer = alternatives[0] || '';\n\n  if (!correctAnswer) {\n    return {\n      userAnswer,\n      correctAnswer: '',\n      accuracy: 0,\n      isCorrect: false,\n      suggestions: []\n    };\n  }\n\n  // Calculate accuracy against all alternatives, use the best score\n  let bestAccuracy = 0;\n  let bestCorrectAnswer = correctAnswer;\n\n  alternatives.forEach(alternative => {\n    const accuracy = calculateSimilarity(userAnswer, alternative);\n    if (accuracy > bestAccuracy) {\n      bestAccuracy = accuracy;\n      bestCorrectAnswer = alternative;\n    }\n  });\n\n  const wordMatches = calculateWordMatches(userAnswer, bestCorrectAnswer);\n  const isCorrect = bestAccuracy >= accuracyThreshold;\n\n  return {\n    userAnswer,\n    correctAnswer: bestCorrectAnswer,\n    accuracy: Math.round(bestAccuracy),\n    isCorrect,\n    wordMatches,\n    suggestions: alternatives.slice(1) // Alternative answers excluding the best match\n  };\n}\n\n/**\n * Generate multiple choice options for sentence translation\n */\nexport function generateSentenceMultipleChoice(\n  line: ReadingLine,\n  targetSide: string,\n  allLines: ReadingLine[],\n  optionsCount: number = 4,\n  difficulty: 'easy' | 'medium' | 'hard' = 'medium'\n): string[] {\n  const correctAnswer = line[targetSide as keyof ReadingLine] as string;\n  if (!correctAnswer) return [];\n\n  const options = [correctAnswer];\n  const usedAnswers = new Set([normalizeText(correctAnswer)]);\n\n  // Generate distractors based on difficulty\n  const potentialDistractors: string[] = [];\n\n  if (difficulty === 'easy') {\n    // Use other sides from the same line\n    Object.keys(line).forEach(side => {\n      if (side !== targetSide && typeof line[side as keyof ReadingLine] === 'string') {\n        const text = line[side as keyof ReadingLine] as string;\n        if (text && !usedAnswers.has(normalizeText(text))) {\n          potentialDistractors.push(text);\n        }\n      }\n    });\n  }\n\n  // Add distractors from other lines regardless of difficulty\n  allLines.forEach(otherLine => {\n    if (otherLine === line) return;\n\n    const text = otherLine[targetSide as keyof ReadingLine] as string;\n    if (text && !usedAnswers.has(normalizeText(text))) {\n      potentialDistractors.push(text);\n    }\n  });\n\n  // Shuffle and select distractors\n  const shuffledDistractors = potentialDistractors\n    .sort(() => Math.random() - 0.5)\n    .slice(0, optionsCount - 1);\n\n  options.push(...shuffledDistractors);\n\n  // Shuffle all options\n  return options.sort(() => Math.random() - 0.5);\n}\n\n/**\n * Get hint text for a specific Chinese word using word alignments\n */\nexport function getWordHint(\n  line: ReadingLine,\n  chineseWord: string,\n  targetSide: string\n): { pinyin?: string; translation?: string } | null {\n  if (!line.wordAlignments) return null;\n\n  const alignment = line.wordAlignments.find(\n    alignment => alignment.chinese === chineseWord\n  );\n\n  if (!alignment) return null;\n\n  const result: { pinyin?: string; translation?: string } = {};\n\n  if (alignment.pinyin && alignment.pinyin.trim()) {\n    result.pinyin = alignment.pinyin;\n  }\n\n  if (targetSide === 'c' && alignment.english && alignment.english.trim()) {\n    result.translation = alignment.english;\n  }\n\n  return Object.keys(result).length > 0 ? result : null;\n}","import { ReadingLine } from '@/types';\n\nexport interface AlignedToken {\n  chinese: string;\n  pinyin: string;\n  english: string;\n  index: number;\n}\n\n/**\n * Extracts aligned tokens from wordAlignments data\n * This provides a 1:1 mapping between Chinese, pinyin, and English tokens\n */\nexport function extractAlignedTokens(line: ReadingLine): AlignedToken[] {\n  if (!line.wordAlignments || line.wordAlignments.length === 0) {\n    return [];\n  }\n\n  return line.wordAlignments.map((alignment, index) => ({\n    chinese: alignment.chinese,\n    pinyin: alignment.pinyin,\n    english: alignment.english,\n    index\n  }));\n}\n\n/**\n * Checks if a line has word alignment data available\n */\nexport function hasWordAlignments(line: ReadingLine): boolean {\n  return Boolean(line.wordAlignments && line.wordAlignments.length > 0);\n}\n\n/**\n * Gets the aligned translation for a specific Chinese token\n */\nexport function getAlignedTranslation(\n  line: ReadingLine,\n  tokenIndex: number\n): { pinyin: string; english: string } | null {\n  if (!hasWordAlignments(line) || !line.wordAlignments) {\n    return null;\n  }\n\n  const alignment = line.wordAlignments[tokenIndex];\n  if (!alignment) {\n    return null;\n  }\n\n  return {\n    pinyin: alignment.pinyin,\n    english: alignment.english\n  };\n}\n\n/**\n * Finds the token index for a given Chinese text\n */\nexport function findTokenIndex(line: ReadingLine, chineseText: string): number {\n  if (!hasWordAlignments(line) || !line.wordAlignments) {\n    return -1;\n  }\n\n  return line.wordAlignments.findIndex(\n    alignment => alignment.chinese === chineseText\n  );\n}\n\n/**\n * Creates a combined display text for word-by-word reading\n * This shows Chinese with hover/tap for translations\n */\nexport function createInteractiveTokens(line: ReadingLine): AlignedToken[] {\n  const tokens = extractAlignedTokens(line);\n\n  // Filter out empty English translations (punctuation, particles, etc.)\n  return tokens.map(token => ({\n    ...token,\n    // Mark tokens with empty English as non-interactive\n    english: token.english.trim() || ''\n  }));\n}","import { FC, useState, useCallback, useMemo, useEffect, useRef } from 'react';\nimport { ReadingLine, ReadModeSettings, SentenceTranslationResult } from '@/types';\nimport { checkSentenceTranslation, generateSentenceMultipleChoice } from '@/utils/sentenceTranslation';\nimport { hasWordAlignments, extractAlignedTokens, AlignedToken } from '@/utils/wordAlignments';\nimport { Button } from '@/components/ui/Button';\nimport styles from './SentenceTranslation.module.css';\n\ninterface Props {\n  line: ReadingLine;\n  allLines: ReadingLine[]; // For generating MC distractors\n  settings: ReadModeSettings;\n  onAnswer: (result: SentenceTranslationResult) => void;\n  onSkip?: () => void;\n  showResult?: boolean;\n  disabled?: boolean;\n}\n\nexport const SentenceTranslation: FC<Props> = ({\n  line,\n  allLines,\n  settings,\n  onAnswer,\n  onSkip,\n  showResult = false,\n  disabled = false\n}) => {\n  const [userAnswer, setUserAnswer] = useState('');\n  const [selectedOption, setSelectedOption] = useState<string | null>(null);\n  const [result, setResult] = useState<SentenceTranslationResult | null>(null);\n\n  // Get source and target text\n  const sourceText = line[settings.translationDirection.from] || '';\n  // const targetText = line[settings.translationDirection.to] || ''; // Used in checking\n\n  // Generate multiple choice options\n  const mcOptions = useMemo(() => {\n    if (settings.answerType === 'multiple_choice') {\n      return generateSentenceMultipleChoice(\n        line,\n        settings.translationDirection.to,\n        allLines,\n        settings.optionsCount || 4,\n        settings.multipleChoiceDifficulty || 'medium'\n      );\n    }\n    return [];\n  }, [line, allLines, settings]);\n\n  // Check if word alignments are available for hints\n  const hasAlignments = useMemo(() => hasWordAlignments(line), [line]);\n  const alignedTokens = useMemo(() => {\n    return hasAlignments ? extractAlignedTokens(line) : [];\n  }, [line, hasAlignments]);\n\n  // Handle answer submission\n  const handleSubmit = useCallback(() => {\n    if (disabled || result) return;\n\n    const answer = settings.answerType === 'multiple_choice' ? selectedOption || '' : userAnswer;\n    const translationResult = checkSentenceTranslation(\n      answer,\n      line,\n      settings.translationDirection.to,\n      settings.accuracyThreshold || 70\n    );\n\n    setResult(translationResult);\n    onAnswer(translationResult);\n  }, [userAnswer, selectedOption, settings, line, onAnswer, disabled, result]);\n\n  // Handle multiple choice selection\n  const handleOptionSelect = useCallback((option: string) => {\n    if (disabled || result) return;\n    setSelectedOption(option);\n\n    if (settings.checkMode === 'live') {\n      // Auto-submit on selection for live mode\n      setTimeout(() => {\n        const translationResult = checkSentenceTranslation(\n          option,\n          line,\n          settings.translationDirection.to,\n          settings.accuracyThreshold || 70\n        );\n        setResult(translationResult);\n        onAnswer(translationResult);\n      }, 100);\n    }\n  }, [settings, line, onAnswer, disabled, result]);\n\n  // Handle free text input\n  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (disabled || result) return;\n    setUserAnswer(e.target.value);\n\n    if (settings.checkMode === 'live' && e.target.value.trim()) {\n      // Debounced live checking could go here\n    }\n  }, [settings, disabled, result]);\n\n  // Handle key press for submission\n  const handleKeyPress = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit();\n    }\n  }, [handleSubmit]);\n\n  // Track which token is tapped (for mobile hint display)\n  const [tappedTokenIndex, setTappedTokenIndex] = useState<number | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Close tapped hint when clicking outside\n  useEffect(() => {\n    if (tappedTokenIndex === null) return;\n    const handleOutsideClick = (e: MouseEvent | TouchEvent) => {\n      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {\n        setTappedTokenIndex(null);\n      }\n    };\n    document.addEventListener('mousedown', handleOutsideClick);\n    document.addEventListener('touchstart', handleOutsideClick);\n    return () => {\n      document.removeEventListener('mousedown', handleOutsideClick);\n      document.removeEventListener('touchstart', handleOutsideClick);\n    };\n  }, [tappedTokenIndex]);\n\n  // Get the display text and hint text for a token based on translation direction\n  const getTokenDisplay = useCallback((token: AlignedToken): string => {\n    const from = settings.translationDirection.from;\n    if (from === 'b') return token.pinyin;\n    if (from === 'c') return token.english;\n    return token.chinese; // default: side 'a'\n  }, [settings.translationDirection.from]);\n\n  const getTokenHint = useCallback((token: AlignedToken): string => {\n    const from = settings.translationDirection.from;\n    const parts: string[] = [];\n    if (from !== 'a' && token.chinese) parts.push(token.chinese);\n    if (from !== 'b' && token.pinyin) parts.push(token.pinyin);\n    if (from !== 'c' && token.english) parts.push(token.english);\n    return parts.join(' - ');\n  }, [settings.translationDirection.from]);\n\n  // Determine if a token has a meaningful hint\n  const tokenHasHint = useCallback((token: AlignedToken): boolean => {\n    return getTokenHint(token).length > 0;\n  }, [getTokenHint]);\n\n  // Handle token tap/click for hints\n  const handleTokenTap = useCallback((index: number) => {\n    if (!settings.showWordHints || !hasAlignments) return;\n    setTappedTokenIndex(prev => prev === index ? null : index);\n  }, [settings.showWordHints, hasAlignments]);\n\n  // Reset when line changes\n  useEffect(() => {\n    setUserAnswer('');\n    setSelectedOption(null);\n    setResult(null);\n    setTappedTokenIndex(null);\n  }, [line]);\n\n  const canSubmit = settings.answerType === 'multiple_choice'\n    ? selectedOption !== null\n    : userAnswer.trim().length > 0;\n\n  return (\n    <div className={styles.container}>\n      {/* Source text with word hints */}\n      <div className={styles.sourceSection}>\n        <div className={styles.sectionLabel}>\n          Translate this sentence:\n        </div>\n        <div className={styles.sourceText} ref={containerRef}>\n           {hasAlignments && settings.showWordHints ? (\n             <div className={styles.interactiveSource}>\n               <div className={styles.wordTokensContainer}>\n                 {alignedTokens.map((token, index) => {\n                   const hint = getTokenHint(token);\n                   const hasHint = tokenHasHint(token);\n                   const isRevealed = tappedTokenIndex === index;\n                   return (\n                     <span\n                       key={index}\n                       className={`${styles.wordToken} ${hasHint ? styles.clickable : styles.static} ${isRevealed ? styles.revealed : ''}`}\n                       onClick={() => hasHint && handleTokenTap(index)}\n                     >\n                       {getTokenDisplay(token)}\n                       {isRevealed && hint && (\n                         <span className={styles.tokenHintPopup}>{hint}</span>\n                       )}\n                     </span>\n                   );\n                 })}\n               </div>\n               <div className={styles.hintText}>\n                 Tap words for hints\n               </div>\n             </div>\n           ) : (\n             <div className={styles.staticSource}>{sourceText}</div>\n           )}\n         </div>\n      </div>\n\n      {/* Answer input section */}\n      <div className={styles.answerSection}>\n        <div className={styles.sectionLabel}>\n          Your translation:\n        </div>\n\n        {settings.answerType === 'free_text' ? (\n          <div className={styles.freeTextSection}>\n            <textarea\n              className={`${styles.textInput} ${result ? styles.submitted : ''}`}\n              value={userAnswer}\n              onChange={handleTextChange}\n              onKeyPress={handleKeyPress}\n              placeholder=\"Type your translation here...\"\n              disabled={disabled || !!result}\n              rows={3}\n            />\n          </div>\n        ) : (\n          <div className={styles.multipleChoiceSection}>\n            {mcOptions.map((option, index) => (\n              <button\n                key={index}\n                className={`${styles.option} ${\n                  selectedOption === option ? styles.selected : ''\n                } ${result ? (\n                  option === result.correctAnswer ? styles.correct :\n                  selectedOption === option ? styles.incorrect : ''\n                ) : ''}`}\n                onClick={() => handleOptionSelect(option)}\n                disabled={disabled || !!result}\n              >\n                <span className={styles.optionLetter}>\n                  {String.fromCharCode(65 + index)}\n                </span>\n                <span className={styles.optionText}>{option}</span>\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Action buttons */}\n      {!result && (\n        <div className={styles.actions}>\n          {settings.checkMode === 'wait' && (\n            <Button\n              variant=\"primary\"\n              onClick={handleSubmit}\n              disabled={!canSubmit || disabled}\n              className={styles.submitButton}\n            >\n              Check Answer\n            </Button>\n          )}\n          {onSkip && (\n            <Button\n              variant=\"secondary\"\n              onClick={onSkip}\n              disabled={disabled}\n              className={styles.skipButton}\n            >\n              Skip\n            </Button>\n          )}\n        </div>\n      )}\n\n      {/* Results display */}\n      {result && showResult && (\n        <div className={styles.resultSection}>\n          <div className={`${styles.resultHeader} ${result.isCorrect ? styles.correct : styles.incorrect}`}>\n            <div className={styles.accuracyScore}>\n              {result.accuracy}% accuracy\n            </div>\n            <div className={styles.resultStatus}>\n              {result.isCorrect ? 'Correct!' : 'Needs improvement'}\n            </div>\n          </div>\n\n          {!result.isCorrect && (\n            <div className={styles.correctAnswer}>\n              <div className={styles.correctLabel}>Correct answer:</div>\n              <div className={styles.correctText}>{result.correctAnswer}</div>\n            </div>\n          )}\n\n          {result.wordMatches && result.wordMatches.length > 0 && (\n            <div className={styles.wordAnalysis}>\n              <div className={styles.analysisLabel}>Word analysis:</div>\n              <div className={styles.wordMatches}>\n                {result.wordMatches.map((match, index) => (\n                  <span\n                    key={index}\n                    className={`${styles.wordMatch} ${match.matched ? styles.matched : styles.unmatched}`}\n                    title={match.similarity ? `${Math.round(match.similarity)}% match` : undefined}\n                  >\n                    {match.word}\n                  </span>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {result.suggestions && result.suggestions.length > 0 && (\n            <div className={styles.suggestions}>\n              <div className={styles.suggestionsLabel}>Alternative answers:</div>\n              <div className={styles.suggestionsList}>\n                {result.suggestions.map((suggestion, index) => (\n                  <div key={index} className={styles.suggestion}>\n                    {suggestion}\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};","import { SideId, ReadingLine, ReadingTokenizationConfig, WordAlignment } from '@/types';\n\nexport interface Token {\n  text: string;\n  start: number;\n  end: number;\n}\n\nexport type LineTokens = Partial<Record<SideId, Token[]>>;\n\n// Default tokenization configuration\nconst DEFAULT_TOKENIZATION: ReadingTokenizationConfig = {\n  unit: {\n    a: 'character',\n    b: 'space',\n    c: 'space',\n    d: undefined,\n    e: undefined,\n    f: undefined\n  },\n  preservePunctuation: true\n};\n\n// Check if character is CJK (Chinese, Japanese, Korean)\nconst isCJKCharacter = (char: string): boolean => {\n  const code = char.charCodeAt(0);\n  return (\n    (code >= 0x4e00 && code <= 0x9fff) || // CJK Unified Ideographs\n    (code >= 0x3400 && code <= 0x4dbf) || // CJK Extension A\n    (code >= 0x20000 && code <= 0x2a6df) || // CJK Extension B\n    (code >= 0x2a700 && code <= 0x2b73f) || // CJK Extension C\n    (code >= 0x2b740 && code <= 0x2b81f) || // CJK Extension D\n    (code >= 0x3040 && code <= 0x309f) || // Hiragana\n    (code >= 0x30a0 && code <= 0x30ff) || // Katakana\n    (code >= 0xac00 && code <= 0xd7af) // Hangul Syllables\n  );\n};\n\n// Tokenize by character\nconst tokenizeByCharacter = (text: string, preservePunctuation: boolean): Token[] => {\n  const tokens: Token[] = [];\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n\n    // Skip or include punctuation based on settings\n    if (!preservePunctuation && /\\s|[.,!?;:]/.test(char)) {\n      continue;\n    }\n\n    // Skip whitespace for character tokenization\n    if (/\\s/.test(char)) {\n      continue;\n    }\n\n    tokens.push({\n      text: char,\n      start: i,\n      end: i + 1\n    });\n  }\n\n  return tokens;\n};\n\n// Tokenize by word (space-separated)\nconst tokenizeByWord = (text: string, preservePunctuation: boolean): Token[] => {\n  const tokens: Token[] = [];\n  let currentWord = '';\n  let wordStart = 0;\n\n  for (let i = 0; i <= text.length; i++) {\n    const char = text[i];\n\n    if (i === text.length || /\\s/.test(char)) {\n      if (currentWord) {\n        // Remove trailing punctuation if needed\n        let wordText = currentWord;\n        if (!preservePunctuation) {\n          wordText = wordText.replace(/[.,!?;:]+$/, '');\n        }\n\n        if (wordText) {\n          tokens.push({\n            text: wordText,\n            start: wordStart,\n            end: wordStart + wordText.length\n          });\n        }\n\n        currentWord = '';\n      }\n      wordStart = i + 1;\n    } else {\n      if (currentWord === '') {\n        wordStart = i;\n      }\n      currentWord += char;\n    }\n  }\n\n  return tokens;\n};\n\n// Tokenize by space (keep spaces as separators)\nconst tokenizeBySpace = (text: string, preservePunctuation: boolean): Token[] => {\n  return tokenizeByWord(text, preservePunctuation);\n};\n\n// Smart tokenization - detect CJK for character-based, otherwise word-based\nconst tokenizeSmart = (text: string, preservePunctuation: boolean): Token[] => {\n  // Check if text contains significant CJK characters\n  const totalChars = text.replace(/\\s/g, '').length;\n  const cjkChars = Array.from(text).filter(isCJKCharacter).length;\n\n  // If more than 30% CJK, use character tokenization\n  if (cjkChars > 0 && cjkChars / totalChars > 0.3) {\n    return tokenizeByCharacter(text, preservePunctuation);\n  }\n\n  // Otherwise use word tokenization\n  return tokenizeByWord(text, preservePunctuation);\n};\n\n// Main tokenization function\nexport const tokenizeLine = (\n  line: ReadingLine,\n  config?: ReadingTokenizationConfig\n): LineTokens => {\n  const tokenConfig = config || DEFAULT_TOKENIZATION;\n\n  // If wordAlignments exist, use them for precise alignment\n  if (line.wordAlignments && line.wordAlignments.length > 0) {\n    return tokenizeWithWordAlignments(line.wordAlignments);\n  }\n\n  // Fallback to original tokenization method\n  const result: LineTokens = {};\n  const sideIds: SideId[] = ['a', 'b', 'c', 'd', 'e', 'f'];\n\n  for (const side of sideIds) {\n    const text = line[side];\n    if (!text) continue;\n\n    const unit = tokenConfig.unit[side];\n    if (!unit) continue;\n\n    switch (unit) {\n      case 'character':\n        result[side] = tokenizeByCharacter(text, tokenConfig.preservePunctuation);\n        break;\n      case 'word':\n        result[side] = tokenizeByWord(text, tokenConfig.preservePunctuation);\n        break;\n      case 'space':\n        result[side] = tokenizeBySpace(text, tokenConfig.preservePunctuation);\n        break;\n      default:\n        // Fallback to smart tokenization\n        result[side] = tokenizeSmart(text, tokenConfig.preservePunctuation);\n    }\n  }\n\n  return result;\n};\n\n// Tokenize using word alignments\nconst tokenizeWithWordAlignments = (wordAlignments: WordAlignment[]): LineTokens => {\n  const result: LineTokens = {\n    a: [], // Chinese\n    b: [], // Pinyin\n    c: []  // English\n  };\n\n  let chinesePos = 0;\n  let pinyinPos = 0;\n  let englishPos = 0;\n\n  wordAlignments.forEach(alignment => {\n    // Chinese token (side a)\n    result.a!.push({\n      text: alignment.chinese,\n      start: chinesePos,\n      end: chinesePos + alignment.chinese.length\n    });\n    chinesePos += alignment.chinese.length;\n\n    // Pinyin token (side b)\n    result.b!.push({\n      text: alignment.pinyin,\n      start: pinyinPos,\n      end: pinyinPos + alignment.pinyin.length\n    });\n    pinyinPos += alignment.pinyin.length + 1; // +1 for space\n\n    // English token (side c)\n    result.c!.push({\n      text: alignment.english,\n      start: englishPos,\n      end: englishPos + alignment.english.length\n    });\n    englishPos += alignment.english.length + 1; // +1 for space\n  });\n\n  return result;\n};\n\n// Get aligned tokens based on index or heuristic\nexport const getAlignedTokens = (\n  lineTokens: LineTokens,\n  line: ReadingLine,\n  fromSide: SideId,\n  toSide: SideId\n): Map<number, number> => {\n  const alignment = new Map<number, number>();\n\n  const fromTokens = lineTokens[fromSide];\n  const toTokens = lineTokens[toSide];\n\n  if (!fromTokens || !toTokens) return alignment;\n\n  // If explicit alignments exist, use them\n  if (line.alignments && line.alignments.length > 0) {\n    line.alignments.forEach((mapping) => {\n      const fromIndex = mapping[fromSide];\n      const toIndex = mapping[toSide];\n      if (fromIndex !== undefined && toIndex !== undefined) {\n        alignment.set(fromIndex, toIndex);\n      }\n    });\n    return alignment;\n  }\n\n  // Otherwise use heuristic alignment\n  // Simple case: if token counts are close, use index alignment\n  const ratio = fromTokens.length / toTokens.length;\n\n  if (ratio > 0.8 && ratio < 1.2) {\n    // Close enough, use index alignment\n    const minLength = Math.min(fromTokens.length, toTokens.length);\n    for (let i = 0; i < minLength; i++) {\n      alignment.set(i, i);\n    }\n  } else {\n    // More complex alignment - distribute evenly\n    for (let i = 0; i < fromTokens.length; i++) {\n      const targetIndex = Math.floor((i / fromTokens.length) * toTokens.length);\n      alignment.set(i, Math.min(targetIndex, toTokens.length - 1));\n    }\n  }\n\n  return alignment;\n};\n\n// Normalize text for matching (used in answer checking)\nexport const normalizeText = (text: string, options?: {\n  caseSensitive?: boolean;\n  removeSpaces?: boolean;\n  removePunctuation?: boolean;\n}): string => {\n  let normalized = text;\n\n  const opts = {\n    caseSensitive: false,\n    removeSpaces: false,\n    removePunctuation: true,\n    ...options\n  };\n\n  if (!opts.caseSensitive) {\n    normalized = normalized.toLowerCase();\n  }\n\n  if (opts.removePunctuation) {\n    normalized = normalized.replace(/[.,!?;:'\"]/g, '');\n  }\n\n  if (opts.removeSpaces) {\n    normalized = normalized.replace(/\\s+/g, '');\n  } else {\n    // Collapse multiple spaces to single space\n    normalized = normalized.replace(/\\s+/g, ' ').trim();\n  }\n\n  return normalized;\n};\n\n// Calculate edit distance for fuzzy matching\nexport const calculateEditDistance = (str1: string, str2: string): number => {\n  const m = str1.length;\n  const n = str2.length;\n\n  if (m === 0) return n;\n  if (n === 0) return m;\n\n  const dp: number[][] = Array(m + 1)\n    .fill(null)\n    .map(() => Array(n + 1).fill(0));\n\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1, // deletion\n          dp[i][j - 1] + 1, // insertion\n          dp[i - 1][j - 1] + 1 // substitution\n        );\n      }\n    }\n  }\n\n  return dp[m][n];\n};\n\n// Normalize pinyin by removing tone marks and converting to lowercase\nexport const normalizePinyin = (pinyin: string): string => {\n  return pinyin\n    .toLowerCase()\n    .replace(/[āáǎà]/g, 'a')\n    .replace(/[ēéěè]/g, 'e')\n    .replace(/[īíǐì]/g, 'i')\n    .replace(/[ōóǒò]/g, 'o')\n    .replace(/[ūúǔù]/g, 'u')\n    .replace(/[ǖǘǚǜü]/g, 'v') // ü becomes v (common pinyin input method)\n    .replace(/[ńňǹ]/g, 'n')\n    .replace(/[ḿ]/g, 'm')\n    .trim();\n};\n\n// Check if pinyin answer is close enough (handles tone mark variations)\nexport const isPinyinAnswerClose = (\n  userAnswer: string,\n  correctAnswer: string,\n  maxEditDistance: number = 1\n): boolean => {\n  // Normalize both answers to remove tone marks\n  const normalizedUser = normalizePinyin(userAnswer);\n  const normalizedCorrect = normalizePinyin(correctAnswer);\n\n  // Exact match after normalization\n  if (normalizedUser === normalizedCorrect) return true;\n\n  // Allow slight variations (typos, missing spaces, etc.)\n  const distance = calculateEditDistance(normalizedUser, normalizedCorrect);\n  const maxDistance = Math.min(maxEditDistance, Math.floor(normalizedCorrect.length * 0.15));\n\n  return distance <= maxDistance;\n};\n\n// Check if answer is close enough (for fuzzy matching)\nexport const isAnswerClose = (\n  userAnswer: string,\n  correctAnswer: string,\n  maxEditDistance: number = 2,\n  answerType: 'text' | 'pinyin' = 'text'\n): boolean => {\n  // Use specialized pinyin matching for pinyin answers\n  if (answerType === 'pinyin') {\n    return isPinyinAnswerClose(userAnswer, correctAnswer, maxEditDistance);\n  }\n\n  // Standard text matching\n  const normalizedUser = normalizeText(userAnswer);\n  const normalizedCorrect = normalizeText(correctAnswer);\n\n  if (normalizedUser === normalizedCorrect) return true;\n\n  const distance = calculateEditDistance(normalizedUser, normalizedCorrect);\n  const maxDistance = Math.min(maxEditDistance, Math.floor(normalizedCorrect.length * 0.2));\n\n  return distance <= maxDistance;\n};","import { FC, useState, useCallback, useEffect, useRef } from 'react';\nimport { ReadModeSettings } from '@/types';\nimport { isAnswerClose } from '@/utils/tokenize';\nimport { Button } from '@/components/ui/Button';\nimport styles from './ReadToken.module.css';\n\ninterface Token {\n  text: string;\n  start: number;\n  end: number;\n}\n\ninterface Props {\n  token: Token;\n  index: number;\n  isActive: boolean;\n  isCompleted: boolean;\n  onClick: () => void;\n  onClose?: () => void; // New prop to deactivate token\n  onComplete?: () => void;\n  settings: ReadModeSettings;\n  sourceText: string;\n  targetText: string;\n  pinyinText?: string;\n  translationText?: string;\n}\n\nexport const ReadToken: FC<Props> = ({\n  isActive,\n  isCompleted,\n  onClick,\n  onClose,\n  onComplete,\n  settings,\n  sourceText,\n  targetText,\n  pinyinText,\n  translationText\n}) => {\n  const [userAnswer, setUserAnswer] = useState('');\n  const [showAnswer, setShowAnswer] = useState(false);\n  const [isCorrect, setIsCorrect] = useState<boolean | null>(null);\n  const [mcOptions, setMcOptions] = useState<string[]>([]);\n  const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });\n  const tokenRef = useRef<HTMLDivElement>(null);\n\n  // Check if a string is punctuation or special character\n  const isPunctuation = (text: string) => {\n    return /^[.,!?;:()\\[\\]{}\"'`~@#$%^&*+=\\-\\/\\\\|<>]+$/.test(text);\n  };\n\n  // Check if tokens should be skipped for practice\n  const shouldSkipToken = (source: string, target: string) => {\n    // Skip if both source and target are punctuation\n    if (isPunctuation(source) && isPunctuation(target)) return true;\n    // Skip if target is empty or whitespace only\n    if (!target || !target.trim()) return true;\n    return false;\n  };\n\n  // Generate multiple choice options if needed\n  useEffect(() => {\n    if (settings.answerType === 'multiple_choice' && isActive && targetText) {\n      // Skip MC for punctuation/special cases\n      if (shouldSkipToken(sourceText, targetText)) {\n        // Auto-advance for punctuation\n        if (onComplete) {\n          setTimeout(() => onComplete(), 500);\n        }\n        return;\n      }\n\n      // Generate distractors based on the target text\n      const options = [targetText];\n\n      // Generate appropriate distractors based on target language/side\n      let distractorPool: string[] = [];\n      const targetSide = settings.translationDirection.to;\n\n      // Check if target is a number (language agnostic)\n      if (/^\\d+$/.test(targetText)) {\n        // For numbers, use other numbers as distractors\n        const num = parseInt(targetText);\n        distractorPool = [\n          (num - 1).toString(),\n          (num + 1).toString(),\n          (num * 2).toString(),\n          (num + 10).toString(),\n          Math.floor(num / 2).toString()\n        ].filter(n => n !== targetText && parseInt(n) >= 0);\n      }\n      // Generate distractors based on target language/side\n      else if (targetSide === 'b') {\n        // Pinyin distractors - common pinyin syllables\n        const pinyinSyllables = [\n          'ma', 'wo', 'ni', 'ta', 'de', 'shi', 'zai', 'you', 'ge', 'le',\n          'dao', 'shang', 'xia', 'lai', 'qu', 'hao', 'hen', 'dou', 'bu', 'mei',\n          'kan', 'shuo', 'zuo', 'chi', 'he', 'zou', 'pao', 'fei', 'kai', 'guan',\n          'da', 'xiao', 'gao', 'ai', 'pang', 'shou', 'kuai', 'man', 'xin', 'jiu',\n          'duo', 'shao', 'chang', 'duan', 'yuan', 'jin', 'li', 'wai', 'zhong', 'bian',\n          'qian', 'hou', 'zuo', 'you', 'dong', 'xi', 'nan', 'bei', 'bai', 'hei',\n          'hong', 'lu', 'huang', 'lan', 'zi', 'fen', 'hui', 'zong', 'cheng', 'qing'\n        ];\n        // Add tone mark variations for more realistic distractors\n        const extendedPinyin = [...pinyinSyllables];\n        pinyinSyllables.forEach(syllable => {\n          if (syllable.includes('a')) {\n            extendedPinyin.push(syllable.replace('a', 'ā'), syllable.replace('a', 'á'), syllable.replace('a', 'ǎ'), syllable.replace('a', 'à'));\n          }\n          if (syllable.includes('e')) {\n            extendedPinyin.push(syllable.replace('e', 'ē'), syllable.replace('e', 'é'), syllable.replace('e', 'ě'), syllable.replace('e', 'è'));\n          }\n          if (syllable.includes('i')) {\n            extendedPinyin.push(syllable.replace('i', 'ī'), syllable.replace('i', 'í'), syllable.replace('i', 'ǐ'), syllable.replace('i', 'ì'));\n          }\n          if (syllable.includes('o')) {\n            extendedPinyin.push(syllable.replace('o', 'ō'), syllable.replace('o', 'ó'), syllable.replace('o', 'ǒ'), syllable.replace('o', 'ò'));\n          }\n          if (syllable.includes('u')) {\n            extendedPinyin.push(syllable.replace('u', 'ū'), syllable.replace('u', 'ú'), syllable.replace('u', 'ǔ'), syllable.replace('u', 'ù'));\n          }\n        });\n        distractorPool = extendedPinyin;\n      }\n      else if (targetSide === 'a') {\n        // Chinese character distractors - common characters\n        distractorPool = [\n          '我', '你', '他', '她', '的', '是', '在', '有', '个', '了',\n          '到', '上', '下', '来', '去', '好', '很', '都', '不', '没',\n          '看', '说', '做', '吃', '喝', '走', '跑', '飞', '开', '关',\n          '大', '小', '高', '矮', '胖', '瘦', '快', '慢', '新', '旧',\n          '多', '少', '长', '短', '远', '近', '里', '外', '中', '边',\n          '前', '后', '左', '右', '东', '西', '南', '北', '白', '黑',\n          '红', '绿', '黄', '蓝', '紫', '粉', '灰', '棕', '橙', '青'\n        ];\n      }\n      else {\n        // English distractors (side c or other)\n        // Check if target is very short (1-2 chars)\n        if (targetText.length <= 2) {\n          distractorPool = [\n            'a', 'I', 'it', 'is', 'to', 'be', 'of', 'in', 'on', 'at',\n            'or', 'an', 'as', 'by', 'we', 'he', 'me', 'my', 'up', 'so'\n          ];\n        } else {\n          // Group words by part of speech/meaning for better distractors\n          const pronouns = ['I', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them'];\n          const verbs = ['is', 'are', 'was', 'were', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'can', 'could', 'would', 'should', 'make', 'take', 'give', 'get', 'go', 'come', 'see', 'know', 'think', 'want'];\n          const adjectives = ['good', 'bad', 'big', 'small', 'new', 'old', 'happy', 'sad', 'fast', 'slow', 'hot', 'cold', 'easy', 'hard', 'beautiful', 'ugly'];\n          const articles = ['the', 'a', 'an', 'this', 'that', 'these', 'those'];\n          const prepositions = ['in', 'on', 'at', 'to', 'for', 'with', 'from', 'by', 'about', 'into', 'through', 'during', 'before', 'after'];\n          const adverbs = ['very', 'really', 'quite', 'too', 'so', 'just', 'still', 'already', 'yet', 'even', 'only', 'also', 'never', 'always', 'sometimes'];\n\n          // Try to match the target word type and select from appropriate pool\n          if (pronouns.includes(targetText.toLowerCase())) {\n            distractorPool = pronouns;\n          } else if (verbs.includes(targetText.toLowerCase())) {\n            distractorPool = verbs;\n          } else if (adjectives.includes(targetText.toLowerCase())) {\n            distractorPool = adjectives;\n          } else if (articles.includes(targetText.toLowerCase())) {\n            distractorPool = articles;\n          } else if (prepositions.includes(targetText.toLowerCase())) {\n            distractorPool = prepositions;\n          } else if (adverbs.includes(targetText.toLowerCase())) {\n            distractorPool = adverbs;\n          } else {\n            // Default mixed pool for unknown words\n            distractorPool = [...verbs.slice(0, 5), ...adjectives.slice(0, 5), ...pronouns.slice(0, 5)];\n          }\n        }\n      }\n\n      // Filter out the correct answer and select random distractors\n      const availableDisractors = distractorPool.filter(d =>\n        d.toLowerCase() !== targetText.toLowerCase()\n      );\n\n      while (options.length < (settings.optionsCount || 4) && availableDisractors.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availableDisractors.length);\n        const distractor = availableDisractors[randomIndex];\n        if (!options.includes(distractor)) {\n          options.push(distractor);\n          availableDisractors.splice(randomIndex, 1);\n        }\n      }\n\n      // If we still need more options, add language-appropriate fallbacks\n      while (options.length < (settings.optionsCount || 4)) {\n        let fallbackOptions: string[];\n        if (targetSide === 'b') {\n          // Pinyin fallbacks\n          fallbackOptions = ['shénme', 'nǎlǐ', 'zěnme', 'shéi'];\n        } else if (targetSide === 'a') {\n          // Chinese character fallbacks\n          fallbackOptions = ['什么', '哪里', '怎么', '谁'];\n        } else {\n          // English fallbacks\n          fallbackOptions = ['something', 'nothing', 'anything', 'everything'];\n        }\n        const fallback = fallbackOptions[options.length - 1] || `option${options.length}`;\n        if (!options.includes(fallback)) {\n          options.push(fallback);\n        }\n      }\n\n      // Shuffle options\n      setMcOptions(options.sort(() => Math.random() - 0.5));\n    }\n  }, [isActive, settings, targetText, sourceText, onClick]);\n\n  // Calculate popup position when token becomes active\n  useEffect(() => {\n    if (isActive && tokenRef.current) {\n      const rect = tokenRef.current.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n\n      // Calculate position that keeps popup in viewport\n      let top = rect.bottom + 10;\n      let left = rect.left + (rect.width / 2);\n\n      // Check if popup would go off bottom of screen\n      if (top + 300 > viewportHeight) {\n        top = rect.top - 310; // Show above instead\n      }\n\n      // Ensure horizontal position stays in viewport\n      const popupWidth = 250;\n      if (left - (popupWidth / 2) < 10) {\n        left = popupWidth / 2 + 10;\n      } else if (left + (popupWidth / 2) > viewportWidth - 10) {\n        left = viewportWidth - (popupWidth / 2) - 10;\n      }\n\n      setPopupPosition({ top, left });\n    }\n  }, [isActive]);\n\n  // Handle answer submission\n  const handleSubmit = useCallback((answer: string) => {\n\n    if (settings.checkMode === 'live') {\n      // Live checking - check immediately\n      // Use pinyin-aware matching if target is pinyin (side b)\n      const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n      const correct = isAnswerClose(answer, targetText, 2, answerType);\n      setIsCorrect(correct);\n      setShowAnswer(true);\n\n      // Don't auto-advance - let user manually advance\n    } else {\n      // Wait mode - just store answer\n      setUserAnswer(answer);\n    }\n  }, [settings, targetText, sourceText]);\n\n  // Handle reveal\n  const handleReveal = useCallback(() => {\n    if (userAnswer) {\n      // Use pinyin-aware matching if target is pinyin (side b)\n      const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n      const correct = isAnswerClose(userAnswer, targetText, 2, answerType);\n      setIsCorrect(correct);\n      setShowAnswer(true);\n\n      // Auto-advance to next token after a short delay\n      if (correct && onComplete) {\n        setTimeout(() => {\n          onComplete(); // Move to next token\n        }, 1000);\n      }\n    } else {\n      setShowAnswer(true);\n    }\n  }, [userAnswer, targetText, settings, onComplete]);\n\n  // Handle multiple choice selection\n  const handleMCSelect = useCallback((option: string) => {\n    // Use pinyin-aware matching if target is pinyin (side b)\n    const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n    const correct = isAnswerClose(option, targetText, 2, answerType);\n    setIsCorrect(correct);\n    setShowAnswer(true);\n    setUserAnswer(option);\n\n    // Auto-advance to next token after a short delay\n    if (correct && onComplete) {\n      setTimeout(() => {\n        onComplete(); // Move to next token\n      }, 1000);\n    }\n  }, [targetText, settings, onComplete]);\n\n  return (\n    <div\n      ref={tokenRef}\n      className={`\n        ${styles.token}\n        ${isActive ? styles.active : ''}\n        ${isCompleted ? styles.completed : ''}\n        ${isCorrect === true ? styles.correct : ''}\n        ${isCorrect === false ? styles.incorrect : ''}\n      `}\n      onClick={onClick}\n    >\n      <span className={styles.tokenText}>{sourceText}</span>\n\n      {/* Show interaction UI when active - skip for punctuation */}\n      {isActive && !showAnswer && !shouldSkipToken(sourceText, targetText) && (\n        <div\n          className={styles.interactionArea}\n          style={{\n            position: 'fixed',\n            top: `${popupPosition.top}px`,\n            left: `${popupPosition.left}px`,\n            transform: 'translateX(-50%)'\n          }}\n        >\n          {/* Close button to dismiss popup */}\n          <button\n            className={styles.closeButton}\n            onClick={(e) => {\n              e.stopPropagation();\n              if (onClose) {\n                onClose(); // Deactivate this token\n              }\n            }}\n            aria-label=\"Close input\"\n            title=\"Close (to see translations below)\"\n          >\n            ✕\n          </button>\n\n          {settings.answerType === 'free_text' ? (\n            <div className={styles.freeTextInput}>\n              <input\n                type=\"text\"\n                value={userAnswer}\n                onChange={(e) => setUserAnswer(e.target.value)}\n                onKeyPress={(e) => {\n                  if (e.key === 'Enter') {\n                    if (settings.checkMode === 'live') {\n                      handleSubmit(userAnswer);\n                    } else {\n                      handleReveal();\n                    }\n                  }\n                }}\n                placeholder=\"Type translation...\"\n                className={styles.textInput}\n                autoFocus\n              />\n              {settings.checkMode === 'wait' && (\n                <Button\n                  size=\"small\"\n                  variant=\"primary\"\n                  onClick={handleReveal}\n                  disabled={!userAnswer}\n                >\n                  Check\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className={styles.multipleChoice}>\n              {mcOptions.map((option, idx) => (\n                <Button\n                  key={idx}\n                  size=\"small\"\n                  variant=\"secondary\"\n                  onClick={() => handleMCSelect(option)}\n                  className={styles.mcOption}\n                >\n                  {option}\n                </Button>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Show answer when revealed */}\n      {showAnswer && (\n        <div className={styles.answerDisplay}>\n          <span className={styles.correctAnswer}>{targetText}</span>\n          {isCorrect !== null && (\n            <span className={isCorrect ? styles.feedbackCorrect : styles.feedbackIncorrect}>\n              {isCorrect ? '✓' : '✗'}\n            </span>\n          )}\n        </div>\n      )}\n\n      {/* Show hints if enabled */}\n      {pinyinText && !isActive && (\n        <span className={styles.pinyinHint}>{pinyinText}</span>\n      )}\n      {translationText && !isActive && (\n        <span className={styles.translationHint}>{translationText}</span>\n      )}\n    </div>\n  );\n};","import { FC, useMemo, useCallback } from 'react';\nimport { Deck, ReadingLine, ReadModeSettings } from '@/types';\nimport {\n  hasWordAlignments,\n  createInteractiveTokens\n} from '@/utils/wordAlignments';\nimport { tokenizeLine } from '@/utils/tokenize';\nimport { ReadToken } from './ReadToken';\nimport styles from './AlignedReadLine.module.css';\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface Props {\n  line: ReadingLine;\n  deck: Deck;\n  session: ReadSessionState;\n  settings: ReadModeSettings;\n  onTokenClick: (tokenIndex: number) => void;\n  onTokenComplete: () => void;\n}\n\nexport const AlignedReadLine: FC<Props> = ({\n  line,\n  deck,\n  session,\n  settings,\n  onTokenClick,\n  onTokenComplete\n}) => {\n  // Check if we have word alignments for this line\n  const hasAlignments = useMemo(() => hasWordAlignments(line), [line]);\n\n  // Get aligned tokens if available\n  const alignedTokens = useMemo(() => {\n    if (hasAlignments) {\n      return createInteractiveTokens(line);\n    }\n    return [];\n  }, [line, hasAlignments]);\n\n\n\n  // Fall back to traditional tokenization if no alignments\n  const lineTokens = useMemo(() => {\n    if (hasAlignments) return null; // Don't compute if we have alignments\n\n    const config = deck.reading?.tokenization || {\n      unit: {\n        a: 'character',\n        b: 'space',\n        c: 'space',\n        d: undefined,\n        e: undefined,\n        f: undefined\n      },\n      preservePunctuation: true\n    };\n\n    return tokenizeLine(line, config);\n  }, [line, deck, hasAlignments]);\n\n  // Get tokens for interactive mode - use wordAlignments if available, fallback to traditional\n  const sourceTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format for ReadToken components\n      const tokens = alignedTokens.map((alignedToken, index) => ({\n        text: alignedToken.chinese,\n        start: index,\n        end: index + 1\n      }));\n      return tokens;\n    }\n\n    if (!lineTokens) return [];\n    const sourceSide = settings.translationDirection.from;\n    return lineTokens[sourceSide] || [];\n  }, [hasAlignments, alignedTokens, lineTokens, settings]);\n\n  const targetTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format\n      const targetSide = settings.translationDirection.to;\n      return alignedTokens.map((alignedToken, index) => ({\n        text: targetSide === 'b' ? alignedToken.pinyin : alignedToken.english,\n        start: index,\n        end: index + 1\n      }));\n    }\n\n    if (!lineTokens) return [];\n    const targetSide = settings.translationDirection.to;\n    return lineTokens[targetSide] || [];\n  }, [hasAlignments, alignedTokens, lineTokens, settings]);\n\n  const pinyinTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format for pinyin\n      return alignedTokens.map((alignedToken, index) => ({\n        text: alignedToken.pinyin,\n        start: index,\n        end: index + 1\n      }));\n    }\n\n    if (!lineTokens) return [];\n    return lineTokens['b'] || [];\n  }, [hasAlignments, alignedTokens, lineTokens]);\n\n\n  // Traditional token click handler\n  const handleTokenClick = useCallback((tokenIndex: number) => {\n    onTokenClick(tokenIndex);\n  }, [onTokenClick]);\n\n  // Traditional token completion handler\n  const handleTokenComplete = useCallback(() => {\n    onTokenComplete();\n  }, [onTokenComplete]);\n\n  // Get target text for tokens (now supports wordAlignment-based tokens)\n  const getTargetForSourceToken = useCallback((sourceIndex: number) => {\n    if (!targetTokens.length) return '';\n    const targetToken = targetTokens[sourceIndex];\n    return targetToken?.text || '';\n  }, [targetTokens]);\n\n  // Get pinyin for tokens (now supports wordAlignment-based tokens)\n  const getPinyinForSourceToken = useCallback((sourceIndex: number) => {\n    if (!pinyinTokens.length) return '';\n    const pinyinToken = pinyinTokens[sourceIndex];\n    return pinyinToken?.text || '';\n  }, [pinyinTokens]);\n\n  // Get side labels\n  const getSideLabel = useCallback((sideId: string) => {\n    if (!deck.reading?.sides) {\n      const defaultLabels: Record<string, string> = {\n        a: 'Characters',\n        b: 'Pinyin',\n        c: 'English',\n        d: 'Side D',\n        e: 'Side E',\n        f: 'Side F'\n      };\n      return defaultLabels[sideId] || sideId.toUpperCase();\n    }\n    return deck.reading.sides[sideId as keyof typeof deck.reading.sides] || sideId.toUpperCase();\n  }, [deck]);\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.lineHeader}>\n        <span className={styles.lineNumber}>Line {session.currentLineIndex + 1}</span>\n        <span className={styles.translationDirection}>\n          {getSideLabel(settings.translationDirection.from)} → {getSideLabel(settings.translationDirection.to)}\n        </span>\n        {hasAlignments && (\n          <span className={styles.alignmentBadge}>Word Aligned</span>\n        )}\n      </div>\n\n      <div className={styles.lineContent}>\n        {/* Always use interactive ReadToken components for token-by-token practice */}\n        {/* Now uses wordAlignment-based tokens when available for correct boundaries */}\n        <div className={styles.sourceSide}>\n          <div className={styles.sideLabel}>\n            {getSideLabel(settings.translationDirection.from)}\n            {hasAlignments && (\n              <span className={styles.alignmentBadge}>Word Aligned</span>\n            )}\n          </div>\n          <div className={styles.tokens}>\n            {sourceTokens.map((token, index) => (\n              <ReadToken\n                key={`${session.currentLineIndex}-${index}`}\n                token={token}\n                index={index}\n                isActive={session.currentTokenIndex === index}\n                isCompleted={false}\n                onClick={() => handleTokenClick(index)}\n                onClose={() => handleTokenClick(-1)} // Deactivate by setting to -1\n                onComplete={handleTokenComplete}\n                settings={settings}\n                sourceText={token.text}\n                targetText={getTargetForSourceToken(index)}\n                pinyinText={session.showPinyin ? getPinyinForSourceToken(index) : ''}\n                translationText={session.showTranslation ? getTargetForSourceToken(index) : ''}\n              />\n            ))}\n          </div>\n        </div>\n\n        {/* Show additional sides if enabled and not using word alignments */}\n        {!hasAlignments && session.showPinyin && line.b && (\n          <div className={styles.additionalSide}>\n            <div className={styles.sideLabel}>Pinyin</div>\n            <div className={styles.sideText}>{line.b}</div>\n          </div>\n        )}\n\n        {!hasAlignments && session.showTranslation && (\n          <div className={styles.additionalSide}>\n            <div className={styles.sideLabel}>{getSideLabel(settings.translationDirection.to)}</div>\n            <div className={styles.sideText}>{line[settings.translationDirection.to] || ''}</div>\n          </div>\n        )}\n\n        {/* For aligned content, show full sentences when enabled */}\n        {hasAlignments && (session.showPinyin || session.showTranslation) && (\n          <div className={styles.fullSentences}>\n            {session.showPinyin && line.b && (\n              <div className={styles.fullSentence}>\n                <div className={styles.sideLabel}>Full Pinyin</div>\n                <div className={styles.sideText}>{line.b}</div>\n              </div>\n            )}\n            {session.showTranslation && line.c && (\n              <div className={styles.fullSentence}>\n                <div className={styles.sideLabel}>Full Translation</div>\n                <div className={styles.sideText}>{line.c}</div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};","import { FC, useMemo, useCallback } from 'react';\nimport { Deck, ReadingLine, ReadModeSettings, SentenceTranslationResult } from '@/types';\nimport { SentenceTranslation } from './SentenceTranslation';\nimport { AlignedReadLine } from './AlignedReadLine';\nimport styles from './EnhancedReadLine.module.css';\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface Props {\n  line: ReadingLine;\n  deck: Deck;\n  session: ReadSessionState;\n  settings: ReadModeSettings;\n  allLines: ReadingLine[]; // For MC distractors\n  onAnswer?: (result: SentenceTranslationResult) => void;\n  onTokenClick?: (tokenIndex: number) => void;\n  onTokenComplete?: () => void;\n  onNext?: () => void;\n  showControls?: boolean;\n}\n\nexport const EnhancedReadLine: FC<Props> = ({\n  line,\n  deck,\n  session,\n  settings,\n  allLines,\n  onAnswer,\n  onTokenClick,\n  onTokenComplete,\n  onNext: _onNext // Reserved for potential future auto-advance feature\n  // showControls = true // Reserved for future use\n}) => {\n  // Get side labels\n  const getSideLabel = useCallback((sideId: string) => {\n    if (!deck.reading?.sides) {\n      const defaultLabels: Record<string, string> = {\n        a: 'Characters',\n        b: 'Pinyin',\n        c: 'English',\n        d: 'Side D',\n        e: 'Side E',\n        f: 'Side F'\n      };\n      return defaultLabels[sideId] || sideId.toUpperCase();\n    }\n    return deck.reading.sides[sideId as keyof typeof deck.reading.sides] || sideId.toUpperCase();\n  }, [deck]);\n\n  // Handle sentence translation answer\n  const handleSentenceAnswer = useCallback((result: SentenceTranslationResult) => {\n    if (onAnswer) {\n      onAnswer(result);\n    }\n\n    // Don't auto-advance - let user manually navigate with keyboard or buttons\n  }, [onAnswer]);\n\n  // Render based on translation mode\n  const renderContent = useMemo(() => {\n    if (settings.translationMode === 'sentence') {\n      return (\n        <div className={styles.sentenceMode}>\n          <div className={styles.lineHeader}>\n            <span className={styles.lineNumber}>Line {session.currentLineIndex + 1}</span>\n            <span className={styles.translationDirection}>\n              {getSideLabel(settings.translationDirection.from)} → {getSideLabel(settings.translationDirection.to)}\n            </span>\n          </div>\n\n          <SentenceTranslation\n            line={line}\n            allLines={allLines}\n            settings={settings}\n            onAnswer={handleSentenceAnswer}\n            showResult={true}\n          />\n\n          {/* Show additional content if enabled */}\n          {(session.showPinyin || session.showTranslation) && (\n            <div className={styles.additionalContent}>\n              {session.showPinyin && line.b && (\n                <div className={styles.additionalSide}>\n                  <div className={styles.sideLabel}>Pinyin</div>\n                  <div className={styles.sideText}>{line.b}</div>\n                </div>\n              )}\n              {session.showTranslation && line[settings.translationDirection.to] && (\n                <div className={styles.additionalSide}>\n                  <div className={styles.sideLabel}>{getSideLabel(settings.translationDirection.to)}</div>\n                  <div className={styles.sideText}>{line[settings.translationDirection.to]}</div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      );\n    }\n\n    // Fall back to token-based mode\n    return (\n      <AlignedReadLine\n        line={line}\n        deck={deck}\n        session={session}\n        settings={settings}\n        onTokenClick={onTokenClick || (() => {})}\n        onTokenComplete={onTokenComplete || (() => {})}\n      />\n    );\n  }, [\n    settings.translationMode,\n    line,\n    deck,\n    session,\n    settings,\n    allLines,\n    getSideLabel,\n    handleSentenceAnswer,\n    onTokenClick,\n    onTokenComplete\n  ]);\n\n  return (\n    <div className={styles.container}>\n      {renderContent}\n    </div>\n  );\n};","import { FC } from 'react';\nimport { Button } from '@/components/ui/Button';\nimport styles from './ReadControls.module.css';\n\ninterface Props {\n  canGoPrevious: boolean;\n  canGoNext: boolean;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  onPrevious: () => void;\n  onNext: () => void;\n  onTogglePinyin: () => void;\n  onToggleTranslation: () => void;\n}\n\nexport const ReadControls: FC<Props> = ({\n  canGoPrevious,\n  canGoNext,\n  showPinyin,\n  showTranslation,\n  onPrevious,\n  onNext,\n  onTogglePinyin,\n  onToggleTranslation\n}) => {\n  return (\n    <div className={styles.container}>\n      <div className={styles.navigationControls}>\n        <Button\n          variant=\"secondary\"\n          size=\"medium\"\n          onClick={onPrevious}\n          disabled={!canGoPrevious}\n          className={styles.navButton}\n        >\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <path d=\"M19 12H5M5 12L12 19M5 12L12 5\" />\n          </svg>\n          Previous\n        </Button>\n        <Button\n          variant=\"secondary\"\n          size=\"medium\"\n          onClick={onNext}\n          disabled={!canGoNext}\n          className={styles.navButton}\n        >\n          Next\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <path d=\"M5 12H19M19 12L12 5M19 12L12 19\" />\n          </svg>\n        </Button>\n      </div>\n\n      <div className={styles.toggleControls}>\n        <Button\n          variant={showPinyin ? 'primary' : 'secondary'}\n          size=\"small\"\n          onClick={onTogglePinyin}\n          className={styles.toggleButton}\n        >\n          {showPinyin ? (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\" />\n              <circle cx=\"12\" cy=\"12\" r=\"3\" />\n            </svg>\n          ) : (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24\" />\n              <line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\" />\n            </svg>\n          )}\n          Pinyin (R)\n        </Button>\n        <Button\n          variant={showTranslation ? 'primary' : 'secondary'}\n          size=\"small\"\n          onClick={onToggleTranslation}\n          className={styles.toggleButton}\n        >\n          {showTranslation ? (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\" />\n              <circle cx=\"12\" cy=\"12\" r=\"3\" />\n            </svg>\n          ) : (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24\" />\n              <line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\" />\n            </svg>\n          )}\n          Translation (T)\n        </Button>\n      </div>\n\n      <div className={styles.shortcuts}>\n        <span className={styles.shortcutHint}>\n          Use ↑/↓ or J/K to navigate • R for pinyin • T for translation\n        </span>\n      </div>\n    </div>\n  );\n};","import { FC } from 'react';\nimport styles from './ReadProgress.module.css';\n\ninterface Props {\n  currentLineIndex: number;\n  totalLines: number;\n  correctCount: number;\n  incorrectCount: number;\n}\n\nexport const ReadProgress: FC<Props> = ({\n  currentLineIndex,\n  totalLines,\n  correctCount,\n  incorrectCount\n}) => {\n  const progressPercentage = ((currentLineIndex + 1) / totalLines) * 100;\n  const accuracy = correctCount + incorrectCount > 0\n    ? (correctCount / (correctCount + incorrectCount)) * 100\n    : 0;\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.stats}>\n        <div className={styles.stat}>\n          <span className={styles.statLabel}>Line</span>\n          <span className={styles.statValue}>\n            {currentLineIndex + 1} / {totalLines}\n          </span>\n        </div>\n        {(correctCount > 0 || incorrectCount > 0) && (\n          <>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Correct</span>\n              <span className={`${styles.statValue} ${styles.correct}`}>\n                {correctCount}\n              </span>\n            </div>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Incorrect</span>\n              <span className={`${styles.statValue} ${styles.incorrect}`}>\n                {incorrectCount}\n              </span>\n            </div>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Accuracy</span>\n              <span className={styles.statValue}>\n                {accuracy.toFixed(0)}%\n              </span>\n            </div>\n          </>\n        )}\n      </div>\n      <div className={styles.progressBar}>\n        <div\n          className={styles.progressFill}\n          style={{ width: `${progressPercentage}%` }}\n        />\n      </div>\n    </div>\n  );\n};","import { FC, useEffect, useMemo, useState, useCallback } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useReadStore } from '@/store/readStore';\nimport { SentenceTranslationResult } from '@/types';\nimport { PageHeader } from '@/components/common/PageHeader';\nimport { ReadSidebar } from '@/components/read/ReadSidebar';\nimport { TranscriptModal } from '@/components/read/TranscriptModal';\nimport { EnhancedReadLine } from '@/components/read/EnhancedReadLine';\nimport { ReadControls } from '@/components/read/ReadControls';\nimport { ReadProgress } from '@/components/read/ReadProgress';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport SettingsIcon from '@/components/icons/SettingsIcon';\nimport { Button } from '@/components/ui/Button';\nimport { hasTranscriptsForDeck } from '@/services/transcriptService';\nimport styles from './Read.module.css';\n\nconst Read: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n\n  // Store hooks\n  const { currentDeck, isLoading, error, loadDeck } = useDeckStore();\n  const {\n    session,\n    settings,\n    initSession,\n    setCurrentDialogue,\n    setCurrentLine,\n    setCurrentToken,\n    togglePinyin,\n    toggleTranslation,\n    recordAnswer,\n    getProgress\n  } = useReadStore();\n\n\n  // Local state\n  const [showSettings, setShowSettings] = useState(false);\n  const [selectedDialogueId, setSelectedDialogueId] = useState<string | null>(null);\n  const [hasTranscripts, setHasTranscripts] = useState<boolean | null>(null);\n\n  // Load deck on mount\n  useEffect(() => {\n    if (deckId) {\n      loadDeck(deckId);\n    }\n  }, [deckId, loadDeck]);\n\n  // Check for transcripts availability\n  useEffect(() => {\n    if (deckId) {\n      hasTranscriptsForDeck(deckId).then(setHasTranscripts);\n    }\n  }, [deckId]);\n\n  // Initialize session when deck loads\n  useEffect(() => {\n    if (currentDeck?.reading && deckId) {\n      const dialogueIds = Object.keys(currentDeck.reading.dialogues);\n      if (dialogueIds.length > 0) {\n        // Check for saved progress\n        const savedProgress = getProgress(deckId);\n        const dialogueId = savedProgress?.dialogueId || dialogueIds[0];\n\n        // Always set the selected dialogue (even if session exists)\n        setSelectedDialogueId(dialogueId);\n\n        // Only initialize session if it doesn't exist\n        if (!session) {\n          initSession(deckId, dialogueId);\n        }\n      }\n    }\n  }, [currentDeck, deckId, initSession, getProgress]);\n\n  // Restore progress when session initializes\n  useEffect(() => {\n    if (session && deckId && session.currentLineIndex === 0 && session.currentTokenIndex === 0) {\n      const savedProgress = getProgress(deckId);\n      if (savedProgress && savedProgress.lineIndex > 0) {\n        setCurrentLine(savedProgress.lineIndex);\n        setCurrentToken(savedProgress.tokenIndex);\n      }\n    }\n  }, [session?.currentDialogueId]); // Only run when dialogue changes\n\n  // Get current dialogue and line data\n  const currentDialogue = useMemo(() => {\n    if (!currentDeck?.reading || !selectedDialogueId) return null;\n    return currentDeck.reading.dialogues[selectedDialogueId];\n  }, [currentDeck, selectedDialogueId]);\n\n  const currentLine = useMemo(() => {\n    if (!currentDialogue || !session) return null;\n    return currentDialogue.lines[session.currentLineIndex];\n  }, [currentDialogue, session]);\n\n  // Get all lines for MC generation\n  const allLines = useMemo(() => {\n    if (!currentDialogue) return [];\n    return currentDialogue.lines;\n  }, [currentDialogue]);\n\n  // Handle dialogue selection\n  const handleSelectDialogue = useCallback((dialogueId: string) => {\n    setSelectedDialogueId(dialogueId);\n    setCurrentDialogue(dialogueId);\n    setCurrentLine(0);\n    setCurrentToken(0);\n  }, [setCurrentDialogue, setCurrentLine, setCurrentToken]);\n\n  // Handle navigation\n  const handlePreviousLine = useCallback(() => {\n    if (!session) return;\n\n    if (session.currentLineIndex > 0) {\n      setCurrentLine(session.currentLineIndex - 1);\n      setCurrentToken(0);\n    }\n  }, [session, setCurrentLine, setCurrentToken]);\n\n  const handleNextLine = useCallback(() => {\n    if (!session || !currentDialogue) return;\n\n    if (session.currentLineIndex < currentDialogue.lines.length - 1) {\n      setCurrentLine(session.currentLineIndex + 1);\n      setCurrentToken(0);\n    }\n  }, [session, currentDialogue, setCurrentLine, setCurrentToken]);\n\n  // Handle sentence translation answer\n  const handleSentenceAnswer = useCallback((result: SentenceTranslationResult) => {\n    if (!session) return;\n\n    const responseTime = Date.now() - session.responseStartTime;\n    recordAnswer(result.isCorrect, responseTime);\n\n  }, [session, recordAnswer]);\n\n  // Handle keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      switch (e.key) {\n        case 'ArrowUp':\n        case 'k':\n          e.preventDefault();\n          handlePreviousLine();\n          break;\n        case 'ArrowDown':\n        case 'j':\n          e.preventDefault();\n          handleNextLine();\n          break;\n        case 'r':\n          e.preventDefault();\n          togglePinyin();\n          break;\n        case 't':\n          e.preventDefault();\n          toggleTranslation();\n          break;\n        default:\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handlePreviousLine, handleNextLine, togglePinyin, toggleTranslation]);\n\n  // Handle cleanup\n  useEffect(() => {\n    return () => {\n      // Save progress when leaving\n      if (session && deckId) {\n        // Progress is already saved in the store\n      }\n    };\n  }, [session, deckId]);\n\n  // Loading state - removed LoadingScreen to avoid duplicate with PageLazyBoundary\n  if (isLoading) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  // Error state\n  if (error || !currentDeck) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>Unable to load deck</h2>\n        <p>The deck could not be loaded. Please try again.</p>\n        <button onClick={() => navigate('/')} className={styles.backButton}>\n          Back to Home\n        </button>\n      </div>\n    );\n  }\n\n  // Determine if we have reading content\n  const hasReadingContent = currentDeck.reading && Object.keys(currentDeck.reading.dialogues).length > 0;\n\n  // Wait for transcript check to complete\n  if (hasTranscripts === null) {\n    return null; // Still checking for transcripts\n  }\n\n  // Check if deck has any reading content (structured dialogues OR transcripts)\n  if (!hasReadingContent && !hasTranscripts) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>No reading content available</h2>\n        <p>This deck doesn't have any reading dialogues or transcripts. Please choose a different deck.</p>\n        <button onClick={() => navigate(`/deck/${deckId}`)} className={styles.backButton}>\n          Back to Deck\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.readPage}>\n      <PageHeader\n        title={currentDeck.metadata.deck_name}\n        subtitle=\"Read Mode\"\n        onBackClick={() => navigate(`/deck/${deckId}`)}\n        backLabel=\"Back to Deck\"\n        rightContent={\n          <Button\n            variant=\"secondary\"\n            size=\"small\"\n            onClick={() => setShowSettings(true)}\n            className={styles.settingsButton}\n          >\n            <SettingsIcon size={20} />\n          </Button>\n        }\n      />\n\n      <div className={styles.container}>\n        <div className={styles.leftPanel}>\n          <ReadSidebar\n            deck={currentDeck}\n            selectedDialogueId={selectedDialogueId}\n            onSelectDialogue={handleSelectDialogue}\n            progress={getProgress(deckId || '')}\n          />\n        </div>\n\n        <div className={styles.mainPanel}>\n          {session && currentDialogue && currentLine ? (\n            <>\n              <ReadProgress\n                currentLineIndex={session.currentLineIndex}\n                totalLines={currentDialogue.lines.length}\n                correctCount={session.correctCount}\n                incorrectCount={session.incorrectCount}\n              />\n\n              <EnhancedReadLine\n                line={currentLine}\n                deck={currentDeck}\n                session={session}\n                settings={settings}\n                allLines={allLines}\n                onAnswer={handleSentenceAnswer}\n                onNext={handleNextLine}\n                onTokenClick={(tokenIndex: number) => {\n                  // Set the current token when clicked\n                  setCurrentToken(tokenIndex);\n                }}\n                onTokenComplete={() => {\n                  // Advance to next token when current one is completed\n                  if (!session || !currentDialogue) return;\n\n                  const nextTokenIndex = session.currentTokenIndex + 1;\n                  const currentLine = currentDialogue.lines[session.currentLineIndex];\n\n                  // Check if we have wordAlignments to determine max tokens\n                  const maxTokens = currentLine.wordAlignments ?\n                    currentLine.wordAlignments.length :\n                    (currentLine.a?.length || 0);\n\n\n                  if (nextTokenIndex < maxTokens) {\n                    // Move to next token in same line\n                    setCurrentToken(nextTokenIndex);\n                  } else {\n                    // Move to next line if available\n                    if (session.currentLineIndex < currentDialogue.lines.length - 1) {\n                      handleNextLine();\n                    }\n                  }\n                }}\n              />\n\n              {settings.translationMode === 'token' && (\n                <ReadControls\n                  canGoPrevious={session.currentLineIndex > 0}\n                  canGoNext={session.currentLineIndex < currentDialogue.lines.length - 1}\n                  showPinyin={session.showPinyin}\n                  showTranslation={session.showTranslation}\n                  onPrevious={handlePreviousLine}\n                  onNext={handleNextLine}\n                  onTogglePinyin={togglePinyin}\n                  onToggleTranslation={toggleTranslation}\n                />\n              )}\n\n              {settings.translationMode === 'sentence' && (\n                <div className={styles.sentenceControls}>\n                  <button\n                    onClick={handlePreviousLine}\n                    disabled={session.currentLineIndex === 0}\n                    className={styles.navButton}\n                  >\n                    ← Previous Sentence\n                  </button>\n                  <button\n                    onClick={handleNextLine}\n                    disabled={session.currentLineIndex >= currentDialogue.lines.length - 1}\n                    className={styles.navButton}\n                  >\n                    Next Sentence →\n                  </button>\n                </div>\n              )}\n            </>\n          ) : hasTranscripts && !hasReadingContent ? (\n            <div className={styles.transcriptOnlyMessage}>\n              <h3>Transcript Reader</h3>\n              <p>This deck has transcripts available for external TTS readers.</p>\n              <p>Select a transcript from the sidebar to view and copy.</p>\n            </div>\n          ) : null}\n        </div>\n      </div>\n\n      {showSettings && (\n        <UnifiedSettings\n          visible={showSettings}\n          onClose={() => setShowSettings(false)}\n          mode=\"read\"\n          deck={currentDeck}\n          settings={settings}\n          onUpdateSettings={(newSettings) => {\n            useReadStore.getState().updateSettings(newSettings as any);\n          }}\n        />\n      )}\n\n      <TranscriptModal />\n    </div>\n  );\n};\n\nexport default Read;"],"names":["defaultSettings","answerType","checkMode","translationDirection","from","to","optionsCount","showPinyinDefault","multipleChoiceDifficulty","unit","translationMode","accuracyThreshold","showWordHints","useReadStore","create","persist","set","get","progress","session","settings","initSession","deckId","dialogueId","state","currentDialogueId","currentLineIndex","currentTokenIndex","showPinyin","showTranslation","correctCount","incorrectCount","startTime","Date","now","responseStartTime","responseTimes","setCurrentDialogue","currentProgress","lineIndex","tokenIndex","completedTokens","Set","masteredTokens","setCurrentLine","setCurrentToken","markTokenComplete","tokenKey","newCompletedTokens","add","markTokenMastered","newMasteredTokens","togglePinyin","toggleTranslation","updateSettings","recordAnswer","correct","responseTime","clearSession","resetProgress","newProgress","getProgress","name","version","partialize","migrate","persistedState","currentFrom","currentTo","ReadDialoguePicker","deck","selectedDialogueId","onSelectDialogue","dialogueProgress","useMemo","reading","result","Object","entries","dialogues","forEach","dialogue","totalTokens","lines","reduce","acc","line","tokenCount","a","b","c","Array","filter","key","startsWith","length","completed","total","dialogueEntries","jsxs","className","styles","children","jsx","map","isSelected","dialogueStats","progressPercentage","displayName","replace","l","toUpperCase","Button","variant","onClick","width","height","viewBox","fill","stroke","strokeWidth","d","style","initialState","availableTranscripts","selectedTranscript","transcriptContent","isLoading","isLoadingContent","error","isModalOpen","useTranscriptStore","loadTranscriptsForDeck","async","transcripts","getTranscriptsForDeck","Error","message","selectTranscript","transcript","content","loadTranscriptContent","filename","closeModal","clearError","reset","TranscriptPicker","useEffect","strokeLinecap","strokeLinejoin","points","x1","y1","x2","y2","id","ReadSidebar","hasDialogues","keys","CopyIcon","size","color","xmlns","x","y","rx","ry","TranscriptModal","copySuccess","setCopySuccess","useState","isPlaying","setIsPlaying","playbackRate","setPlaybackRate","currentTime","setCurrentTime","duration","setDuration","audioRef","useRef","audioFile","audioUrl","current","pause","audio","handleEnded","handleTimeUpdate","handleLoadedMetadata","addEventListener","removeEventListener","handlePlayPause","useCallback","play","handleSkipBack","Math","max","handleSkipForward","min","handleRestart","handleSeek","e","newTime","Number","target","value","formatTime","time","floor","toString","padStart","handleSpeedDecrease","prev","handleSpeedIncrease","handleCopy","navigator","clipboard","writeText","setTimeout","err","textArea","document","createElement","position","left","body","appendChild","select","execCommand","removeChild","fallbackErr","modalTitle","Modal","isOpen","onClose","title","Fragment","ref","src","preload","type","onChange","disabled","RestartIcon","SkipBackIcon","PauseIcon","PlayIcon","SkipForwardIcon","step","calculateSimilarity","str1","str2","normalizedStr1","normalizeText","normalizedStr2","maxLength","distance","matrix","i","j","indicator","levenshteinDistance","text","toLowerCase","trim","extractWords","split","word","checkSentenceTranslation","userAnswer","targetSide","alternatives","mainText","push","wordAlignments","words","alignment","english","join","generateAlternativeAnswers","correctAnswer","accuracy","isCorrect","suggestions","bestAccuracy","bestCorrectAnswer","alternative","wordMatches","userWords","correctWords","matchedCorrectWords","userWord","bestMatch","bestSimilarity","correctWord","has","similarity","matched","calculateWordMatches","round","slice","extractAlignedTokens","index","chinese","pinyin","hasWordAlignments","Boolean","SentenceTranslation","allLines","onAnswer","onSkip","showResult","setUserAnswer","selectedOption","setSelectedOption","setResult","sourceText","mcOptions","difficulty","options","usedAnswers","potentialDistractors","side","otherLine","shuffledDistractors","sort","random","generateSentenceMultipleChoice","hasAlignments","alignedTokens","handleSubmit","translationResult","handleOptionSelect","option","handleTextChange","handleKeyPress","shiftKey","preventDefault","tappedTokenIndex","setTappedTokenIndex","containerRef","handleOutsideClick","contains","getTokenDisplay","token","getTokenHint","parts","tokenHasHint","handleTokenTap","canSubmit","hint","hasHint","isRevealed","onKeyPress","placeholder","rows","fromCharCode","match","suggestion","DEFAULT_TOKENIZATION","f","preservePunctuation","isCJKCharacter","char","code","charCodeAt","tokenizeByCharacter","tokens","test","start","end","tokenizeByWord","currentWord","wordStart","wordText","tokenizeBySpace","tokenizeSmart","totalChars","cjkChars","tokenizeWithWordAlignments","chinesePos","pinyinPos","englishPos","normalized","opts","caseSensitive","removeSpaces","removePunctuation","calculateEditDistance","m","n","dp","normalizePinyin","isAnswerClose","maxEditDistance","normalizedUser","normalizedCorrect","isPinyinAnswerClose","ReadToken","isActive","isCompleted","onComplete","targetText","pinyinText","translationText","showAnswer","setShowAnswer","setIsCorrect","setMcOptions","popupPosition","setPopupPosition","top","tokenRef","isPunctuation","shouldSkipToken","source","distractorPool","num","parseInt","pinyinSyllables","extendedPinyin","syllable","includes","pronouns","verbs","adjectives","articles","prepositions","adverbs","availableDisractors","randomIndex","distractor","splice","fallbackOptions","fallback","rect","getBoundingClientRect","viewportHeight","window","innerHeight","viewportWidth","innerWidth","bottom","popupWidth","answer","handleReveal","handleMCSelect","transform","stopPropagation","autoFocus","idx","AlignedReadLine","onTokenClick","onTokenComplete","createInteractiveTokens","lineTokens","config","tokenization","tokenConfig","sideIds","tokenizeLine","sourceTokens","alignedToken","sourceSide","targetTokens","pinyinTokens","handleTokenClick","handleTokenComplete","getTargetForSourceToken","sourceIndex","targetToken","getPinyinForSourceToken","pinyinToken","getSideLabel","sideId","sides","EnhancedReadLine","onNext","_onNext","handleSentenceAnswer","renderContent","ReadControls","canGoPrevious","canGoNext","onPrevious","onTogglePinyin","onToggleTranslation","cx","cy","r","ReadProgress","totalLines","toFixed","Read","useParams","navigate","useNavigate","currentDeck","loadDeck","useDeckStore","showSettings","setShowSettings","setSelectedDialogueId","hasTranscripts","setHasTranscripts","hasTranscriptsForDeck","then","dialogueIds","savedProgress","currentDialogue","currentLine","handleSelectDialogue","handlePreviousLine","handleNextLine","handleKeyDown","tagName","isContentEditable","hasReadingContent","PageHeader","metadata","deck_name","subtitle","onBackClick","backLabel","rightContent","SettingsIcon","nextTokenIndex","UnifiedSettings","visible","mode","onUpdateSettings","newSettings","getState"],"mappings":"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"}