{"version":3,"file":"Flashcards-B2whPQM3.js","sources":["../../src/store/flashcardSessionStore.ts","../../src/components/modals/FlashcardsCompletionModal.tsx","../../src/pages/Flashcards.tsx"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport interface FlashcardSession {\n  deckId: string;\n  currentCardIndex: number;\n  progress: { [key: number]: 'correct' | 'incorrect' | null };\n  frontSides: string[];\n  backSides: string[];\n  lastAccessed: number;\n  roundNumber: number;\n  cardOrder: number[]; // Current order of cards (for shuffling missed cards)\n  startTime: number;\n  isMissedCardsRound: boolean; // True if current round is missed cards only\n  progressionMode?: 'sequential' | 'shuffle' | 'level'; // Card progression mode\n  includeMastered?: boolean; // Whether to include mastered cards in the session\n}\n\ninterface FlashcardSessionStore {\n  sessions: Map<string, FlashcardSession>;\n\n  getSession: (deckId: string) => FlashcardSession | undefined;\n  saveSession: (session: FlashcardSession) => void;\n  clearSession: (deckId: string) => void;\n  clearOldSessions: () => void;\n  startNewRound: (deckId: string, totalCards: number) => FlashcardSession;\n  startMissedCardsRound: (deckId: string, missedCardIndices: number[]) => FlashcardSession;\n  getMissedCardIndices: (session: FlashcardSession) => number[];\n}\n\nexport const DEFAULT_FRONT_SIDES = ['side_a'];\nexport const DEFAULT_BACK_SIDES = ['side_b'];\nconst SESSION_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport const useFlashcardSessionStore = create<FlashcardSessionStore>()(\n  persist(\n    (set, get) => ({\n      sessions: new Map(),\n\n      getSession: (deckId: string) => {\n        const sessions = get().sessions;\n        const session = sessions.get(deckId);\n\n        if (session) {\n          // Check if session is expired\n          if (Date.now() - session.lastAccessed > SESSION_EXPIRY_MS) {\n            get().clearSession(deckId);\n            return undefined;\n          }\n          return session;\n        }\n\n        return undefined;\n      },\n\n      saveSession: (session: FlashcardSession) => {\n        set(state => {\n          const newSessions = new Map(state.sessions);\n          newSessions.set(session.deckId, {\n            ...session,\n            lastAccessed: Date.now(),\n          });\n          return { sessions: newSessions };\n        });\n      },\n\n      clearSession: (deckId: string) => {\n        set(state => {\n          const newSessions = new Map(state.sessions);\n          newSessions.delete(deckId);\n          return { sessions: newSessions };\n        });\n      },\n\n      clearOldSessions: () => {\n        set(state => {\n          const newSessions = new Map();\n          const now = Date.now();\n\n          state.sessions.forEach((session, deckId) => {\n            if (now - session.lastAccessed <= SESSION_EXPIRY_MS) {\n              newSessions.set(deckId, session);\n            }\n          });\n\n          return { sessions: newSessions };\n        });\n      },\n\n      startNewRound: (deckId: string, totalCards: number) => {\n        const existingSession = get().getSession(deckId);\n        const newSession: FlashcardSession = {\n          deckId,\n          currentCardIndex: 0,\n          progress: {},\n          frontSides: existingSession?.frontSides || DEFAULT_FRONT_SIDES,\n          backSides: existingSession?.backSides || DEFAULT_BACK_SIDES,\n          lastAccessed: Date.now(),\n          roundNumber: (existingSession?.roundNumber || 0) + 1,\n          cardOrder: Array.from({ length: totalCards }, (_, i) => i),\n          startTime: Date.now(),\n          isMissedCardsRound: false,\n          progressionMode: existingSession?.progressionMode || 'shuffle',\n          includeMastered:\n            existingSession?.includeMastered !== undefined ? existingSession.includeMastered : true,\n        };\n\n        get().saveSession(newSession);\n        return newSession;\n      },\n\n      startMissedCardsRound: (deckId: string, missedCardIndices: number[]) => {\n        const existingSession = get().getSession(deckId);\n\n        // Shuffle the missed cards for variety\n        const shuffled = [...missedCardIndices].sort(() => Math.random() - 0.5);\n\n        const newSession: FlashcardSession = {\n          deckId,\n          currentCardIndex: 0,\n          progress: {},\n          frontSides: existingSession?.frontSides || DEFAULT_FRONT_SIDES,\n          backSides: existingSession?.backSides || DEFAULT_BACK_SIDES,\n          lastAccessed: Date.now(),\n          roundNumber: (existingSession?.roundNumber || 0) + 1,\n          cardOrder: shuffled,\n          startTime: Date.now(),\n          isMissedCardsRound: true,\n          progressionMode: existingSession?.progressionMode || 'shuffle',\n          includeMastered:\n            existingSession?.includeMastered !== undefined ? existingSession.includeMastered : true,\n        };\n\n        get().saveSession(newSession);\n        return newSession;\n      },\n\n      getMissedCardIndices: (session: FlashcardSession) => {\n        const missedIndices: number[] = [];\n\n        if (session.isMissedCardsRound) {\n          // For missed cards round, check progress against the card order\n          session.cardOrder.forEach((originalIndex, currentIndex) => {\n            if (session.progress[currentIndex] === 'incorrect' || !session.progress[currentIndex]) {\n              missedIndices.push(originalIndex);\n            }\n          });\n        } else {\n          // For regular round, check all cards\n          Object.entries(session.progress).forEach(([index, status]) => {\n            if (status === 'incorrect') {\n              missedIndices.push(parseInt(index));\n            }\n          });\n        }\n\n        return missedIndices;\n      },\n    }),\n    {\n      name: 'flashcard-session-store',\n      // Custom storage to handle Map serialization\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          const { state } = JSON.parse(str);\n          return {\n            state: {\n              ...state,\n              sessions: new Map(state.sessions || []),\n            },\n          };\n        },\n        setItem: (name, value) => {\n          const { state } = value;\n          const serialized = {\n            state: {\n              ...state,\n              sessions: Array.from(state.sessions.entries()),\n            },\n          };\n          localStorage.setItem(name, JSON.stringify(serialized));\n        },\n        removeItem: name => localStorage.removeItem(name),\n      },\n    }\n  )\n);\n","import { FC, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport styles from './FlashcardsCompletionModal.module.css';\n\nexport interface FlashcardSessionResults {\n  deckId: string;\n  totalCards: number;\n  correctCards: number;\n  incorrectCards: number;\n  accuracy: number;\n  roundNumber: number;\n  isComplete: boolean;\n  missedCardIndices: number[];\n  startTime: number;\n  endTime: number;\n}\n\ninterface FlashcardsCompletionModalProps {\n  visible: boolean;\n  results: FlashcardSessionResults | null;\n  onContinueWithMissed: () => void;\n  onStartNewRound: () => void;\n  onBackToDeck: () => void;\n  onClose: () => void;\n}\n\nconst FlashcardsCompletionModal: FC<FlashcardsCompletionModalProps> = ({\n  visible,\n  results,\n  onContinueWithMissed,\n  onStartNewRound,\n  onBackToDeck,\n  onClose,\n}) => {\n  const accuracyPercentage = results ? Math.round(results.accuracy) : 0;\n  const duration = results ? results.endTime - results.startTime : 0;\n  const timeInSeconds = Math.round(duration / 1000);\n  const minutes = Math.floor(timeInSeconds / 60);\n  const seconds = timeInSeconds % 60;\n  const hasMissedCards = results ? results.missedCardIndices.length > 0 : false;\n\n  const getPerformanceEmoji = () => {\n    if (accuracyPercentage === 100) return 'üèÜ';\n    if (accuracyPercentage >= 90) return 'üåü';\n    if (accuracyPercentage >= 75) return '‚ú®';\n    if (accuracyPercentage >= 60) return 'üëç';\n    return 'üí™';\n  };\n\n  const getPerformanceMessage = () => {\n    if (accuracyPercentage === 100) return 'Perfect Round!';\n    if (accuracyPercentage >= 90) return 'Outstanding!';\n    if (accuracyPercentage >= 75) return 'Great job!';\n    if (accuracyPercentage >= 60) return 'Good effort!';\n    return 'Keep practicing!';\n  };\n\n  const getRoundMessage = () => {\n    if (!results) return '';\n    if (results.roundNumber === 1) {\n      return hasMissedCards\n        ? `You completed Round ${results.roundNumber} with ${results.incorrectCards} card${results.incorrectCards === 1 ? '' : 's'} to review.`\n        : `You completed Round ${results.roundNumber} perfectly!`;\n    }\n    return hasMissedCards\n      ? `Round ${results.roundNumber} complete! ${results.incorrectCards} card${results.incorrectCards === 1 ? '' : 's'} still need review.`\n      : `Round ${results.roundNumber} complete! All cards mastered!`;\n  };\n\n  // Keyboard shortcuts when modal is visible\n  // If there are missed cards: 1 = Continue with Missed, 2 = Start Full Deck Again, 3 = Back to Deck\n  // If no missed cards: 1 = Start New Round, 3 = Back to Deck\n  useEffect(() => {\n    if (!visible || !results) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea/contentEditable\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      const hasMissed = results.missedCardIndices.length > 0;\n\n      if (e.key === '1') {\n        e.preventDefault();\n        if (hasMissed) {\n          onContinueWithMissed();\n        } else {\n          onStartNewRound();\n        }\n      } else if (e.key === '2' && hasMissed) {\n        e.preventDefault();\n        onStartNewRound();\n      } else if (e.key === '3') {\n        e.preventDefault();\n        onBackToDeck();\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [visible, results, onContinueWithMissed, onStartNewRound, onBackToDeck]);\n\n  if (!results) return null;\n\n  return (\n    <AnimatePresence>\n      {visible && (\n        <>\n          <motion.div\n            className={styles.overlay}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            onClick={onClose}\n          />\n          <motion.div\n            className={styles.modal}\n            initial={{ opacity: 0, scale: 0.9, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.9, y: 20 }}\n            transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n          >\n            {/* Performance Header */}\n            <div className={styles.performanceHeader}>\n              <div className={styles.performanceEmoji}>{getPerformanceEmoji()}</div>\n              <h2 className={styles.performanceMessage}>{getPerformanceMessage()}</h2>\n              <p className={styles.roundMessage}>{getRoundMessage()}</p>\n            </div>\n\n            {/* Main Score */}\n            <div className={styles.mainScore}>\n              <div className={styles.accuracyDisplay}>\n                <span className={styles.accuracyNumber}>{accuracyPercentage}</span>\n                <span className={styles.accuracyPercent}>%</span>\n              </div>\n              <p className={styles.accuracyLabel}>Accuracy</p>\n            </div>\n\n            {/* Stats Grid */}\n            <div className={styles.statsGrid}>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.correctCards}</div>\n                <div className={styles.statLabel}>Correct</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.incorrectCards}</div>\n                <div className={styles.statLabel}>Incorrect</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.totalCards}</div>\n                <div className={styles.statLabel}>Total Cards</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>\n                  {minutes}:{seconds.toString().padStart(2, '0')}\n                </div>\n                <div className={styles.statLabel}>Time</div>\n              </div>\n            </div>\n\n            {/* Round Info */}\n            <div className={styles.roundInfo}>\n              <div className={styles.roundBadge}>Round {results.roundNumber}</div>\n              {hasMissedCards && (\n                <div className={styles.missedCardsInfo}>\n                  {results.incorrectCards} card{results.incorrectCards === 1 ? '' : 's'} to review\n                </div>\n              )}\n            </div>\n\n            {/* Action Buttons */}\n            <div className={styles.actionButtons}>\n              {hasMissedCards ? (\n                <>\n                  <button\n                    onClick={onContinueWithMissed}\n                    className={`${styles.actionButton} ${styles.primaryButton}`}\n                    title=\"Press 1 to continue\"\n                  >\n                    Continue with Missed Cards ({results.incorrectCards})\n                  </button>\n                  <button\n                    onClick={onStartNewRound}\n                    className={`${styles.actionButton} ${styles.secondaryButton}`}\n                    title=\"Press 2 to start again\"\n                  >\n                    Start Full Deck Again\n                  </button>\n                </>\n              ) : (\n                <>\n                  <button\n                    onClick={onStartNewRound}\n                    className={`${styles.actionButton} ${styles.primaryButton}`}\n                    title=\"Press 1 to start new round\"\n                  >\n                    Start New Round\n                  </button>\n                </>\n              )}\n              <button\n                onClick={onBackToDeck}\n                className={`${styles.actionButton} ${styles.tertiaryButton}`}\n                title=\"Press 3 to go back\"\n              >\n                Back to Deck\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n};\n\nexport default FlashcardsCompletionModal;\n","import { FC, useState, useEffect, useCallback, useRef } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { motion, PanInfo, AnimatePresence } from 'framer-motion';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport {\n  useFlashcardSessionStore,\n  DEFAULT_FRONT_SIDES,\n  DEFAULT_BACK_SIDES,\n} from '@/store/flashcardSessionStore';\nimport { useProgressStore } from '@/store/progressStore';\nimport { FlashcardSessionResults } from '@/types';\nimport FlashCard from '@/components/FlashCard';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport { FlashcardsSettings } from '@/types';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport FlashcardsCompletionModal from '@/components/modals/FlashcardsCompletionModal';\nimport { SharedModeHeader } from '@/components/common/SharedModeHeader';\nimport styles from './Flashcards.module.css';\n\nconst Flashcards: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n  const { decks, activeDeck, selectDeck } = useDeckStore();\n  const { getSession, saveSession, startNewRound, startMissedCardsRound, getMissedCardIndices } =\n    useFlashcardSessionStore();\n  const { updateDeckProgress } = useProgressStore();\n  const { updateSettings: updateStoredSettings } = useSettingsStore();\n  const isInitialMount = useRef(true);\n\n  // Initialize state from persisted session or defaults\n  const [currentCardIndex, setCurrentCardIndex] = useState(0);\n  const [isFlipped, setIsFlipped] = useState(false);\n  const [frontSides, setFrontSides] = useState(DEFAULT_FRONT_SIDES);\n  const [backSides, setBackSides] = useState(DEFAULT_BACK_SIDES);\n  const [progress, setProgress] = useState<{ [key: number]: 'correct' | 'incorrect' | null }>({});\n  const [showSettings, setShowSettings] = useState(false);\n  const [swipeDirection, setSwipeDirection] = useState<'left' | 'right' | null>(null);\n  const [roundNumber, setRoundNumber] = useState(1);\n  const [cardOrder, setCardOrder] = useState<number[]>([]);\n  const [startTime, setStartTime] = useState(Date.now());\n  const [isMissedCardsRound, setIsMissedCardsRound] = useState(false);\n  const [showCompletionModal, setShowCompletionModal] = useState(false);\n  const [completionResults, setCompletionResults] = useState<FlashcardSessionResults | null>(null);\n  const [progressionMode, setProgressionMode] = useState<'sequential' | 'shuffle' | 'level'>(\n    'shuffle'\n  );\n  const [includeMastered, setIncludeMastered] = useState(true);\n\n  // Load deck and restore session on mount\n  useEffect(() => {\n    if (deckId) {\n      const deck = decks.find(d => d.id === deckId);\n      if (deck) {\n        selectDeck(deckId);\n\n        // Only restore session on initial mount\n        if (isInitialMount.current) {\n          const session = getSession(deckId);\n          if (session) {\n            setCurrentCardIndex(session.currentCardIndex);\n            setProgress(session.progress);\n            setFrontSides(session.frontSides);\n            setBackSides(session.backSides);\n            setRoundNumber(session.roundNumber || 1);\n            setStartTime(session.startTime || Date.now());\n            setIsMissedCardsRound(session.isMissedCardsRound || false);\n            setProgressionMode(session.progressionMode || 'shuffle');\n\n            // Handle includeMastered and card order\n            const sessionIncludeMastered =\n              session.includeMastered !== undefined ? session.includeMastered : true;\n            setIncludeMastered(sessionIncludeMastered);\n\n            // Validate card order against current mastered cards\n            if (session.cardOrder && !session.isMissedCardsRound) {\n              const { getMasteredCards } = useCardMasteryStore.getState();\n              const masteredIndices = getMasteredCards(deckId);\n\n              if (!sessionIncludeMastered && masteredIndices.length > 0) {\n                // Filter out mastered cards from the order\n                const filteredOrder = session.cardOrder.filter(\n                  (idx: number) => !masteredIndices.includes(idx)\n                );\n                setCardOrder(filteredOrder.length > 0 ? filteredOrder : session.cardOrder);\n              } else {\n                setCardOrder(session.cardOrder);\n              }\n            } else {\n              setCardOrder(\n                session.cardOrder || Array.from({ length: deck.content.length }, (_, i) => i)\n              );\n            }\n          } else {\n            // Initialize new session with shuffled cards (excluding mastered if needed)\n            const { getMasteredCards } = useCardMasteryStore.getState();\n            const masteredIndices = getMasteredCards(deckId);\n            let initialIndices = Array.from({ length: deck.content.length }, (_, i) => i);\n\n            // Exclude mastered cards by default for new sessions\n            if (masteredIndices.length > 0) {\n              initialIndices = initialIndices.filter(i => !masteredIndices.includes(i));\n              setIncludeMastered(false);\n            }\n\n            // Shuffle by default\n            const shuffled = [...initialIndices];\n            for (let i = shuffled.length - 1; i > 0; i--) {\n              const j = Math.floor(Math.random() * (i + 1));\n              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n            }\n            setCardOrder(shuffled);\n            setStartTime(Date.now());\n          }\n          isInitialMount.current = false;\n        }\n      } else {\n        navigate('/');\n      }\n    }\n  }, [deckId, decks, selectDeck, navigate, getSession]);\n\n  // Prevent body scrolling on mobile\n  useEffect(() => {\n    document.body.classList.add('no-scroll');\n\n    return () => {\n      document.body.classList.remove('no-scroll');\n    };\n  }, []);\n\n  // Save session whenever progress changes\n  useEffect(() => {\n    if (deckId && !isInitialMount.current) {\n      saveSession({\n        deckId,\n        currentCardIndex,\n        progress,\n        frontSides,\n        backSides,\n        lastAccessed: Date.now(),\n        roundNumber,\n        cardOrder,\n        startTime,\n        isMissedCardsRound,\n        progressionMode,\n        includeMastered,\n      });\n    }\n  }, [\n    deckId,\n    currentCardIndex,\n    progress,\n    frontSides,\n    backSides,\n    saveSession,\n    roundNumber,\n    cardOrder,\n    startTime,\n    isMissedCardsRound,\n    progressionMode,\n    includeMastered,\n  ]);\n\n  // Helper function to create card order based on progression mode\n  const createCardOrder = useCallback(\n    (\n      deck: typeof activeDeck,\n      mode: 'sequential' | 'shuffle' | 'level',\n      excludeMastered: boolean = false\n    ): number[] => {\n      if (!deck || !deckId) return [];\n\n      let indices = Array.from({ length: deck.content.length }, (_, i) => i);\n\n      // Filter out mastered cards if needed\n      if (excludeMastered) {\n        const { getMasteredCards } = useCardMasteryStore.getState();\n        const masteredIndices = getMasteredCards(deckId);\n        indices = indices.filter(i => !masteredIndices.includes(i));\n      }\n\n      switch (mode) {\n        case 'sequential':\n          return indices;\n\n        case 'shuffle':\n          // Fisher-Yates shuffle\n          const shuffled = [...indices];\n          for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n          }\n          return shuffled;\n\n        case 'level':\n          // Sort by level, then by index within each level\n          return indices.sort((a, b) => {\n            const levelDiff = deck.content[a].level - deck.content[b].level;\n            return levelDiff !== 0 ? levelDiff : a - b;\n          });\n\n        default:\n          return indices;\n      }\n    },\n    [deckId]\n  );\n\n  // Define handleDeckCompletion before handleNext since handleNext depends on it\n  const handleDeckCompletion = useCallback(() => {\n    if (!activeDeck || !deckId) return;\n\n    const session = {\n      deckId,\n      currentCardIndex,\n      progress,\n      frontSides,\n      backSides,\n      lastAccessed: Date.now(),\n      roundNumber,\n      cardOrder,\n      startTime,\n      isMissedCardsRound,\n    };\n\n    const missedIndices = getMissedCardIndices(session);\n    const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n    const correctCards = Object.values(progress).filter(p => p === 'correct').length;\n    const incorrectCards = Object.values(progress).filter(p => p === 'incorrect').length;\n\n    // Calculate accuracy based on cards actually answered, not total deck size\n    const cardsAnswered = correctCards + incorrectCards;\n    const accuracy = cardsAnswered > 0 ? (correctCards / cardsAnswered) * 100 : 0;\n\n    const results: FlashcardSessionResults = {\n      deckId,\n      totalCards,\n      correctCards,\n      incorrectCards,\n      accuracy,\n      roundNumber,\n      isComplete: incorrectCards === 0,\n      missedCardIndices: missedIndices,\n      startTime,\n      endTime: Date.now(),\n    };\n\n    setCompletionResults(results);\n    setShowCompletionModal(true);\n\n    // Update progress store with the session results\n    if (deckId) {\n      updateDeckProgress(deckId, 'flashcards', cardsAnswered, correctCards, cardsAnswered);\n    }\n  }, [\n    activeDeck,\n    deckId,\n    currentCardIndex,\n    progress,\n    frontSides,\n    backSides,\n    roundNumber,\n    cardOrder,\n    startTime,\n    isMissedCardsRound,\n    getMissedCardIndices,\n    updateDeckProgress,\n  ]);\n\n  const handleNext = useCallback(() => {\n    if (!activeDeck) return;\n\n    const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n\n    if (currentCardIndex < totalCards - 1) {\n      setCurrentCardIndex(prev => prev + 1);\n      setIsFlipped(false);\n    } else {\n      // Deck completion - show modal\n      handleDeckCompletion();\n    }\n  }, [activeDeck, currentCardIndex, isMissedCardsRound, cardOrder, handleDeckCompletion]);\n\n  const handlePrevious = useCallback(() => {\n    if (currentCardIndex > 0) {\n      setCurrentCardIndex(prev => prev - 1);\n      setIsFlipped(false);\n    }\n  }, [currentCardIndex]);\n\n  const handleFlip = useCallback(() => {\n    setIsFlipped(prev => !prev);\n  }, []);\n\n  const markCard = useCallback(\n    (status: 'correct' | 'incorrect') => {\n      setProgress(prev => ({\n        ...prev,\n        [currentCardIndex]: status,\n      }));\n      setSwipeDirection(status === 'correct' ? 'right' : 'left');\n      setTimeout(() => {\n        handleNext();\n        setSwipeDirection(null);\n      }, 400);\n    },\n    [currentCardIndex, handleNext]\n  );\n\n  const handleContinueWithMissed = useCallback(() => {\n    if (!completionResults || !deckId || !activeDeck) return;\n\n    const missedIndices = completionResults.missedCardIndices;\n\n    // Apply progression mode to missed cards\n    let orderedMissedIndices: number[];\n    if (progressionMode === 'shuffle') {\n      orderedMissedIndices = [...missedIndices];\n      for (let i = orderedMissedIndices.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [orderedMissedIndices[i], orderedMissedIndices[j]] = [\n          orderedMissedIndices[j],\n          orderedMissedIndices[i],\n        ];\n      }\n    } else if (progressionMode === 'level') {\n      orderedMissedIndices = [...missedIndices].sort((a, b) => {\n        const levelDiff = activeDeck.content[a].level - activeDeck.content[b].level;\n        return levelDiff !== 0 ? levelDiff : a - b;\n      });\n    } else {\n      orderedMissedIndices = missedIndices;\n    }\n\n    const newSession = startMissedCardsRound(deckId, orderedMissedIndices);\n\n    // Update local state from new session\n    setCurrentCardIndex(0);\n    setIsFlipped(false);\n    setProgress({});\n    setRoundNumber(newSession.roundNumber);\n    setCardOrder(orderedMissedIndices);\n    setStartTime(newSession.startTime);\n    setIsMissedCardsRound(true);\n    setShowCompletionModal(false);\n    setCompletionResults(null);\n  }, [completionResults, deckId, activeDeck, startMissedCardsRound, progressionMode]);\n\n  const handleStartNewRound = useCallback(() => {\n    if (!deckId || !activeDeck) return;\n\n    const newSession = startNewRound(deckId, activeDeck.content.length);\n    const newOrder = createCardOrder(activeDeck, progressionMode, !includeMastered);\n\n    // Update local state from new session\n    setCurrentCardIndex(0);\n    setIsFlipped(false);\n    setProgress({});\n    setRoundNumber(newSession.roundNumber);\n    setCardOrder(newOrder);\n    setStartTime(newSession.startTime);\n    setIsMissedCardsRound(false);\n    setShowCompletionModal(false);\n    setCompletionResults(null);\n  }, [deckId, activeDeck, startNewRound, createCardOrder, progressionMode, includeMastered]);\n\n  const handleBackToDeck = useCallback(() => {\n    navigate(`/deck/${deckId}`);\n  }, [navigate, deckId]);\n\n  const handleDragEnd = useCallback(\n    (_event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {\n      const threshold = 100;\n      if (Math.abs(info.offset.x) > threshold) {\n        if (info.offset.x > 0) {\n          markCard('correct');\n        } else {\n          markCard('incorrect');\n        }\n      }\n    },\n    [markCard]\n  );\n\n  const updateSettings = useCallback(\n    (settings: FlashcardsSettings) => {\n      const newFrontSides = settings.frontSides || frontSides;\n      const newBackSides = settings.backSides || backSides;\n      const newProgressionMode = settings.progressionMode || progressionMode;\n      const newIncludeMastered =\n        settings.includeMastered !== undefined ? settings.includeMastered : includeMastered;\n\n      setFrontSides(newFrontSides);\n      setBackSides(newBackSides);\n      setIsFlipped(false);\n\n      // Check if we need to reorder cards\n      const shouldReorder =\n        newProgressionMode !== progressionMode || newIncludeMastered !== includeMastered;\n\n      if (shouldReorder && activeDeck && !isMissedCardsRound) {\n        setProgressionMode(newProgressionMode);\n        setIncludeMastered(newIncludeMastered);\n\n        const newOrder = createCardOrder(activeDeck, newProgressionMode, !newIncludeMastered);\n        setCardOrder(newOrder);\n        // Reset to first card when changing settings\n        setCurrentCardIndex(0);\n        setProgress({});\n      } else {\n        setProgressionMode(newProgressionMode);\n        setIncludeMastered(newIncludeMastered);\n      }\n\n      // Save settings to store\n      if (deckId) {\n        updateStoredSettings(deckId, 'flashcards', settings);\n      }\n    },\n    [\n      progressionMode,\n      includeMastered,\n      activeDeck,\n      isMissedCardsRound,\n      createCardOrder,\n      frontSides,\n      backSides,\n      deckId,\n      updateStoredSettings,\n    ]\n  );\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      switch (e.key) {\n        case ' ':\n          e.preventDefault();\n          handleFlip();\n          break;\n        case 'ArrowRight':\n          handleNext();\n          break;\n        case 'ArrowLeft':\n          handlePrevious();\n          break;\n        case '1':\n          markCard('incorrect');\n          break;\n        case '2':\n          markCard('correct');\n          break;\n      }\n    },\n    [handleFlip, handleNext, handlePrevious, markCard]\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  if (!activeDeck) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  // Get the actual card based on the card order (always use cardOrder for proper shuffling)\n  const actualCardIndex = cardOrder.length > 0 ? cardOrder[currentCardIndex] : currentCardIndex;\n  const currentCard = activeDeck.content[actualCardIndex];\n  const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n  const progressPercentage = (Object.keys(progress).length / totalCards) * 100;\n  const correctCount = Object.values(progress).filter(p => p === 'correct').length;\n  const incorrectCount = Object.values(progress).filter(p => p === 'incorrect').length;\n\n  return (\n    <div className={styles.container}>\n      <SharedModeHeader\n        deckName={activeDeck.metadata.deck_name}\n        currentCard={currentCardIndex + 1}\n        totalCards={totalCards}\n        onBackClick={() => {\n          // Session is automatically saved via useEffect\n          navigate(`/deck/${deckId}`);\n        }}\n        onSettingsClick={() => setShowSettings(true)}\n        showSettings={true}\n        subtitle={[\n          isMissedCardsRound ? 'Review' : null,\n          roundNumber > 1 ? `Round ${roundNumber}` : null,\n        ]\n          .filter(Boolean)\n          .join(' ')}\n      />\n\n      <div className={styles.progressSection}>\n        <div className={styles.progressBar}>\n          <div className={styles.progressFill} style={{ width: `${progressPercentage}%` }} />\n        </div>\n        <div className={styles.progressStats}>\n          <span className={styles.incorrectStat}>‚úó {incorrectCount}</span>\n          <span className={styles.correctStat}>‚úì {correctCount}</span>\n        </div>\n      </div>\n\n      <main className={styles.main}>\n        <AnimatePresence mode=\"wait\">\n          <motion.div\n            key={currentCardIndex}\n            className={styles.cardWrapper}\n            drag=\"x\"\n            dragConstraints={{ left: 0, right: 0 }}\n            dragElastic={1}\n            onDragEnd={handleDragEnd}\n            style={{ touchAction: 'none' }}\n            initial={{ y: window.innerHeight, opacity: 0 }}\n            animate={{\n              y: 0,\n              opacity: 1,\n              x:\n                swipeDirection === 'right'\n                  ? window.innerWidth\n                  : swipeDirection === 'left'\n                    ? -window.innerWidth\n                    : 0,\n              rotate: swipeDirection === 'right' ? 20 : swipeDirection === 'left' ? -20 : 0,\n            }}\n            exit={{\n              opacity: 0,\n              transition: { duration: 0.2 },\n            }}\n            transition={{\n              type: 'spring',\n              stiffness: 300,\n              damping: 30,\n            }}\n          >\n            <FlashCard\n              card={currentCard}\n              isFlipped={isFlipped}\n              onFlip={handleFlip}\n              frontSides={frontSides}\n              backSides={backSides}\n            />\n\n            {/* Swipe indicators */}\n            <div\n              className={`${styles.swipeIndicator} ${styles.incorrect}`}\n              style={{ opacity: swipeDirection === 'left' ? 1 : 0 }}\n            >\n              ‚úó\n            </div>\n            <div\n              className={`${styles.swipeIndicator} ${styles.correct}`}\n              style={{ opacity: swipeDirection === 'right' ? 1 : 0 }}\n            >\n              ‚úì\n            </div>\n          </motion.div>\n        </AnimatePresence>\n      </main>\n\n      <div className={styles.controls}>\n        <button\n          className={styles.navButton}\n          onClick={handlePrevious}\n          disabled={currentCardIndex === 0}\n          aria-label=\"Previous card\"\n        >\n          ‚Üê\n        </button>\n\n        <div className={styles.actionButtons}>\n          <button\n            className={`${styles.markButton} ${styles.incorrect}`}\n            onClick={() => markCard('incorrect')}\n            aria-label=\"Mark as incorrect\"\n          >\n            ‚úó Incorrect\n          </button>\n          <button className={styles.flipButton} onClick={handleFlip} aria-label=\"Flip card\">\n            Flip\n          </button>\n          <button\n            className={`${styles.markButton} ${styles.correct}`}\n            onClick={() => markCard('correct')}\n            aria-label=\"Mark as correct\"\n          >\n            ‚úì Correct\n          </button>\n        </div>\n\n        <button\n          className={styles.navButton}\n          onClick={handleNext}\n          disabled={currentCardIndex === totalCards - 1}\n          aria-label=\"Next card\"\n        >\n          ‚Üí\n        </button>\n      </div>\n\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={() => setShowSettings(false)}\n        deck={activeDeck}\n        mode=\"flashcards\"\n        settings={\n          {\n            frontSides,\n            backSides,\n            progressionMode,\n            includeMastered,\n            enableTimer: false,\n            timerSeconds: 30,\n            enableAudio: false,\n            groupSides: {},\n          } as FlashcardsSettings\n        }\n        onUpdateSettings={(newSettings) => {\n          updateSettings(newSettings as FlashcardsSettings);\n        }}\n      />\n\n      <FlashcardsCompletionModal\n        visible={showCompletionModal}\n        results={completionResults}\n        onContinueWithMissed={handleContinueWithMissed}\n        onStartNewRound={handleStartNewRound}\n        onBackToDeck={handleBackToDeck}\n        onClose={() => setShowCompletionModal(false)}\n      />\n    </div>\n  );\n};\n\nexport default Flashcards;\n"],"names":["DEFAULT_FRONT_SIDES","DEFAULT_BACK_SIDES","SESSION_EXPIRY_MS","useFlashcardSessionStore","create","persist","set","get","sessions","Map","getSession","deckId","session","Date","now","lastAccessed","clearSession","saveSession","state","newSessions","delete","clearOldSessions","forEach","startNewRound","totalCards","existingSession","newSession","currentCardIndex","progress","frontSides","backSides","roundNumber","cardOrder","Array","from","length","_","i","startTime","isMissedCardsRound","progressionMode","includeMastered","startMissedCardsRound","missedCardIndices","shuffled","sort","Math","random","getMissedCardIndices","missedIndices","originalIndex","currentIndex","push","Object","entries","index","status","parseInt","name","storage","getItem","str","localStorage","JSON","parse","setItem","value","serialized","stringify","removeItem","FlashcardsCompletionModal","visible","results","onContinueWithMissed","onStartNewRound","onBackToDeck","onClose","accuracyPercentage","round","accuracy","duration","endTime","timeInSeconds","minutes","floor","seconds","hasMissedCards","useEffect","handleKeyDown","e","target","tagName","isContentEditable","hasMissed","key","preventDefault","window","addEventListener","removeEventListener","jsx","AnimatePresence","children","jsxs","Fragment","motion","div","className","styles","initial","opacity","animate","exit","onClick","scale","y","transition","type","stiffness","damping","incorrectCards","correctCards","toString","padStart","title","Flashcards","useParams","navigate","useNavigate","decks","activeDeck","selectDeck","useDeckStore","updateDeckProgress","useProgressStore","updateSettings","updateStoredSettings","useSettingsStore","isInitialMount","useRef","setCurrentCardIndex","useState","isFlipped","setIsFlipped","setFrontSides","setBackSides","setProgress","showSettings","setShowSettings","swipeDirection","setSwipeDirection","setRoundNumber","setCardOrder","setStartTime","setIsMissedCardsRound","showCompletionModal","setShowCompletionModal","completionResults","setCompletionResults","setProgressionMode","setIncludeMastered","deck","find","d","id","current","sessionIncludeMastered","getMasteredCards","useCardMasteryStore","getState","masteredIndices","filteredOrder","filter","idx","includes","content","initialIndices","j","document","body","classList","add","remove","createCardOrder","useCallback","mode","excludeMastered","indices","a","b","levelDiff","level","handleDeckCompletion","values","p","cardsAnswered","isComplete","handleNext","prev","handlePrevious","handleFlip","markCard","setTimeout","handleContinueWithMissed","orderedMissedIndices","handleStartNewRound","newOrder","handleBackToDeck","handleDragEnd","_event","info","abs","offset","x","settings","newFrontSides","newBackSides","newProgressionMode","newIncludeMastered","actualCardIndex","currentCard","progressPercentage","keys","correctCount","incorrectCount","container","SharedModeHeader","deckName","metadata","deck_name","onBackClick","onSettingsClick","subtitle","Boolean","join","progressSection","progressBar","progressFill","style","width","progressStats","incorrectStat","correctStat","main","cardWrapper","drag","dragConstraints","left","right","dragElastic","onDragEnd","touchAction","innerHeight","innerWidth","rotate","FlashCard","card","onFlip","swipeIndicator","incorrect","correct","controls","navButton","disabled","actionButtons","markButton","flipButton","UnifiedSettings","enableTimer","timerSeconds","enableAudio","groupSides","onUpdateSettings","newSettings"],"mappings":"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"}