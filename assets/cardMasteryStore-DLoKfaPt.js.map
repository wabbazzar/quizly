{"version":3,"file":"cardMasteryStore-DLoKfaPt.js","sources":["../../src/store/cardMasteryStore.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport interface CardMasteryRecord {\n  cardIndex: number;\n  masteredAt: Date;\n  attemptCount: number;\n  lastSeen: Date;\n  consecutiveCorrect: number;\n}\n\nexport interface DeckMastery {\n  deckId: string;\n  masteredCards: Map<number, CardMasteryRecord>;\n  totalCards: number;\n  lastUpdated: Date;\n  masteryThreshold: number; // Store the threshold per deck\n}\n\ninterface CardMasteryStore {\n  // Mastery data by deck ID\n  mastery: Record<string, DeckMastery>;\n\n  // Actions\n  markCardMastered: (deckId: string, cardIndex: number, totalCards: number) => void;\n  unmarkCardMastered: (deckId: string, cardIndex: number) => void;\n  getMasteredCards: (deckId: string) => number[];\n  getDeckMasteryPercentage: (deckId: string, actualTotalCards?: number) => number;\n  resetDeckMastery: (deckId: string) => void;\n  updateCardAttempt: (\n    deckId: string,\n    cardIndex: number,\n    isCorrect: boolean,\n    totalCards: number,\n    masteryThreshold?: number\n  ) => void;\n  isCardMastered: (deckId: string, cardIndex: number) => boolean;\n}\n\nexport const useCardMasteryStore = create<CardMasteryStore>()(\n  persist(\n    (set, get) => ({\n      mastery: {},\n\n      markCardMastered: (deckId: string, cardIndex: number, totalCards: number) => {\n        set(state => {\n          const deckMastery = state.mastery[deckId] || {\n            deckId,\n            masteredCards: new Map(),\n            totalCards,\n            lastUpdated: new Date(),\n            masteryThreshold: 3,\n          };\n\n          const updatedMasteredCards = new Map(deckMastery.masteredCards);\n          updatedMasteredCards.set(cardIndex, {\n            cardIndex,\n            masteredAt: new Date(),\n            attemptCount: 1,\n            lastSeen: new Date(),\n            consecutiveCorrect: deckMastery.masteryThreshold || 3,\n          });\n\n          return {\n            mastery: {\n              ...state.mastery,\n              [deckId]: {\n                ...deckMastery,\n                masteredCards: updatedMasteredCards,\n                totalCards,\n                lastUpdated: new Date(),\n                masteryThreshold: deckMastery.masteryThreshold,\n              },\n            },\n          };\n        });\n      },\n\n      unmarkCardMastered: (deckId: string, cardIndex: number) => {\n        set(state => {\n          const deckMastery = state.mastery[deckId];\n          if (!deckMastery) return state;\n\n          const updatedMasteredCards = new Map(deckMastery.masteredCards);\n          updatedMasteredCards.delete(cardIndex);\n\n          return {\n            mastery: {\n              ...state.mastery,\n              [deckId]: {\n                ...deckMastery,\n                masteredCards: updatedMasteredCards,\n                lastUpdated: new Date(),\n                masteryThreshold: deckMastery.masteryThreshold,\n              },\n            },\n          };\n        });\n      },\n\n      getMasteredCards: (deckId: string) => {\n        const deckMastery = get().mastery[deckId];\n        if (!deckMastery) return [];\n\n        // Only return cards that have actually achieved mastery (3+ consecutive correct)\n        const masteredIndices: number[] = [];\n        deckMastery.masteredCards.forEach((record, cardIndex) => {\n          if (record.consecutiveCorrect >= (deckMastery.masteryThreshold || 3)) {\n            masteredIndices.push(cardIndex);\n          }\n        });\n        return masteredIndices;\n      },\n\n      getDeckMasteryPercentage: (deckId: string, actualTotalCards?: number) => {\n        const deckMastery = get().mastery[deckId];\n        // Use actualTotalCards if provided, otherwise fall back to stored totalCards\n        const totalCards = actualTotalCards ?? deckMastery?.totalCards ?? 0;\n\n        if (!deckMastery || totalCards === 0) return 0;\n\n        // Count only cards with 3+ consecutive correct answers\n        let masteredCount = 0;\n        deckMastery.masteredCards.forEach(record => {\n          if (record.consecutiveCorrect >= (deckMastery.masteryThreshold || 3)) {\n            masteredCount++;\n          }\n        });\n\n        return Math.round((masteredCount / totalCards) * 100);\n      },\n\n      resetDeckMastery: (deckId: string) => {\n        set(state => {\n          const newMastery = { ...state.mastery };\n          delete newMastery[deckId];\n          return { mastery: newMastery };\n        });\n      },\n\n      updateCardAttempt: (\n        deckId: string,\n        cardIndex: number,\n        isCorrect: boolean,\n        totalCards: number,\n        masteryThreshold: number = 3\n      ) => {\n        set(state => {\n          const deckMastery = state.mastery[deckId] || {\n            deckId,\n            masteredCards: new Map(),\n            totalCards,\n            lastUpdated: new Date(),\n            masteryThreshold,\n          };\n\n          const updatedMasteredCards = new Map(deckMastery.masteredCards);\n          const existingRecord = updatedMasteredCards.get(cardIndex);\n\n          if (isCorrect) {\n            const consecutiveCorrect = existingRecord ? existingRecord.consecutiveCorrect + 1 : 1;\n            const attemptCount = existingRecord ? existingRecord.attemptCount + 1 : 1;\n\n            // Mark as mastered if consecutive correct reaches configurable threshold\n            if (consecutiveCorrect >= masteryThreshold) {\n              updatedMasteredCards.set(cardIndex, {\n                cardIndex,\n                masteredAt: existingRecord?.masteredAt || new Date(),\n                attemptCount,\n                lastSeen: new Date(),\n                consecutiveCorrect,\n              });\n            } else {\n              // Create or update record for cards not yet mastered\n              updatedMasteredCards.set(cardIndex, {\n                cardIndex,\n                masteredAt: existingRecord?.masteredAt || new Date(),\n                attemptCount,\n                lastSeen: new Date(),\n                consecutiveCorrect,\n              });\n            }\n          } else {\n            // Reset consecutive correct on wrong answer\n            if (existingRecord) {\n              // If it was mastered but got wrong, remove mastery\n              if (existingRecord.consecutiveCorrect >= masteryThreshold) {\n                updatedMasteredCards.delete(cardIndex);\n              } else {\n                updatedMasteredCards.set(cardIndex, {\n                  ...existingRecord,\n                  attemptCount: existingRecord.attemptCount + 1,\n                  lastSeen: new Date(),\n                  consecutiveCorrect: 0,\n                });\n              }\n            }\n          }\n\n          return {\n            mastery: {\n              ...state.mastery,\n              [deckId]: {\n                ...deckMastery,\n                masteredCards: updatedMasteredCards,\n                totalCards,\n                lastUpdated: new Date(),\n                masteryThreshold,\n              },\n            },\n          };\n        });\n      },\n\n      isCardMastered: (deckId: string, cardIndex: number) => {\n        const deckMastery = get().mastery[deckId];\n        if (!deckMastery) return false;\n\n        const record = deckMastery.masteredCards.get(cardIndex);\n        const masteryThreshold = deckMastery?.masteryThreshold || 3;\n        return record ? record.consecutiveCorrect >= masteryThreshold : false;\n      },\n    }),\n    {\n      name: 'card-mastery-store',\n      // Custom serialization to handle Map objects\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          const parsed = JSON.parse(str);\n          if (parsed.state && parsed.state.mastery) {\n            // Convert arrays back to Maps\n            Object.keys(parsed.state.mastery).forEach(deckId => {\n              const deckMastery = parsed.state.mastery[deckId];\n              if (Array.isArray(deckMastery.masteredCards)) {\n                deckMastery.masteredCards = new Map(deckMastery.masteredCards);\n              }\n              // Convert date strings back to Date objects\n              if (deckMastery.lastUpdated) {\n                deckMastery.lastUpdated = new Date(deckMastery.lastUpdated);\n              }\n              // Convert dates in mastery records\n              deckMastery.masteredCards.forEach((record: CardMasteryRecord) => {\n                if (record.masteredAt) record.masteredAt = new Date(record.masteredAt);\n                if (record.lastSeen) record.lastSeen = new Date(record.lastSeen);\n              });\n            });\n          }\n          return parsed;\n        },\n        setItem: (name, value) => {\n          // Convert Maps to arrays for serialization\n          const toStore = {\n            ...value,\n            state: {\n              ...value.state,\n              mastery: Object.keys(value.state.mastery).reduce(\n                (\n                  acc: Record<\n                    string,\n                    Omit<DeckMastery, 'masteredCards'> & {\n                      masteredCards: [number, CardMasteryRecord][];\n                    }\n                  >,\n                  deckId: string\n                ) => {\n                  const deckMastery = value.state.mastery[deckId];\n                  acc[deckId] = {\n                    ...deckMastery,\n                    masteredCards: deckMastery.masteredCards\n                      ? Array.from(deckMastery.masteredCards.entries())\n                      : [],\n                  };\n                  return acc;\n                },\n                {}\n              ),\n            },\n          };\n          localStorage.setItem(name, JSON.stringify(toStore));\n        },\n        removeItem: name => {\n          localStorage.removeItem(name);\n        },\n      },\n    }\n  )\n);\n"],"names":["useCardMasteryStore","create","persist","set","get","mastery","markCardMastered","deckId","cardIndex","totalCards","state","deckMastery","masteredCards","Map","lastUpdated","Date","masteryThreshold","updatedMasteredCards","masteredAt","attemptCount","lastSeen","consecutiveCorrect","unmarkCardMastered","delete","getMasteredCards","masteredIndices","forEach","record","push","getDeckMasteryPercentage","actualTotalCards","masteredCount","Math","round","resetDeckMastery","newMastery","updateCardAttempt","isCorrect","existingRecord","isCardMastered","name","storage","getItem","str","localStorage","parsed","JSON","parse","Object","keys","Array","isArray","setItem","value","toStore","reduce","acc","from","entries","stringify","removeItem"],"mappings":"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"}