{"version":3,"file":"Flashcards-DwwlFjsi.js","sources":["../../src/store/flashcardSessionStore.ts","../../src/components/FlashCard.tsx","../../src/components/modals/FlashcardsCompletionModal.tsx","../../src/pages/Flashcards.tsx"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport interface FlashcardSession {\n  deckId: string;\n  currentCardIndex: number;\n  progress: { [key: number]: 'correct' | 'incorrect' | null };\n  frontSides: string[];\n  backSides: string[];\n  lastAccessed: number;\n  roundNumber: number;\n  cardOrder: number[]; // Current order of cards (for shuffling missed cards)\n  startTime: number;\n  isMissedCardsRound: boolean; // True if current round is missed cards only\n  progressionMode?: 'sequential' | 'shuffle' | 'level'; // Card progression mode\n  includeMastered?: boolean; // Whether to include mastered cards in the session\n}\n\ninterface FlashcardSessionStore {\n  sessions: Map<string, FlashcardSession>;\n\n  getSession: (deckId: string) => FlashcardSession | undefined;\n  saveSession: (session: FlashcardSession) => void;\n  clearSession: (deckId: string) => void;\n  clearOldSessions: () => void;\n  startNewRound: (deckId: string, totalCards: number) => FlashcardSession;\n  startMissedCardsRound: (deckId: string, missedCardIndices: number[]) => FlashcardSession;\n  getMissedCardIndices: (session: FlashcardSession) => number[];\n}\n\nexport const DEFAULT_FRONT_SIDES = ['side_a'];\nexport const DEFAULT_BACK_SIDES = ['side_b'];\nconst SESSION_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport const useFlashcardSessionStore = create<FlashcardSessionStore>()(\n  persist(\n    (set, get) => ({\n      sessions: new Map(),\n\n      getSession: (deckId: string) => {\n        const sessions = get().sessions;\n        const session = sessions.get(deckId);\n\n        if (session) {\n          // Check if session is expired\n          if (Date.now() - session.lastAccessed > SESSION_EXPIRY_MS) {\n            get().clearSession(deckId);\n            return undefined;\n          }\n          return session;\n        }\n\n        return undefined;\n      },\n\n      saveSession: (session: FlashcardSession) => {\n        set(state => {\n          const newSessions = new Map(state.sessions);\n          newSessions.set(session.deckId, {\n            ...session,\n            lastAccessed: Date.now(),\n          });\n          return { sessions: newSessions };\n        });\n      },\n\n      clearSession: (deckId: string) => {\n        set(state => {\n          const newSessions = new Map(state.sessions);\n          newSessions.delete(deckId);\n          return { sessions: newSessions };\n        });\n      },\n\n      clearOldSessions: () => {\n        set(state => {\n          const newSessions = new Map();\n          const now = Date.now();\n\n          state.sessions.forEach((session, deckId) => {\n            if (now - session.lastAccessed <= SESSION_EXPIRY_MS) {\n              newSessions.set(deckId, session);\n            }\n          });\n\n          return { sessions: newSessions };\n        });\n      },\n\n      startNewRound: (deckId: string, totalCards: number) => {\n        const existingSession = get().getSession(deckId);\n        const newSession: FlashcardSession = {\n          deckId,\n          currentCardIndex: 0,\n          progress: {},\n          frontSides: existingSession?.frontSides || DEFAULT_FRONT_SIDES,\n          backSides: existingSession?.backSides || DEFAULT_BACK_SIDES,\n          lastAccessed: Date.now(),\n          roundNumber: (existingSession?.roundNumber || 0) + 1,\n          cardOrder: Array.from({ length: totalCards }, (_, i) => i),\n          startTime: Date.now(),\n          isMissedCardsRound: false,\n          progressionMode: existingSession?.progressionMode || 'shuffle',\n          includeMastered:\n            existingSession?.includeMastered !== undefined ? existingSession.includeMastered : true,\n        };\n\n        get().saveSession(newSession);\n        return newSession;\n      },\n\n      startMissedCardsRound: (deckId: string, missedCardIndices: number[]) => {\n        const existingSession = get().getSession(deckId);\n\n        // Shuffle the missed cards for variety\n        const shuffled = [...missedCardIndices].sort(() => Math.random() - 0.5);\n\n        const newSession: FlashcardSession = {\n          deckId,\n          currentCardIndex: 0,\n          progress: {},\n          frontSides: existingSession?.frontSides || DEFAULT_FRONT_SIDES,\n          backSides: existingSession?.backSides || DEFAULT_BACK_SIDES,\n          lastAccessed: Date.now(),\n          roundNumber: (existingSession?.roundNumber || 0) + 1,\n          cardOrder: shuffled,\n          startTime: Date.now(),\n          isMissedCardsRound: true,\n          progressionMode: existingSession?.progressionMode || 'shuffle',\n          includeMastered:\n            existingSession?.includeMastered !== undefined ? existingSession.includeMastered : true,\n        };\n\n        get().saveSession(newSession);\n        return newSession;\n      },\n\n      getMissedCardIndices: (session: FlashcardSession) => {\n        const missedIndices: number[] = [];\n\n        if (session.isMissedCardsRound) {\n          // For missed cards round, check progress against the card order\n          session.cardOrder.forEach((originalIndex, currentIndex) => {\n            if (session.progress[currentIndex] === 'incorrect' || !session.progress[currentIndex]) {\n              missedIndices.push(originalIndex);\n            }\n          });\n        } else {\n          // For regular round, check all cards\n          Object.entries(session.progress).forEach(([index, status]) => {\n            if (status === 'incorrect') {\n              missedIndices.push(parseInt(index));\n            }\n          });\n        }\n\n        return missedIndices;\n      },\n    }),\n    {\n      name: 'flashcard-session-store',\n      // Custom storage to handle Map serialization\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          const { state } = JSON.parse(str);\n          return {\n            state: {\n              ...state,\n              sessions: new Map(state.sessions || []),\n            },\n          };\n        },\n        setItem: (name, value) => {\n          const { state } = value;\n          const serialized = {\n            state: {\n              ...state,\n              sessions: Array.from(state.sessions.entries()),\n            },\n          };\n          localStorage.setItem(name, JSON.stringify(serialized));\n        },\n        removeItem: name => localStorage.removeItem(name),\n      },\n    }\n  )\n);\n","import { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { Card } from '@/types';\nimport styles from './FlashCard.module.css';\n\ninterface FlashCardProps {\n  card: Card;\n  isFlipped: boolean;\n  onFlip: () => void;\n  frontSides?: string[];\n  backSides?: string[];\n}\n\nconst FlashCard: FC<FlashCardProps> = ({\n  card,\n  isFlipped,\n  onFlip,\n  frontSides = ['side_a'],\n  backSides = ['side_b'],\n}) => {\n  const frontContent = frontSides\n    .filter(side => card[side as keyof Card])\n    .map(side => ({\n      content: card[side as keyof Card] as string,\n    }));\n\n  const backContent = backSides\n    .filter(side => card[side as keyof Card])\n    .map(side => ({\n      content: card[side as keyof Card] as string,\n    }));\n\n  return (\n    <div className={styles.cardContainer} onClick={onFlip}>\n      <motion.div\n        className={styles.card}\n        animate={{ rotateY: isFlipped ? 180 : 0 }}\n        transition={{ duration: 0.6, type: 'spring', stiffness: 100 }}\n        style={{ transformStyle: 'preserve-3d' }}\n      >\n        {/* Front of card */}\n        <div className={`${styles.cardFace} ${styles.cardFront}`}>\n          <div className={styles.cardContent}>\n            {frontContent.map((item, index) => (\n              <div key={index} className={styles.contentItem}>\n                <div className={styles.text}>{item.content}</div>\n              </div>\n            ))}\n          </div>\n          {card.level && <div className={styles.level}>Level {card.level}</div>}\n        </div>\n\n        {/* Back of card */}\n        <div className={`${styles.cardFace} ${styles.cardBack}`}>\n          <div className={styles.cardContent}>\n            {backContent.map((item, index) => (\n              <div key={index} className={styles.contentItem}>\n                <div className={styles.text}>{item.content}</div>\n              </div>\n            ))}\n          </div>\n          {card.level && <div className={styles.level}>Level {card.level}</div>}\n        </div>\n      </motion.div>\n    </div>\n  );\n};\n\nexport default FlashCard;\n","import { FC, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport styles from './FlashcardsCompletionModal.module.css';\n\nexport interface FlashcardSessionResults {\n  deckId: string;\n  totalCards: number;\n  correctCards: number;\n  incorrectCards: number;\n  accuracy: number;\n  roundNumber: number;\n  isComplete: boolean;\n  missedCardIndices: number[];\n  startTime: number;\n  endTime: number;\n}\n\ninterface FlashcardsCompletionModalProps {\n  visible: boolean;\n  results: FlashcardSessionResults | null;\n  onContinueWithMissed: () => void;\n  onStartNewRound: () => void;\n  onBackToDeck: () => void;\n  onClose: () => void;\n}\n\nconst FlashcardsCompletionModal: FC<FlashcardsCompletionModalProps> = ({\n  visible,\n  results,\n  onContinueWithMissed,\n  onStartNewRound,\n  onBackToDeck,\n  onClose,\n}) => {\n  const accuracyPercentage = results ? Math.round(results.accuracy) : 0;\n  const duration = results ? results.endTime - results.startTime : 0;\n  const timeInSeconds = Math.round(duration / 1000);\n  const minutes = Math.floor(timeInSeconds / 60);\n  const seconds = timeInSeconds % 60;\n  const hasMissedCards = results ? results.missedCardIndices.length > 0 : false;\n\n  const getPerformanceEmoji = () => {\n    if (accuracyPercentage === 100) return '🏆';\n    if (accuracyPercentage >= 90) return '🌟';\n    if (accuracyPercentage >= 75) return '✨';\n    if (accuracyPercentage >= 60) return '👍';\n    return '💪';\n  };\n\n  const getPerformanceMessage = () => {\n    if (accuracyPercentage === 100) return 'Perfect Round!';\n    if (accuracyPercentage >= 90) return 'Outstanding!';\n    if (accuracyPercentage >= 75) return 'Great job!';\n    if (accuracyPercentage >= 60) return 'Good effort!';\n    return 'Keep practicing!';\n  };\n\n  const getRoundMessage = () => {\n    if (!results) return '';\n    if (results.roundNumber === 1) {\n      return hasMissedCards\n        ? `You completed Round ${results.roundNumber} with ${results.incorrectCards} card${results.incorrectCards === 1 ? '' : 's'} to review.`\n        : `You completed Round ${results.roundNumber} perfectly!`;\n    }\n    return hasMissedCards\n      ? `Round ${results.roundNumber} complete! ${results.incorrectCards} card${results.incorrectCards === 1 ? '' : 's'} still need review.`\n      : `Round ${results.roundNumber} complete! All cards mastered!`;\n  };\n\n  // Keyboard shortcuts when modal is visible\n  // If there are missed cards: 1 = Continue with Missed, 2 = Start Full Deck Again, 3 = Back to Deck\n  // If no missed cards: 1 = Start New Round, 3 = Back to Deck\n  useEffect(() => {\n    if (!visible || !results) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea/contentEditable\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      const hasMissed = results.missedCardIndices.length > 0;\n\n      if (e.key === '1') {\n        e.preventDefault();\n        if (hasMissed) {\n          onContinueWithMissed();\n        } else {\n          onStartNewRound();\n        }\n      } else if (e.key === '2' && hasMissed) {\n        e.preventDefault();\n        onStartNewRound();\n      } else if (e.key === '3') {\n        e.preventDefault();\n        onBackToDeck();\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [visible, results, onContinueWithMissed, onStartNewRound, onBackToDeck]);\n\n  if (!results) return null;\n\n  return (\n    <AnimatePresence>\n      {visible && (\n        <>\n          <motion.div\n            className={styles.overlay}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            onClick={onClose}\n          />\n          <motion.div\n            className={styles.modal}\n            initial={{ opacity: 0, scale: 0.9, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.9, y: 20 }}\n            transition={{ type: 'spring', stiffness: 300, damping: 30 }}\n          >\n            {/* Performance Header */}\n            <div className={styles.performanceHeader}>\n              <div className={styles.performanceEmoji}>{getPerformanceEmoji()}</div>\n              <h2 className={styles.performanceMessage}>{getPerformanceMessage()}</h2>\n              <p className={styles.roundMessage}>{getRoundMessage()}</p>\n            </div>\n\n            {/* Main Score */}\n            <div className={styles.mainScore}>\n              <div className={styles.accuracyDisplay}>\n                <span className={styles.accuracyNumber}>{accuracyPercentage}</span>\n                <span className={styles.accuracyPercent}>%</span>\n              </div>\n              <p className={styles.accuracyLabel}>Accuracy</p>\n            </div>\n\n            {/* Stats Grid */}\n            <div className={styles.statsGrid}>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.correctCards}</div>\n                <div className={styles.statLabel}>Correct</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.incorrectCards}</div>\n                <div className={styles.statLabel}>Incorrect</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>{results.totalCards}</div>\n                <div className={styles.statLabel}>Total Cards</div>\n              </div>\n              <div className={styles.statCard}>\n                <div className={styles.statValue}>\n                  {minutes}:{seconds.toString().padStart(2, '0')}\n                </div>\n                <div className={styles.statLabel}>Time</div>\n              </div>\n            </div>\n\n            {/* Round Info */}\n            <div className={styles.roundInfo}>\n              <div className={styles.roundBadge}>Round {results.roundNumber}</div>\n              {hasMissedCards && (\n                <div className={styles.missedCardsInfo}>\n                  {results.incorrectCards} card{results.incorrectCards === 1 ? '' : 's'} to review\n                </div>\n              )}\n            </div>\n\n            {/* Action Buttons */}\n            <div className={styles.actionButtons}>\n              {hasMissedCards ? (\n                <>\n                  <button\n                    onClick={onContinueWithMissed}\n                    className={`${styles.actionButton} ${styles.primaryButton}`}\n                    title=\"Press 1 to continue\"\n                  >\n                    Continue with Missed Cards ({results.incorrectCards})\n                  </button>\n                  <button\n                    onClick={onStartNewRound}\n                    className={`${styles.actionButton} ${styles.secondaryButton}`}\n                    title=\"Press 2 to start again\"\n                  >\n                    Start Full Deck Again\n                  </button>\n                </>\n              ) : (\n                <>\n                  <button\n                    onClick={onStartNewRound}\n                    className={`${styles.actionButton} ${styles.primaryButton}`}\n                    title=\"Press 1 to start new round\"\n                  >\n                    Start New Round\n                  </button>\n                </>\n              )}\n              <button\n                onClick={onBackToDeck}\n                className={`${styles.actionButton} ${styles.tertiaryButton}`}\n                title=\"Press 3 to go back\"\n              >\n                Back to Deck\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n};\n\nexport default FlashcardsCompletionModal;\n","import { FC, useState, useEffect, useCallback, useRef } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { motion, PanInfo, AnimatePresence } from 'framer-motion';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport {\n  useFlashcardSessionStore,\n  DEFAULT_FRONT_SIDES,\n  DEFAULT_BACK_SIDES,\n} from '@/store/flashcardSessionStore';\nimport { useProgressStore } from '@/store/progressStore';\nimport { FlashcardSessionResults } from '@/types';\nimport FlashCard from '@/components/FlashCard';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport { FlashcardsSettings } from '@/types';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport FlashcardsCompletionModal from '@/components/modals/FlashcardsCompletionModal';\nimport { SharedModeHeader } from '@/components/common/SharedModeHeader';\nimport styles from './Flashcards.module.css';\n\nconst Flashcards: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n  const { decks, activeDeck, selectDeck } = useDeckStore();\n  const { getSession, saveSession, startNewRound, startMissedCardsRound, getMissedCardIndices } =\n    useFlashcardSessionStore();\n  const { updateDeckProgress } = useProgressStore();\n  const { updateSettings: updateStoredSettings } = useSettingsStore();\n  const isInitialMount = useRef(true);\n\n  // Initialize state from persisted session or defaults\n  const [currentCardIndex, setCurrentCardIndex] = useState(0);\n  const [isFlipped, setIsFlipped] = useState(false);\n  const [frontSides, setFrontSides] = useState(DEFAULT_FRONT_SIDES);\n  const [backSides, setBackSides] = useState(DEFAULT_BACK_SIDES);\n  const [progress, setProgress] = useState<{ [key: number]: 'correct' | 'incorrect' | null }>({});\n  const [showSettings, setShowSettings] = useState(false);\n  const [swipeDirection, setSwipeDirection] = useState<'left' | 'right' | null>(null);\n  const [roundNumber, setRoundNumber] = useState(1);\n  const [cardOrder, setCardOrder] = useState<number[]>([]);\n  const [startTime, setStartTime] = useState(Date.now());\n  const [isMissedCardsRound, setIsMissedCardsRound] = useState(false);\n  const [showCompletionModal, setShowCompletionModal] = useState(false);\n  const [completionResults, setCompletionResults] = useState<FlashcardSessionResults | null>(null);\n  const [progressionMode, setProgressionMode] = useState<'sequential' | 'shuffle' | 'level'>(\n    'shuffle'\n  );\n  const [includeMastered, setIncludeMastered] = useState(true);\n\n  // Load deck and restore session on mount\n  useEffect(() => {\n    if (deckId) {\n      const deck = decks.find(d => d.id === deckId);\n      if (deck) {\n        selectDeck(deckId);\n\n        // Only restore session on initial mount\n        if (isInitialMount.current) {\n          const session = getSession(deckId);\n          if (session) {\n            setCurrentCardIndex(session.currentCardIndex);\n            setProgress(session.progress);\n            setFrontSides(session.frontSides);\n            setBackSides(session.backSides);\n            setRoundNumber(session.roundNumber || 1);\n            setStartTime(session.startTime || Date.now());\n            setIsMissedCardsRound(session.isMissedCardsRound || false);\n            setProgressionMode(session.progressionMode || 'shuffle');\n\n            // Handle includeMastered and card order\n            const sessionIncludeMastered =\n              session.includeMastered !== undefined ? session.includeMastered : true;\n            setIncludeMastered(sessionIncludeMastered);\n\n            // Validate card order against current mastered cards\n            if (session.cardOrder && !session.isMissedCardsRound) {\n              const { getMasteredCards } = useCardMasteryStore.getState();\n              const masteredIndices = getMasteredCards(deckId);\n\n              if (!sessionIncludeMastered && masteredIndices.length > 0) {\n                // Filter out mastered cards from the order\n                const filteredOrder = session.cardOrder.filter(\n                  (idx: number) => !masteredIndices.includes(idx)\n                );\n                setCardOrder(filteredOrder.length > 0 ? filteredOrder : session.cardOrder);\n              } else {\n                setCardOrder(session.cardOrder);\n              }\n            } else {\n              setCardOrder(\n                session.cardOrder || Array.from({ length: deck.content.length }, (_, i) => i)\n              );\n            }\n          } else {\n            // Initialize new session with shuffled cards (excluding mastered if needed)\n            const { getMasteredCards } = useCardMasteryStore.getState();\n            const masteredIndices = getMasteredCards(deckId);\n            let initialIndices = Array.from({ length: deck.content.length }, (_, i) => i);\n\n            // Exclude mastered cards by default for new sessions\n            if (masteredIndices.length > 0) {\n              initialIndices = initialIndices.filter(i => !masteredIndices.includes(i));\n              setIncludeMastered(false);\n            }\n\n            // Shuffle by default\n            const shuffled = [...initialIndices];\n            for (let i = shuffled.length - 1; i > 0; i--) {\n              const j = Math.floor(Math.random() * (i + 1));\n              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n            }\n            setCardOrder(shuffled);\n            setStartTime(Date.now());\n          }\n          isInitialMount.current = false;\n        }\n      } else {\n        navigate('/');\n      }\n    }\n  }, [deckId, decks, selectDeck, navigate, getSession]);\n\n  // Prevent body scrolling on mobile\n  useEffect(() => {\n    document.body.classList.add('no-scroll');\n\n    return () => {\n      document.body.classList.remove('no-scroll');\n    };\n  }, []);\n\n  // Save session whenever progress changes\n  useEffect(() => {\n    if (deckId && !isInitialMount.current) {\n      saveSession({\n        deckId,\n        currentCardIndex,\n        progress,\n        frontSides,\n        backSides,\n        lastAccessed: Date.now(),\n        roundNumber,\n        cardOrder,\n        startTime,\n        isMissedCardsRound,\n        progressionMode,\n        includeMastered,\n      });\n    }\n  }, [\n    deckId,\n    currentCardIndex,\n    progress,\n    frontSides,\n    backSides,\n    saveSession,\n    roundNumber,\n    cardOrder,\n    startTime,\n    isMissedCardsRound,\n    progressionMode,\n    includeMastered,\n  ]);\n\n  // Helper function to create card order based on progression mode\n  const createCardOrder = useCallback(\n    (\n      deck: typeof activeDeck,\n      mode: 'sequential' | 'shuffle' | 'level',\n      excludeMastered: boolean = false\n    ): number[] => {\n      if (!deck || !deckId) return [];\n\n      let indices = Array.from({ length: deck.content.length }, (_, i) => i);\n\n      // Filter out mastered cards if needed\n      if (excludeMastered) {\n        const { getMasteredCards } = useCardMasteryStore.getState();\n        const masteredIndices = getMasteredCards(deckId);\n        indices = indices.filter(i => !masteredIndices.includes(i));\n      }\n\n      switch (mode) {\n        case 'sequential':\n          return indices;\n\n        case 'shuffle':\n          // Fisher-Yates shuffle\n          const shuffled = [...indices];\n          for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n          }\n          return shuffled;\n\n        case 'level':\n          // Sort by level, then by index within each level\n          return indices.sort((a, b) => {\n            const levelDiff = deck.content[a].level - deck.content[b].level;\n            return levelDiff !== 0 ? levelDiff : a - b;\n          });\n\n        default:\n          return indices;\n      }\n    },\n    [deckId]\n  );\n\n  // Define handleDeckCompletion before handleNext since handleNext depends on it\n  const handleDeckCompletion = useCallback(() => {\n    if (!activeDeck || !deckId) return;\n\n    const session = {\n      deckId,\n      currentCardIndex,\n      progress,\n      frontSides,\n      backSides,\n      lastAccessed: Date.now(),\n      roundNumber,\n      cardOrder,\n      startTime,\n      isMissedCardsRound,\n    };\n\n    const missedIndices = getMissedCardIndices(session);\n    const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n    const correctCards = Object.values(progress).filter(p => p === 'correct').length;\n    const incorrectCards = Object.values(progress).filter(p => p === 'incorrect').length;\n\n    // Calculate accuracy based on cards actually answered, not total deck size\n    const cardsAnswered = correctCards + incorrectCards;\n    const accuracy = cardsAnswered > 0 ? (correctCards / cardsAnswered) * 100 : 0;\n\n    const results: FlashcardSessionResults = {\n      deckId,\n      totalCards,\n      correctCards,\n      incorrectCards,\n      accuracy,\n      roundNumber,\n      isComplete: incorrectCards === 0,\n      missedCardIndices: missedIndices,\n      startTime,\n      endTime: Date.now(),\n    };\n\n    setCompletionResults(results);\n    setShowCompletionModal(true);\n\n    // Update progress store with the session results\n    if (deckId) {\n      updateDeckProgress(deckId, 'flashcards', cardsAnswered, correctCards, cardsAnswered);\n    }\n  }, [\n    activeDeck,\n    deckId,\n    currentCardIndex,\n    progress,\n    frontSides,\n    backSides,\n    roundNumber,\n    cardOrder,\n    startTime,\n    isMissedCardsRound,\n    getMissedCardIndices,\n    updateDeckProgress,\n  ]);\n\n  const handleNext = useCallback(() => {\n    if (!activeDeck) return;\n\n    const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n\n    if (currentCardIndex < totalCards - 1) {\n      setCurrentCardIndex(prev => prev + 1);\n      setIsFlipped(false);\n    } else {\n      // Deck completion - show modal\n      handleDeckCompletion();\n    }\n  }, [activeDeck, currentCardIndex, isMissedCardsRound, cardOrder, handleDeckCompletion]);\n\n  const handlePrevious = useCallback(() => {\n    if (currentCardIndex > 0) {\n      setCurrentCardIndex(prev => prev - 1);\n      setIsFlipped(false);\n    }\n  }, [currentCardIndex]);\n\n  const handleFlip = useCallback(() => {\n    setIsFlipped(prev => !prev);\n  }, []);\n\n  const markCard = useCallback(\n    (status: 'correct' | 'incorrect') => {\n      setProgress(prev => ({\n        ...prev,\n        [currentCardIndex]: status,\n      }));\n      setSwipeDirection(status === 'correct' ? 'right' : 'left');\n      setTimeout(() => {\n        handleNext();\n        setSwipeDirection(null);\n      }, 400);\n    },\n    [currentCardIndex, handleNext]\n  );\n\n  const handleContinueWithMissed = useCallback(() => {\n    if (!completionResults || !deckId || !activeDeck) return;\n\n    const missedIndices = completionResults.missedCardIndices;\n\n    // Apply progression mode to missed cards\n    let orderedMissedIndices: number[];\n    if (progressionMode === 'shuffle') {\n      orderedMissedIndices = [...missedIndices];\n      for (let i = orderedMissedIndices.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [orderedMissedIndices[i], orderedMissedIndices[j]] = [\n          orderedMissedIndices[j],\n          orderedMissedIndices[i],\n        ];\n      }\n    } else if (progressionMode === 'level') {\n      orderedMissedIndices = [...missedIndices].sort((a, b) => {\n        const levelDiff = activeDeck.content[a].level - activeDeck.content[b].level;\n        return levelDiff !== 0 ? levelDiff : a - b;\n      });\n    } else {\n      orderedMissedIndices = missedIndices;\n    }\n\n    const newSession = startMissedCardsRound(deckId, orderedMissedIndices);\n\n    // Update local state from new session\n    setCurrentCardIndex(0);\n    setIsFlipped(false);\n    setProgress({});\n    setRoundNumber(newSession.roundNumber);\n    setCardOrder(orderedMissedIndices);\n    setStartTime(newSession.startTime);\n    setIsMissedCardsRound(true);\n    setShowCompletionModal(false);\n    setCompletionResults(null);\n  }, [completionResults, deckId, activeDeck, startMissedCardsRound, progressionMode]);\n\n  const handleStartNewRound = useCallback(() => {\n    if (!deckId || !activeDeck) return;\n\n    const newSession = startNewRound(deckId, activeDeck.content.length);\n    const newOrder = createCardOrder(activeDeck, progressionMode, !includeMastered);\n\n    // Update local state from new session\n    setCurrentCardIndex(0);\n    setIsFlipped(false);\n    setProgress({});\n    setRoundNumber(newSession.roundNumber);\n    setCardOrder(newOrder);\n    setStartTime(newSession.startTime);\n    setIsMissedCardsRound(false);\n    setShowCompletionModal(false);\n    setCompletionResults(null);\n  }, [deckId, activeDeck, startNewRound, createCardOrder, progressionMode, includeMastered]);\n\n  const handleBackToDeck = useCallback(() => {\n    navigate(`/deck/${deckId}`);\n  }, [navigate, deckId]);\n\n  const handleDragEnd = useCallback(\n    (_event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {\n      const threshold = 100;\n      if (Math.abs(info.offset.x) > threshold) {\n        if (info.offset.x > 0) {\n          markCard('correct');\n        } else {\n          markCard('incorrect');\n        }\n      }\n    },\n    [markCard]\n  );\n\n  const updateSettings = useCallback(\n    (settings: FlashcardsSettings) => {\n      const newFrontSides = settings.frontSides || frontSides;\n      const newBackSides = settings.backSides || backSides;\n      const newProgressionMode = settings.progressionMode || progressionMode;\n      const newIncludeMastered =\n        settings.includeMastered !== undefined ? settings.includeMastered : includeMastered;\n\n      setFrontSides(newFrontSides);\n      setBackSides(newBackSides);\n      setIsFlipped(false);\n\n      // Check if we need to reorder cards\n      const shouldReorder =\n        newProgressionMode !== progressionMode || newIncludeMastered !== includeMastered;\n\n      if (shouldReorder && activeDeck && !isMissedCardsRound) {\n        setProgressionMode(newProgressionMode);\n        setIncludeMastered(newIncludeMastered);\n\n        const newOrder = createCardOrder(activeDeck, newProgressionMode, !newIncludeMastered);\n        setCardOrder(newOrder);\n        // Reset to first card when changing settings\n        setCurrentCardIndex(0);\n        setProgress({});\n      } else {\n        setProgressionMode(newProgressionMode);\n        setIncludeMastered(newIncludeMastered);\n      }\n\n      // Save settings to store\n      if (deckId) {\n        updateStoredSettings(deckId, 'flashcards', settings);\n      }\n    },\n    [\n      progressionMode,\n      includeMastered,\n      activeDeck,\n      isMissedCardsRound,\n      createCardOrder,\n      frontSides,\n      backSides,\n      deckId,\n      updateStoredSettings,\n    ]\n  );\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      switch (e.key) {\n        case ' ':\n          e.preventDefault();\n          handleFlip();\n          break;\n        case 'ArrowRight':\n          handleNext();\n          break;\n        case 'ArrowLeft':\n          handlePrevious();\n          break;\n        case '1':\n          markCard('incorrect');\n          break;\n        case '2':\n          markCard('correct');\n          break;\n      }\n    },\n    [handleFlip, handleNext, handlePrevious, markCard]\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  if (!activeDeck) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  // Get the actual card based on the card order (always use cardOrder for proper shuffling)\n  const actualCardIndex = cardOrder.length > 0 ? cardOrder[currentCardIndex] : currentCardIndex;\n  const currentCard = activeDeck.content[actualCardIndex];\n  const totalCards = cardOrder.length > 0 ? cardOrder.length : activeDeck.content.length;\n  const progressPercentage = (Object.keys(progress).length / totalCards) * 100;\n  const correctCount = Object.values(progress).filter(p => p === 'correct').length;\n  const incorrectCount = Object.values(progress).filter(p => p === 'incorrect').length;\n\n  return (\n    <div className={styles.container}>\n      <SharedModeHeader\n        deckName={activeDeck.metadata.deck_name}\n        currentCard={currentCardIndex + 1}\n        totalCards={totalCards}\n        onBackClick={() => {\n          // Session is automatically saved via useEffect\n          navigate(`/deck/${deckId}`);\n        }}\n        onSettingsClick={() => setShowSettings(true)}\n        showSettings={true}\n        subtitle={[\n          isMissedCardsRound ? 'Review' : null,\n          roundNumber > 1 ? `Round ${roundNumber}` : null,\n        ]\n          .filter(Boolean)\n          .join(' ')}\n      />\n\n      <div className={styles.progressSection}>\n        <div className={styles.progressBar}>\n          <div className={styles.progressFill} style={{ width: `${progressPercentage}%` }} />\n        </div>\n        <div className={styles.progressStats}>\n          <span className={styles.incorrectStat}>✗ {incorrectCount}</span>\n          <span className={styles.correctStat}>✓ {correctCount}</span>\n        </div>\n      </div>\n\n      <main className={styles.main}>\n        <AnimatePresence mode=\"wait\">\n          <motion.div\n            key={currentCardIndex}\n            className={styles.cardWrapper}\n            drag=\"x\"\n            dragConstraints={{ left: 0, right: 0 }}\n            dragElastic={1}\n            onDragEnd={handleDragEnd}\n            initial={{ y: window.innerHeight, opacity: 0 }}\n            animate={{\n              y: 0,\n              opacity: 1,\n              x:\n                swipeDirection === 'right'\n                  ? window.innerWidth\n                  : swipeDirection === 'left'\n                    ? -window.innerWidth\n                    : 0,\n              rotate: swipeDirection === 'right' ? 20 : swipeDirection === 'left' ? -20 : 0,\n            }}\n            exit={{\n              opacity: 0,\n              transition: { duration: 0.2 },\n            }}\n            transition={{\n              type: 'spring',\n              stiffness: 300,\n              damping: 30,\n            }}\n          >\n            <FlashCard\n              card={currentCard}\n              isFlipped={isFlipped}\n              onFlip={handleFlip}\n              frontSides={frontSides}\n              backSides={backSides}\n            />\n\n            {/* Swipe indicators */}\n            <div\n              className={`${styles.swipeIndicator} ${styles.incorrect}`}\n              style={{ opacity: swipeDirection === 'left' ? 1 : 0 }}\n            >\n              ✗\n            </div>\n            <div\n              className={`${styles.swipeIndicator} ${styles.correct}`}\n              style={{ opacity: swipeDirection === 'right' ? 1 : 0 }}\n            >\n              ✓\n            </div>\n          </motion.div>\n        </AnimatePresence>\n      </main>\n\n      <div className={styles.controls}>\n        <button\n          className={styles.navButton}\n          onClick={handlePrevious}\n          disabled={currentCardIndex === 0}\n          aria-label=\"Previous card\"\n        >\n          ←\n        </button>\n\n        <div className={styles.actionButtons}>\n          <button\n            className={`${styles.markButton} ${styles.incorrect}`}\n            onClick={() => markCard('incorrect')}\n            aria-label=\"Mark as incorrect\"\n          >\n            ✗ Incorrect\n          </button>\n          <button className={styles.flipButton} onClick={handleFlip} aria-label=\"Flip card\">\n            Flip\n          </button>\n          <button\n            className={`${styles.markButton} ${styles.correct}`}\n            onClick={() => markCard('correct')}\n            aria-label=\"Mark as correct\"\n          >\n            ✓ Correct\n          </button>\n        </div>\n\n        <button\n          className={styles.navButton}\n          onClick={handleNext}\n          disabled={currentCardIndex === totalCards - 1}\n          aria-label=\"Next card\"\n        >\n          →\n        </button>\n      </div>\n\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={() => setShowSettings(false)}\n        deck={activeDeck}\n        mode=\"flashcards\"\n        settings={\n          {\n            frontSides,\n            backSides,\n            progressionMode,\n            includeMastered,\n            enableTimer: false,\n            timerSeconds: 30,\n            enableAudio: false,\n            groupSides: {},\n          } as FlashcardsSettings\n        }\n        onUpdateSettings={(newSettings) => {\n          updateSettings(newSettings as FlashcardsSettings);\n        }}\n      />\n\n      <FlashcardsCompletionModal\n        visible={showCompletionModal}\n        results={completionResults}\n        onContinueWithMissed={handleContinueWithMissed}\n        onStartNewRound={handleStartNewRound}\n        onBackToDeck={handleBackToDeck}\n        onClose={() => setShowCompletionModal(false)}\n      />\n    </div>\n  );\n};\n\nexport default Flashcards;\n"],"names":["DEFAULT_FRONT_SIDES","DEFAULT_BACK_SIDES","SESSION_EXPIRY_MS","useFlashcardSessionStore","create","persist","set","get","sessions","Map","getSession","deckId","session","Date","now","lastAccessed","clearSession","saveSession","state","newSessions","delete","clearOldSessions","forEach","startNewRound","totalCards","existingSession","newSession","currentCardIndex","progress","frontSides","backSides","roundNumber","cardOrder","Array","from","length","_","i","startTime","isMissedCardsRound","progressionMode","includeMastered","startMissedCardsRound","missedCardIndices","shuffled","sort","Math","random","getMissedCardIndices","missedIndices","originalIndex","currentIndex","push","Object","entries","index","status","parseInt","name","storage","getItem","str","localStorage","JSON","parse","setItem","value","serialized","stringify","removeItem","FlashCard","card","isFlipped","onFlip","frontContent","filter","side","map","content","backContent","className","styles","onClick","children","jsxs","motion","div","animate","rotateY","transition","duration","type","stiffness","style","transformStyle","jsx","item","level","FlashcardsCompletionModal","visible","results","onContinueWithMissed","onStartNewRound","onBackToDeck","onClose","accuracyPercentage","round","accuracy","endTime","timeInSeconds","minutes","floor","seconds","hasMissedCards","useEffect","handleKeyDown","e","target","tagName","isContentEditable","hasMissed","key","preventDefault","window","addEventListener","removeEventListener","AnimatePresence","Fragment","initial","opacity","exit","scale","y","damping","incorrectCards","correctCards","toString","padStart","title","Flashcards","useParams","navigate","useNavigate","decks","activeDeck","selectDeck","useDeckStore","updateDeckProgress","useProgressStore","updateSettings","updateStoredSettings","useSettingsStore","isInitialMount","useRef","setCurrentCardIndex","useState","setIsFlipped","setFrontSides","setBackSides","setProgress","showSettings","setShowSettings","swipeDirection","setSwipeDirection","setRoundNumber","setCardOrder","setStartTime","setIsMissedCardsRound","showCompletionModal","setShowCompletionModal","completionResults","setCompletionResults","setProgressionMode","setIncludeMastered","deck","find","d","id","current","sessionIncludeMastered","getMasteredCards","useCardMasteryStore","getState","masteredIndices","filteredOrder","idx","includes","initialIndices","j","document","body","classList","add","remove","createCardOrder","useCallback","mode","excludeMastered","indices","a","b","levelDiff","handleDeckCompletion","values","p","cardsAnswered","isComplete","handleNext","prev","handlePrevious","handleFlip","markCard","setTimeout","handleContinueWithMissed","orderedMissedIndices","handleStartNewRound","newOrder","handleBackToDeck","handleDragEnd","_event","info","abs","offset","x","settings","newFrontSides","newBackSides","newProgressionMode","newIncludeMastered","actualCardIndex","currentCard","progressPercentage","keys","correctCount","incorrectCount","SharedModeHeader","deckName","metadata","deck_name","onBackClick","onSettingsClick","subtitle","Boolean","join","width","drag","dragConstraints","left","right","dragElastic","onDragEnd","innerHeight","innerWidth","rotate","disabled","UnifiedSettings","enableTimer","timerSeconds","enableAudio","groupSides","onUpdateSettings","newSettings"],"mappings":"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"}