{"version":3,"file":"Read-CyFAdDw2.js","sources":["../../src/store/readStore.ts","../../src/components/read/ReadDialoguePicker.tsx","../../src/utils/sentenceTranslation.ts","../../src/utils/wordAlignments.ts","../../src/components/read/SentenceTranslation.tsx","../../src/utils/tokenize.ts","../../src/components/read/ReadToken.tsx","../../src/components/read/AlignedReadLine.tsx","../../src/components/read/EnhancedReadLine.tsx","../../src/components/read/ReadControls.tsx","../../src/components/read/ReadProgress.tsx","../../src/pages/Read.tsx"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { ReadModeSettings } from '@/types';\n\ninterface ReadProgress {\n  dialogueId: string;\n  lineIndex: number;\n  tokenIndex: number;\n  completedTokens: Set<string>; // dialogueId:lineIndex:tokenIndex\n  masteredTokens: Set<string>;\n}\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface ReadStore {\n  // Progress tracking\n  progress: Record<string, ReadProgress>; // deckId -> progress\n\n  // Current session\n  session: ReadSessionState | null;\n\n  // Settings\n  settings: ReadModeSettings;\n\n  // Actions\n  initSession: (deckId: string, dialogueId: string) => void;\n  setCurrentDialogue: (dialogueId: string) => void;\n  setCurrentLine: (lineIndex: number) => void;\n  setCurrentToken: (tokenIndex: number) => void;\n  markTokenComplete: (dialogueId: string, lineIndex: number, tokenIndex: number) => void;\n  markTokenMastered: (dialogueId: string, lineIndex: number, tokenIndex: number) => void;\n  togglePinyin: () => void;\n  toggleTranslation: () => void;\n  updateSettings: (settings: Partial<ReadModeSettings>) => void;\n  recordAnswer: (correct: boolean, responseTime: number) => void;\n  clearSession: () => void;\n  resetProgress: (deckId: string) => void;\n  getProgress: (deckId: string) => ReadProgress | null;\n}\n\nconst defaultSettings: ReadModeSettings = {\n  answerType: 'free_text',\n  checkMode: 'wait',\n  translationDirection: { from: 'a', to: 'c' },\n  optionsCount: 4,\n  showPinyinDefault: false,\n  multipleChoiceDifficulty: 'medium',\n  unit: 'character',\n  translationMode: 'sentence',\n  accuracyThreshold: 70,\n  showWordHints: true\n};\n\nexport const useReadStore = create<ReadStore>()(\n  persist(\n    (set, get) => ({\n      progress: {},\n      session: null,\n      settings: defaultSettings,\n\n      initSession: (deckId: string, dialogueId: string) => {\n        set(state => ({\n          session: {\n            deckId,\n            currentDialogueId: dialogueId,\n            currentLineIndex: 0,\n            currentTokenIndex: 0,\n            showPinyin: state.settings.showPinyinDefault,\n            showTranslation: false,\n            correctCount: 0,\n            incorrectCount: 0,\n            startTime: Date.now(),\n            responseStartTime: Date.now(),\n            responseTimes: []\n          }\n        }));\n      },\n\n      setCurrentDialogue: (dialogueId: string) => {\n        set(state => {\n          if (!state.session) return state;\n\n          // Save progress for current deck\n          const deckId = state.session.deckId;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                dialogueId\n              }\n            },\n            session: {\n              ...state.session,\n              currentDialogueId: dialogueId,\n              currentLineIndex: 0,\n              currentTokenIndex: 0\n            }\n          };\n        });\n      },\n\n      setCurrentLine: (lineIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const dialogueId = state.session.currentDialogueId || '';\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                lineIndex\n              }\n            },\n            session: {\n              ...state.session,\n              currentLineIndex: lineIndex,\n              currentTokenIndex: 0\n            }\n          };\n        });\n      },\n\n      setCurrentToken: (tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const dialogueId = state.session.currentDialogueId || '';\n          const lineIndex = state.session.currentLineIndex;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                tokenIndex\n              }\n            },\n            session: {\n              ...state.session,\n              currentTokenIndex: tokenIndex,\n              responseStartTime: Date.now()\n            }\n          };\n        });\n      },\n\n      markTokenComplete: (dialogueId: string, lineIndex: number, tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const tokenKey = `${dialogueId}:${lineIndex}:${tokenIndex}`;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          const newCompletedTokens = new Set(currentProgress.completedTokens);\n          newCompletedTokens.add(tokenKey);\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                completedTokens: newCompletedTokens\n              }\n            }\n          };\n        });\n      },\n\n      markTokenMastered: (dialogueId: string, lineIndex: number, tokenIndex: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          const deckId = state.session.deckId;\n          const tokenKey = `${dialogueId}:${lineIndex}:${tokenIndex}`;\n          const currentProgress = state.progress[deckId] || {\n            dialogueId,\n            lineIndex: 0,\n            tokenIndex: 0,\n            completedTokens: new Set(),\n            masteredTokens: new Set()\n          };\n\n          const newMasteredTokens = new Set(currentProgress.masteredTokens);\n          newMasteredTokens.add(tokenKey);\n\n          const newCompletedTokens = new Set(currentProgress.completedTokens);\n          newCompletedTokens.add(tokenKey);\n\n          return {\n            progress: {\n              ...state.progress,\n              [deckId]: {\n                ...currentProgress,\n                completedTokens: newCompletedTokens,\n                masteredTokens: newMasteredTokens\n              }\n            }\n          };\n        });\n      },\n\n      togglePinyin: () => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              showPinyin: !state.session.showPinyin\n            }\n          };\n        });\n      },\n\n      toggleTranslation: () => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              showTranslation: !state.session.showTranslation\n            }\n          };\n        });\n      },\n\n      updateSettings: (settings: Partial<ReadModeSettings>) => {\n        set(state => ({\n          settings: {\n            ...state.settings,\n            ...settings\n          },\n          // Update session if showPinyinDefault changes\n          session: state.session && settings.showPinyinDefault !== undefined\n            ? {\n                ...state.session,\n                showPinyin: settings.showPinyinDefault\n              }\n            : state.session\n        }));\n      },\n\n      recordAnswer: (correct: boolean, responseTime: number) => {\n        set(state => {\n          if (!state.session) return state;\n\n          return {\n            session: {\n              ...state.session,\n              correctCount: state.session.correctCount + (correct ? 1 : 0),\n              incorrectCount: state.session.incorrectCount + (correct ? 0 : 1),\n              responseTimes: [...state.session.responseTimes, responseTime]\n            }\n          };\n        });\n      },\n\n      clearSession: () => {\n        set({ session: null });\n      },\n\n      resetProgress: (deckId: string) => {\n        set(state => {\n          const newProgress = { ...state.progress };\n          delete newProgress[deckId];\n          return { progress: newProgress };\n        });\n      },\n\n      getProgress: (deckId: string) => {\n        return get().progress[deckId] || null;\n      }\n    }),\n    {\n      name: 'read-store',\n      version: 2,\n      partialize: state => ({\n        progress: state.progress,\n        settings: state.settings\n      }),\n      migrate: (persistedState: any, version: number) => {\n        if (version < 2) {\n          // Add new sentence mode settings to existing persisted state\n          return {\n            ...persistedState,\n            settings: {\n              ...defaultSettings,\n              ...persistedState.settings,\n              translationMode: persistedState.settings?.translationMode || 'sentence',\n              accuracyThreshold: persistedState.settings?.accuracyThreshold || 70,\n              showWordHints: persistedState.settings?.showWordHints !== false\n            }\n          };\n        }\n        return persistedState;\n      }\n    }\n  )\n);","import { FC, useMemo } from 'react';\nimport { Deck } from '@/types';\nimport { Button } from '@/components/ui/Button';\n// CheckIcon inline SVG\nimport styles from './ReadDialoguePicker.module.css';\n\ninterface ReadProgress {\n  dialogueId: string;\n  lineIndex: number;\n  tokenIndex: number;\n  completedTokens: Set<string>;\n  masteredTokens: Set<string>;\n}\n\ninterface Props {\n  deck: Deck;\n  selectedDialogueId: string | null;\n  onSelectDialogue: (dialogueId: string) => void;\n  progress: ReadProgress | null;\n}\n\nexport const ReadDialoguePicker: FC<Props> = ({\n  deck,\n  selectedDialogueId,\n  onSelectDialogue,\n  progress\n}) => {\n  // Calculate progress for each dialogue\n  const dialogueProgress = useMemo(() => {\n    if (!deck.reading) return {};\n\n    const result: Record<string, { completed: number; total: number }> = {};\n\n    Object.entries(deck.reading.dialogues).forEach(([dialogueId, dialogue]) => {\n      const totalTokens = dialogue.lines.reduce((acc, line) => {\n        // Count tokens based on available sides\n        let tokenCount = 0;\n        if (line.a) tokenCount++;\n        if (line.b) tokenCount++;\n        if (line.c) tokenCount++;\n        return acc + tokenCount;\n      }, 0);\n\n      const completedTokens = progress?.completedTokens\n        ? Array.from(progress.completedTokens).filter(key =>\n            key.startsWith(`${dialogueId}:`)\n          ).length\n        : 0;\n\n      result[dialogueId] = {\n        completed: completedTokens,\n        total: totalTokens\n      };\n    });\n\n    return result;\n  }, [deck, progress]);\n\n  if (!deck.reading) return null;\n\n  const dialogueEntries = Object.entries(deck.reading.dialogues);\n\n  return (\n    <div className={styles.container}>\n      <h3 className={styles.title}>Dialogues</h3>\n      <div className={styles.dialogueList}>\n        {dialogueEntries.map(([dialogueId, dialogue]) => {\n          const isSelected = selectedDialogueId === dialogueId;\n          const dialogueStats = dialogueProgress[dialogueId];\n          const progressPercentage = dialogueStats\n            ? (dialogueStats.completed / dialogueStats.total) * 100\n            : 0;\n\n          // Create a friendly display name\n          const displayName = dialogueId\n            .replace(/dialogue(\\d+)/, 'Dialogue $1')\n            .replace(/_/g, ' ')\n            .replace(/\\b\\w/g, l => l.toUpperCase());\n\n          return (\n            <Button\n              key={dialogueId}\n              variant={isSelected ? 'primary' : 'secondary'}\n              className={`${styles.dialogueButton} ${isSelected ? styles.selected : ''}`}\n              onClick={() => onSelectDialogue(dialogueId)}\n            >\n              <div className={styles.dialogueContent}>\n                <div className={styles.dialogueHeader}>\n                  <span className={styles.dialogueName}>{displayName}</span>\n                  {progressPercentage === 100 && (\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" className={styles.completeIcon}>\n                      <path d=\"M20 6L9 17L4 12\" />\n                    </svg>\n                  )}\n                </div>\n                <div className={styles.dialogueInfo}>\n                  <span className={styles.lineCount}>\n                    {dialogue.lines.length} lines\n                  </span>\n                  {dialogueStats && dialogueStats.completed > 0 && (\n                    <span className={styles.progress}>\n                      {dialogueStats.completed}/{dialogueStats.total} tokens\n                    </span>\n                  )}\n                </div>\n                {progressPercentage > 0 && progressPercentage < 100 && (\n                  <div className={styles.progressBar}>\n                    <div\n                      className={styles.progressFill}\n                      style={{ width: `${progressPercentage}%` }}\n                    />\n                  </div>\n                )}\n              </div>\n            </Button>\n          );\n        })}\n      </div>\n    </div>\n  );\n};","import { SentenceTranslationResult, ReadingLine } from '@/types';\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));\n\n  for (let i = 0; i <= a.length; i += 1) {\n    matrix[0][i] = i;\n  }\n\n  for (let j = 0; j <= b.length; j += 1) {\n    matrix[j][0] = j;\n  }\n\n  for (let j = 1; j <= b.length; j += 1) {\n    for (let i = 1; i <= a.length; i += 1) {\n      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;\n      matrix[j][i] = Math.min(\n        matrix[j][i - 1] + 1, // deletion\n        matrix[j - 1][i] + 1, // insertion\n        matrix[j - 1][i - 1] + indicator // substitution\n      );\n    }\n  }\n\n  return matrix[b.length][a.length];\n}\n\n/**\n * Calculate similarity percentage between two strings\n */\nfunction calculateSimilarity(str1: string, str2: string): number {\n  const normalizedStr1 = normalizeText(str1);\n  const normalizedStr2 = normalizeText(str2);\n\n  if (normalizedStr1 === normalizedStr2) return 100;\n  if (normalizedStr1.length === 0 && normalizedStr2.length === 0) return 100;\n  if (normalizedStr1.length === 0 || normalizedStr2.length === 0) return 0;\n\n  const maxLength = Math.max(normalizedStr1.length, normalizedStr2.length);\n  const distance = levenshteinDistance(normalizedStr1, normalizedStr2);\n\n  return Math.max(0, (maxLength - distance) / maxLength * 100);\n}\n\n/**\n * Normalize text for comparison (lowercase, trim, remove extra spaces)\n */\nfunction normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[.,!?;:()\\[\\]{}\"'`~@#$%^&*+=\\-\\/\\\\|<>]/g, '') // Remove punctuation\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n\n/**\n * Extract individual words from text for word-level matching\n */\nfunction extractWords(text: string): string[] {\n  return normalizeText(text)\n    .split(/\\s+/)\n    .filter(word => word.length > 0);\n}\n\n/**\n * Calculate word-level matches between user answer and correct answer\n */\nfunction calculateWordMatches(userAnswer: string, correctAnswer: string): Array<{\n  word: string;\n  matched: boolean;\n  similarity?: number;\n}> {\n  const userWords = extractWords(userAnswer);\n  const correctWords = extractWords(correctAnswer);\n  const matchedCorrectWords = new Set<string>();\n\n  return userWords.map(userWord => {\n    // Find best match among correct words\n    let bestMatch: string | null = null;\n    let bestSimilarity = 0;\n\n    correctWords.forEach(correctWord => {\n      if (matchedCorrectWords.has(correctWord)) return; // Already matched\n\n      const similarity = calculateSimilarity(userWord, correctWord);\n      if (similarity > bestSimilarity && similarity >= 70) { // 70% threshold for word matching\n        bestMatch = correctWord;\n        bestSimilarity = similarity;\n      }\n    });\n\n    if (bestMatch) {\n      matchedCorrectWords.add(bestMatch);\n      return {\n        word: userWord,\n        matched: true,\n        similarity: bestSimilarity\n      };\n    }\n\n    return {\n      word: userWord,\n      matched: false\n    };\n  });\n}\n\n/**\n * Generate alternative answers from word alignments\n */\nfunction generateAlternativeAnswers(line: ReadingLine, targetSide: string): string[] {\n  const alternatives: string[] = [];\n\n  // Add the main target side text\n  const mainText = line[targetSide as keyof ReadingLine] as string;\n  if (mainText) {\n    alternatives.push(mainText);\n  }\n\n  // Generate alternatives from word alignments if available\n  if (line.wordAlignments && targetSide === 'c') { // English translations\n    const words = line.wordAlignments\n      .filter(alignment => alignment.english.trim().length > 0)\n      .map(alignment => alignment.english.trim());\n\n    if (words.length > 0) {\n      alternatives.push(words.join(' '));\n    }\n  }\n\n  return [...new Set(alternatives)]; // Remove duplicates\n}\n\n/**\n * Check sentence translation and provide detailed feedback\n */\nexport function checkSentenceTranslation(\n  userAnswer: string,\n  line: ReadingLine,\n  targetSide: string,\n  accuracyThreshold: number = 70\n): SentenceTranslationResult {\n  const alternatives = generateAlternativeAnswers(line, targetSide);\n  const correctAnswer = alternatives[0] || '';\n\n  if (!correctAnswer) {\n    return {\n      userAnswer,\n      correctAnswer: '',\n      accuracy: 0,\n      isCorrect: false,\n      suggestions: []\n    };\n  }\n\n  // Calculate accuracy against all alternatives, use the best score\n  let bestAccuracy = 0;\n  let bestCorrectAnswer = correctAnswer;\n\n  alternatives.forEach(alternative => {\n    const accuracy = calculateSimilarity(userAnswer, alternative);\n    if (accuracy > bestAccuracy) {\n      bestAccuracy = accuracy;\n      bestCorrectAnswer = alternative;\n    }\n  });\n\n  const wordMatches = calculateWordMatches(userAnswer, bestCorrectAnswer);\n  const isCorrect = bestAccuracy >= accuracyThreshold;\n\n  return {\n    userAnswer,\n    correctAnswer: bestCorrectAnswer,\n    accuracy: Math.round(bestAccuracy),\n    isCorrect,\n    wordMatches,\n    suggestions: alternatives.slice(1) // Alternative answers excluding the best match\n  };\n}\n\n/**\n * Generate multiple choice options for sentence translation\n */\nexport function generateSentenceMultipleChoice(\n  line: ReadingLine,\n  targetSide: string,\n  allLines: ReadingLine[],\n  optionsCount: number = 4,\n  difficulty: 'easy' | 'medium' | 'hard' = 'medium'\n): string[] {\n  const correctAnswer = line[targetSide as keyof ReadingLine] as string;\n  if (!correctAnswer) return [];\n\n  const options = [correctAnswer];\n  const usedAnswers = new Set([normalizeText(correctAnswer)]);\n\n  // Generate distractors based on difficulty\n  const potentialDistractors: string[] = [];\n\n  if (difficulty === 'easy') {\n    // Use other sides from the same line\n    Object.keys(line).forEach(side => {\n      if (side !== targetSide && typeof line[side as keyof ReadingLine] === 'string') {\n        const text = line[side as keyof ReadingLine] as string;\n        if (text && !usedAnswers.has(normalizeText(text))) {\n          potentialDistractors.push(text);\n        }\n      }\n    });\n  }\n\n  // Add distractors from other lines regardless of difficulty\n  allLines.forEach(otherLine => {\n    if (otherLine === line) return;\n\n    const text = otherLine[targetSide as keyof ReadingLine] as string;\n    if (text && !usedAnswers.has(normalizeText(text))) {\n      potentialDistractors.push(text);\n    }\n  });\n\n  // Shuffle and select distractors\n  const shuffledDistractors = potentialDistractors\n    .sort(() => Math.random() - 0.5)\n    .slice(0, optionsCount - 1);\n\n  options.push(...shuffledDistractors);\n\n  // Shuffle all options\n  return options.sort(() => Math.random() - 0.5);\n}\n\n/**\n * Get hint text for a specific Chinese word using word alignments\n */\nexport function getWordHint(\n  line: ReadingLine,\n  chineseWord: string,\n  targetSide: string\n): { pinyin?: string; translation?: string } | null {\n  if (!line.wordAlignments) return null;\n\n  const alignment = line.wordAlignments.find(\n    alignment => alignment.chinese === chineseWord\n  );\n\n  if (!alignment) return null;\n\n  const result: { pinyin?: string; translation?: string } = {};\n\n  if (alignment.pinyin && alignment.pinyin.trim()) {\n    result.pinyin = alignment.pinyin;\n  }\n\n  if (targetSide === 'c' && alignment.english && alignment.english.trim()) {\n    result.translation = alignment.english;\n  }\n\n  return Object.keys(result).length > 0 ? result : null;\n}","import { ReadingLine } from '@/types';\n\nexport interface AlignedToken {\n  chinese: string;\n  pinyin: string;\n  english: string;\n  index: number;\n}\n\n/**\n * Extracts aligned tokens from wordAlignments data\n * This provides a 1:1 mapping between Chinese, pinyin, and English tokens\n */\nexport function extractAlignedTokens(line: ReadingLine): AlignedToken[] {\n  if (!line.wordAlignments || line.wordAlignments.length === 0) {\n    return [];\n  }\n\n  return line.wordAlignments.map((alignment, index) => ({\n    chinese: alignment.chinese,\n    pinyin: alignment.pinyin,\n    english: alignment.english,\n    index\n  }));\n}\n\n/**\n * Checks if a line has word alignment data available\n */\nexport function hasWordAlignments(line: ReadingLine): boolean {\n  return Boolean(line.wordAlignments && line.wordAlignments.length > 0);\n}\n\n/**\n * Gets the aligned translation for a specific Chinese token\n */\nexport function getAlignedTranslation(\n  line: ReadingLine,\n  tokenIndex: number\n): { pinyin: string; english: string } | null {\n  if (!hasWordAlignments(line) || !line.wordAlignments) {\n    return null;\n  }\n\n  const alignment = line.wordAlignments[tokenIndex];\n  if (!alignment) {\n    return null;\n  }\n\n  return {\n    pinyin: alignment.pinyin,\n    english: alignment.english\n  };\n}\n\n/**\n * Finds the token index for a given Chinese text\n */\nexport function findTokenIndex(line: ReadingLine, chineseText: string): number {\n  if (!hasWordAlignments(line) || !line.wordAlignments) {\n    return -1;\n  }\n\n  return line.wordAlignments.findIndex(\n    alignment => alignment.chinese === chineseText\n  );\n}\n\n/**\n * Creates a combined display text for word-by-word reading\n * This shows Chinese with hover/tap for translations\n */\nexport function createInteractiveTokens(line: ReadingLine): AlignedToken[] {\n  const tokens = extractAlignedTokens(line);\n\n  // Filter out empty English translations (punctuation, particles, etc.)\n  return tokens.map(token => ({\n    ...token,\n    // Mark tokens with empty English as non-interactive\n    english: token.english.trim() || ''\n  }));\n}","import { FC, useState, useCallback, useMemo, useEffect } from 'react';\nimport { ReadingLine, ReadModeSettings, SentenceTranslationResult } from '@/types';\nimport { checkSentenceTranslation, generateSentenceMultipleChoice, getWordHint } from '@/utils/sentenceTranslation';\nimport { hasWordAlignments, extractAlignedTokens } from '@/utils/wordAlignments';\nimport { Button } from '@/components/ui/Button';\nimport styles from './SentenceTranslation.module.css';\n\ninterface Props {\n  line: ReadingLine;\n  allLines: ReadingLine[]; // For generating MC distractors\n  settings: ReadModeSettings;\n  onAnswer: (result: SentenceTranslationResult) => void;\n  onSkip?: () => void;\n  showResult?: boolean;\n  disabled?: boolean;\n}\n\nexport const SentenceTranslation: FC<Props> = ({\n  line,\n  allLines,\n  settings,\n  onAnswer,\n  onSkip,\n  showResult = false,\n  disabled = false\n}) => {\n  const [userAnswer, setUserAnswer] = useState('');\n  const [selectedOption, setSelectedOption] = useState<string | null>(null);\n  const [result, setResult] = useState<SentenceTranslationResult | null>(null);\n  // const [showHints, setShowHints] = useState(false); // Will be used for hint toggling\n\n  // Get source and target text\n  const sourceText = line[settings.translationDirection.from] || '';\n  // const targetText = line[settings.translationDirection.to] || ''; // Used in checking\n\n  // Generate multiple choice options\n  const mcOptions = useMemo(() => {\n    if (settings.answerType === 'multiple_choice') {\n      return generateSentenceMultipleChoice(\n        line,\n        settings.translationDirection.to,\n        allLines,\n        settings.optionsCount || 4,\n        settings.multipleChoiceDifficulty || 'medium'\n      );\n    }\n    return [];\n  }, [line, allLines, settings]);\n\n  // Check if word alignments are available for hints\n  const hasAlignments = useMemo(() => hasWordAlignments(line), [line]);\n  const alignedTokens = useMemo(() => {\n    return hasAlignments ? extractAlignedTokens(line) : [];\n  }, [line, hasAlignments]);\n\n  // Handle answer submission\n  const handleSubmit = useCallback(() => {\n    if (disabled || result) return;\n\n    const answer = settings.answerType === 'multiple_choice' ? selectedOption || '' : userAnswer;\n    const translationResult = checkSentenceTranslation(\n      answer,\n      line,\n      settings.translationDirection.to,\n      settings.accuracyThreshold || 70\n    );\n\n    setResult(translationResult);\n    onAnswer(translationResult);\n  }, [userAnswer, selectedOption, settings, line, onAnswer, disabled, result]);\n\n  // Handle multiple choice selection\n  const handleOptionSelect = useCallback((option: string) => {\n    if (disabled || result) return;\n    setSelectedOption(option);\n\n    if (settings.checkMode === 'live') {\n      // Auto-submit on selection for live mode\n      setTimeout(() => {\n        const translationResult = checkSentenceTranslation(\n          option,\n          line,\n          settings.translationDirection.to,\n          settings.accuracyThreshold || 70\n        );\n        setResult(translationResult);\n        onAnswer(translationResult);\n      }, 100);\n    }\n  }, [settings, line, onAnswer, disabled, result]);\n\n  // Handle free text input\n  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (disabled || result) return;\n    setUserAnswer(e.target.value);\n\n    if (settings.checkMode === 'live' && e.target.value.trim()) {\n      // Debounced live checking could go here\n    }\n  }, [settings, disabled, result]);\n\n  // Handle key press for submission\n  const handleKeyPress = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit();\n    }\n  }, [handleSubmit]);\n\n  // Word hint functionality\n  const handleWordClick = useCallback((chineseWord: string) => {\n    if (!settings.showWordHints || !hasAlignments) return;\n\n    const hint = getWordHint(line, chineseWord, settings.translationDirection.to);\n    if (hint) {\n      // You could show this in a tooltip or temporary display\n      console.log('Word hint:', chineseWord, hint);\n    }\n  }, [line, settings, hasAlignments]);\n\n  // Reset when line changes\n  useEffect(() => {\n    setUserAnswer('');\n    setSelectedOption(null);\n    setResult(null);\n    // setShowHints(false); // Will reset hint state when implemented\n  }, [line]);\n\n  const canSubmit = settings.answerType === 'multiple_choice'\n    ? selectedOption !== null\n    : userAnswer.trim().length > 0;\n\n  return (\n    <div className={styles.container}>\n      {/* Source text with word hints */}\n      <div className={styles.sourceSection}>\n        <div className={styles.sectionLabel}>\n          Translate this sentence:\n        </div>\n        <div className={styles.sourceText}>\n          {hasAlignments && settings.showWordHints ? (\n            <div className={styles.interactiveSource}>\n              <div className={styles.wordTokensContainer}>\n                {alignedTokens.map((token, index) => (\n                  <span\n                    key={index}\n                    className={`${styles.wordToken} ${token.english ? styles.clickable : styles.static}`}\n                    onClick={() => handleWordClick(token.chinese)}\n                    title={token.english ? `${token.pinyin} - ${token.english}` : undefined}\n                  >\n                    {token.chinese}\n                  </span>\n                ))}\n              </div>\n              <div className={styles.hintText}>\n                Tap words for hints\n              </div>\n            </div>\n          ) : (\n            <div className={styles.staticSource}>{sourceText}</div>\n          )}\n        </div>\n      </div>\n\n      {/* Answer input section */}\n      <div className={styles.answerSection}>\n        <div className={styles.sectionLabel}>\n          Your translation:\n        </div>\n\n        {settings.answerType === 'free_text' ? (\n          <div className={styles.freeTextSection}>\n            <textarea\n              className={`${styles.textInput} ${result ? styles.submitted : ''}`}\n              value={userAnswer}\n              onChange={handleTextChange}\n              onKeyPress={handleKeyPress}\n              placeholder=\"Type your translation here...\"\n              disabled={disabled || !!result}\n              rows={3}\n            />\n          </div>\n        ) : (\n          <div className={styles.multipleChoiceSection}>\n            {mcOptions.map((option, index) => (\n              <button\n                key={index}\n                className={`${styles.option} ${\n                  selectedOption === option ? styles.selected : ''\n                } ${result ? (\n                  option === result.correctAnswer ? styles.correct :\n                  selectedOption === option ? styles.incorrect : ''\n                ) : ''}`}\n                onClick={() => handleOptionSelect(option)}\n                disabled={disabled || !!result}\n              >\n                <span className={styles.optionLetter}>\n                  {String.fromCharCode(65 + index)}\n                </span>\n                <span className={styles.optionText}>{option}</span>\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Action buttons */}\n      {!result && (\n        <div className={styles.actions}>\n          {settings.checkMode === 'wait' && (\n            <Button\n              variant=\"primary\"\n              onClick={handleSubmit}\n              disabled={!canSubmit || disabled}\n              className={styles.submitButton}\n            >\n              Check Answer\n            </Button>\n          )}\n          {onSkip && (\n            <Button\n              variant=\"secondary\"\n              onClick={onSkip}\n              disabled={disabled}\n              className={styles.skipButton}\n            >\n              Skip\n            </Button>\n          )}\n        </div>\n      )}\n\n      {/* Results display */}\n      {result && showResult && (\n        <div className={styles.resultSection}>\n          <div className={`${styles.resultHeader} ${result.isCorrect ? styles.correct : styles.incorrect}`}>\n            <div className={styles.accuracyScore}>\n              {result.accuracy}% accuracy\n            </div>\n            <div className={styles.resultStatus}>\n              {result.isCorrect ? 'Correct!' : 'Needs improvement'}\n            </div>\n          </div>\n\n          {!result.isCorrect && (\n            <div className={styles.correctAnswer}>\n              <div className={styles.correctLabel}>Correct answer:</div>\n              <div className={styles.correctText}>{result.correctAnswer}</div>\n            </div>\n          )}\n\n          {result.wordMatches && result.wordMatches.length > 0 && (\n            <div className={styles.wordAnalysis}>\n              <div className={styles.analysisLabel}>Word analysis:</div>\n              <div className={styles.wordMatches}>\n                {result.wordMatches.map((match, index) => (\n                  <span\n                    key={index}\n                    className={`${styles.wordMatch} ${match.matched ? styles.matched : styles.unmatched}`}\n                    title={match.similarity ? `${Math.round(match.similarity)}% match` : undefined}\n                  >\n                    {match.word}\n                  </span>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {result.suggestions && result.suggestions.length > 0 && (\n            <div className={styles.suggestions}>\n              <div className={styles.suggestionsLabel}>Alternative answers:</div>\n              <div className={styles.suggestionsList}>\n                {result.suggestions.map((suggestion, index) => (\n                  <div key={index} className={styles.suggestion}>\n                    {suggestion}\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};","import { SideId, ReadingLine, ReadingTokenizationConfig, WordAlignment } from '@/types';\n\nexport interface Token {\n  text: string;\n  start: number;\n  end: number;\n}\n\nexport type LineTokens = Partial<Record<SideId, Token[]>>;\n\n// Default tokenization configuration\nconst DEFAULT_TOKENIZATION: ReadingTokenizationConfig = {\n  unit: {\n    a: 'character',\n    b: 'space',\n    c: 'space',\n    d: undefined,\n    e: undefined,\n    f: undefined\n  },\n  preservePunctuation: true\n};\n\n// Check if character is CJK (Chinese, Japanese, Korean)\nconst isCJKCharacter = (char: string): boolean => {\n  const code = char.charCodeAt(0);\n  return (\n    (code >= 0x4e00 && code <= 0x9fff) || // CJK Unified Ideographs\n    (code >= 0x3400 && code <= 0x4dbf) || // CJK Extension A\n    (code >= 0x20000 && code <= 0x2a6df) || // CJK Extension B\n    (code >= 0x2a700 && code <= 0x2b73f) || // CJK Extension C\n    (code >= 0x2b740 && code <= 0x2b81f) || // CJK Extension D\n    (code >= 0x3040 && code <= 0x309f) || // Hiragana\n    (code >= 0x30a0 && code <= 0x30ff) || // Katakana\n    (code >= 0xac00 && code <= 0xd7af) // Hangul Syllables\n  );\n};\n\n// Tokenize by character\nconst tokenizeByCharacter = (text: string, preservePunctuation: boolean): Token[] => {\n  const tokens: Token[] = [];\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n\n    // Skip or include punctuation based on settings\n    if (!preservePunctuation && /\\s|[.,!?;:]/.test(char)) {\n      continue;\n    }\n\n    // Skip whitespace for character tokenization\n    if (/\\s/.test(char)) {\n      continue;\n    }\n\n    tokens.push({\n      text: char,\n      start: i,\n      end: i + 1\n    });\n  }\n\n  return tokens;\n};\n\n// Tokenize by word (space-separated)\nconst tokenizeByWord = (text: string, preservePunctuation: boolean): Token[] => {\n  const tokens: Token[] = [];\n  let currentWord = '';\n  let wordStart = 0;\n\n  for (let i = 0; i <= text.length; i++) {\n    const char = text[i];\n\n    if (i === text.length || /\\s/.test(char)) {\n      if (currentWord) {\n        // Remove trailing punctuation if needed\n        let wordText = currentWord;\n        if (!preservePunctuation) {\n          wordText = wordText.replace(/[.,!?;:]+$/, '');\n        }\n\n        if (wordText) {\n          tokens.push({\n            text: wordText,\n            start: wordStart,\n            end: wordStart + wordText.length\n          });\n        }\n\n        currentWord = '';\n      }\n      wordStart = i + 1;\n    } else {\n      if (currentWord === '') {\n        wordStart = i;\n      }\n      currentWord += char;\n    }\n  }\n\n  return tokens;\n};\n\n// Tokenize by space (keep spaces as separators)\nconst tokenizeBySpace = (text: string, preservePunctuation: boolean): Token[] => {\n  return tokenizeByWord(text, preservePunctuation);\n};\n\n// Smart tokenization - detect CJK for character-based, otherwise word-based\nconst tokenizeSmart = (text: string, preservePunctuation: boolean): Token[] => {\n  // Check if text contains significant CJK characters\n  const totalChars = text.replace(/\\s/g, '').length;\n  const cjkChars = Array.from(text).filter(isCJKCharacter).length;\n\n  // If more than 30% CJK, use character tokenization\n  if (cjkChars > 0 && cjkChars / totalChars > 0.3) {\n    return tokenizeByCharacter(text, preservePunctuation);\n  }\n\n  // Otherwise use word tokenization\n  return tokenizeByWord(text, preservePunctuation);\n};\n\n// Main tokenization function\nexport const tokenizeLine = (\n  line: ReadingLine,\n  config?: ReadingTokenizationConfig\n): LineTokens => {\n  const tokenConfig = config || DEFAULT_TOKENIZATION;\n\n  // If wordAlignments exist, use them for precise alignment\n  if (line.wordAlignments && line.wordAlignments.length > 0) {\n    return tokenizeWithWordAlignments(line.wordAlignments);\n  }\n\n  // Fallback to original tokenization method\n  const result: LineTokens = {};\n  const sideIds: SideId[] = ['a', 'b', 'c', 'd', 'e', 'f'];\n\n  for (const side of sideIds) {\n    const text = line[side];\n    if (!text) continue;\n\n    const unit = tokenConfig.unit[side];\n    if (!unit) continue;\n\n    switch (unit) {\n      case 'character':\n        result[side] = tokenizeByCharacter(text, tokenConfig.preservePunctuation);\n        break;\n      case 'word':\n        result[side] = tokenizeByWord(text, tokenConfig.preservePunctuation);\n        break;\n      case 'space':\n        result[side] = tokenizeBySpace(text, tokenConfig.preservePunctuation);\n        break;\n      default:\n        // Fallback to smart tokenization\n        result[side] = tokenizeSmart(text, tokenConfig.preservePunctuation);\n    }\n  }\n\n  return result;\n};\n\n// Tokenize using word alignments\nconst tokenizeWithWordAlignments = (wordAlignments: WordAlignment[]): LineTokens => {\n  const result: LineTokens = {\n    a: [], // Chinese\n    b: [], // Pinyin\n    c: []  // English\n  };\n\n  let chinesePos = 0;\n  let pinyinPos = 0;\n  let englishPos = 0;\n\n  wordAlignments.forEach(alignment => {\n    // Chinese token (side a)\n    result.a!.push({\n      text: alignment.chinese,\n      start: chinesePos,\n      end: chinesePos + alignment.chinese.length\n    });\n    chinesePos += alignment.chinese.length;\n\n    // Pinyin token (side b)\n    result.b!.push({\n      text: alignment.pinyin,\n      start: pinyinPos,\n      end: pinyinPos + alignment.pinyin.length\n    });\n    pinyinPos += alignment.pinyin.length + 1; // +1 for space\n\n    // English token (side c)\n    result.c!.push({\n      text: alignment.english,\n      start: englishPos,\n      end: englishPos + alignment.english.length\n    });\n    englishPos += alignment.english.length + 1; // +1 for space\n  });\n\n  return result;\n};\n\n// Get aligned tokens based on index or heuristic\nexport const getAlignedTokens = (\n  lineTokens: LineTokens,\n  line: ReadingLine,\n  fromSide: SideId,\n  toSide: SideId\n): Map<number, number> => {\n  const alignment = new Map<number, number>();\n\n  const fromTokens = lineTokens[fromSide];\n  const toTokens = lineTokens[toSide];\n\n  if (!fromTokens || !toTokens) return alignment;\n\n  // If explicit alignments exist, use them\n  if (line.alignments && line.alignments.length > 0) {\n    line.alignments.forEach((mapping) => {\n      const fromIndex = mapping[fromSide];\n      const toIndex = mapping[toSide];\n      if (fromIndex !== undefined && toIndex !== undefined) {\n        alignment.set(fromIndex, toIndex);\n      }\n    });\n    return alignment;\n  }\n\n  // Otherwise use heuristic alignment\n  // Simple case: if token counts are close, use index alignment\n  const ratio = fromTokens.length / toTokens.length;\n\n  if (ratio > 0.8 && ratio < 1.2) {\n    // Close enough, use index alignment\n    const minLength = Math.min(fromTokens.length, toTokens.length);\n    for (let i = 0; i < minLength; i++) {\n      alignment.set(i, i);\n    }\n  } else {\n    // More complex alignment - distribute evenly\n    for (let i = 0; i < fromTokens.length; i++) {\n      const targetIndex = Math.floor((i / fromTokens.length) * toTokens.length);\n      alignment.set(i, Math.min(targetIndex, toTokens.length - 1));\n    }\n  }\n\n  return alignment;\n};\n\n// Normalize text for matching (used in answer checking)\nexport const normalizeText = (text: string, options?: {\n  caseSensitive?: boolean;\n  removeSpaces?: boolean;\n  removePunctuation?: boolean;\n}): string => {\n  let normalized = text;\n\n  const opts = {\n    caseSensitive: false,\n    removeSpaces: false,\n    removePunctuation: true,\n    ...options\n  };\n\n  if (!opts.caseSensitive) {\n    normalized = normalized.toLowerCase();\n  }\n\n  if (opts.removePunctuation) {\n    normalized = normalized.replace(/[.,!?;:'\"]/g, '');\n  }\n\n  if (opts.removeSpaces) {\n    normalized = normalized.replace(/\\s+/g, '');\n  } else {\n    // Collapse multiple spaces to single space\n    normalized = normalized.replace(/\\s+/g, ' ').trim();\n  }\n\n  return normalized;\n};\n\n// Calculate edit distance for fuzzy matching\nexport const calculateEditDistance = (str1: string, str2: string): number => {\n  const m = str1.length;\n  const n = str2.length;\n\n  if (m === 0) return n;\n  if (n === 0) return m;\n\n  const dp: number[][] = Array(m + 1)\n    .fill(null)\n    .map(() => Array(n + 1).fill(0));\n\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1, // deletion\n          dp[i][j - 1] + 1, // insertion\n          dp[i - 1][j - 1] + 1 // substitution\n        );\n      }\n    }\n  }\n\n  return dp[m][n];\n};\n\n// Normalize pinyin by removing tone marks and converting to lowercase\nexport const normalizePinyin = (pinyin: string): string => {\n  return pinyin\n    .toLowerCase()\n    .replace(/[āáǎà]/g, 'a')\n    .replace(/[ēéěè]/g, 'e')\n    .replace(/[īíǐì]/g, 'i')\n    .replace(/[ōóǒò]/g, 'o')\n    .replace(/[ūúǔù]/g, 'u')\n    .replace(/[ǖǘǚǜü]/g, 'v') // ü becomes v (common pinyin input method)\n    .replace(/[ńňǹ]/g, 'n')\n    .replace(/[ḿ]/g, 'm')\n    .trim();\n};\n\n// Check if pinyin answer is close enough (handles tone mark variations)\nexport const isPinyinAnswerClose = (\n  userAnswer: string,\n  correctAnswer: string,\n  maxEditDistance: number = 1\n): boolean => {\n  // Normalize both answers to remove tone marks\n  const normalizedUser = normalizePinyin(userAnswer);\n  const normalizedCorrect = normalizePinyin(correctAnswer);\n\n  // Exact match after normalization\n  if (normalizedUser === normalizedCorrect) return true;\n\n  // Allow slight variations (typos, missing spaces, etc.)\n  const distance = calculateEditDistance(normalizedUser, normalizedCorrect);\n  const maxDistance = Math.min(maxEditDistance, Math.floor(normalizedCorrect.length * 0.15));\n\n  return distance <= maxDistance;\n};\n\n// Check if answer is close enough (for fuzzy matching)\nexport const isAnswerClose = (\n  userAnswer: string,\n  correctAnswer: string,\n  maxEditDistance: number = 2,\n  answerType: 'text' | 'pinyin' = 'text'\n): boolean => {\n  // Use specialized pinyin matching for pinyin answers\n  if (answerType === 'pinyin') {\n    return isPinyinAnswerClose(userAnswer, correctAnswer, maxEditDistance);\n  }\n\n  // Standard text matching\n  const normalizedUser = normalizeText(userAnswer);\n  const normalizedCorrect = normalizeText(correctAnswer);\n\n  if (normalizedUser === normalizedCorrect) return true;\n\n  const distance = calculateEditDistance(normalizedUser, normalizedCorrect);\n  const maxDistance = Math.min(maxEditDistance, Math.floor(normalizedCorrect.length * 0.2));\n\n  return distance <= maxDistance;\n};","import { FC, useState, useCallback, useEffect, useRef } from 'react';\nimport { ReadModeSettings } from '@/types';\nimport { isAnswerClose } from '@/utils/tokenize';\nimport { Button } from '@/components/ui/Button';\nimport styles from './ReadToken.module.css';\n\ninterface Token {\n  text: string;\n  start: number;\n  end: number;\n}\n\ninterface Props {\n  token: Token;\n  index: number;\n  isActive: boolean;\n  isCompleted: boolean;\n  onClick: () => void;\n  onClose?: () => void; // New prop to deactivate token\n  onComplete?: () => void;\n  settings: ReadModeSettings;\n  sourceText: string;\n  targetText: string;\n  pinyinText?: string;\n  translationText?: string;\n}\n\nexport const ReadToken: FC<Props> = ({\n  isActive,\n  isCompleted,\n  onClick,\n  onClose,\n  onComplete,\n  settings,\n  sourceText,\n  targetText,\n  pinyinText,\n  translationText\n}) => {\n  const [userAnswer, setUserAnswer] = useState('');\n  const [showAnswer, setShowAnswer] = useState(false);\n  const [isCorrect, setIsCorrect] = useState<boolean | null>(null);\n  const [mcOptions, setMcOptions] = useState<string[]>([]);\n  const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });\n  const tokenRef = useRef<HTMLDivElement>(null);\n\n  // Check if a string is punctuation or special character\n  const isPunctuation = (text: string) => {\n    return /^[.,!?;:()\\[\\]{}\"'`~@#$%^&*+=\\-\\/\\\\|<>]+$/.test(text);\n  };\n\n  // Check if tokens should be skipped for practice\n  const shouldSkipToken = (source: string, target: string) => {\n    // Skip if both source and target are punctuation\n    if (isPunctuation(source) && isPunctuation(target)) return true;\n    // Skip if target is empty or whitespace only\n    if (!target || !target.trim()) return true;\n    return false;\n  };\n\n  // Generate multiple choice options if needed\n  useEffect(() => {\n    if (settings.answerType === 'multiple_choice' && isActive && targetText) {\n      // Skip MC for punctuation/special cases\n      if (shouldSkipToken(sourceText, targetText)) {\n        // Auto-advance for punctuation\n        if (onComplete) {\n          setTimeout(() => onComplete(), 500);\n        }\n        return;\n      }\n\n      // Generate distractors based on the target text\n      const options = [targetText];\n\n      // Generate appropriate distractors based on target language/side\n      let distractorPool: string[] = [];\n      const targetSide = settings.translationDirection.to;\n\n      // Check if target is a number (language agnostic)\n      if (/^\\d+$/.test(targetText)) {\n        // For numbers, use other numbers as distractors\n        const num = parseInt(targetText);\n        distractorPool = [\n          (num - 1).toString(),\n          (num + 1).toString(),\n          (num * 2).toString(),\n          (num + 10).toString(),\n          Math.floor(num / 2).toString()\n        ].filter(n => n !== targetText && parseInt(n) >= 0);\n      }\n      // Generate distractors based on target language/side\n      else if (targetSide === 'b') {\n        // Pinyin distractors - common pinyin syllables\n        const pinyinSyllables = [\n          'ma', 'wo', 'ni', 'ta', 'de', 'shi', 'zai', 'you', 'ge', 'le',\n          'dao', 'shang', 'xia', 'lai', 'qu', 'hao', 'hen', 'dou', 'bu', 'mei',\n          'kan', 'shuo', 'zuo', 'chi', 'he', 'zou', 'pao', 'fei', 'kai', 'guan',\n          'da', 'xiao', 'gao', 'ai', 'pang', 'shou', 'kuai', 'man', 'xin', 'jiu',\n          'duo', 'shao', 'chang', 'duan', 'yuan', 'jin', 'li', 'wai', 'zhong', 'bian',\n          'qian', 'hou', 'zuo', 'you', 'dong', 'xi', 'nan', 'bei', 'bai', 'hei',\n          'hong', 'lu', 'huang', 'lan', 'zi', 'fen', 'hui', 'zong', 'cheng', 'qing'\n        ];\n        // Add tone mark variations for more realistic distractors\n        const extendedPinyin = [...pinyinSyllables];\n        pinyinSyllables.forEach(syllable => {\n          if (syllable.includes('a')) {\n            extendedPinyin.push(syllable.replace('a', 'ā'), syllable.replace('a', 'á'), syllable.replace('a', 'ǎ'), syllable.replace('a', 'à'));\n          }\n          if (syllable.includes('e')) {\n            extendedPinyin.push(syllable.replace('e', 'ē'), syllable.replace('e', 'é'), syllable.replace('e', 'ě'), syllable.replace('e', 'è'));\n          }\n          if (syllable.includes('i')) {\n            extendedPinyin.push(syllable.replace('i', 'ī'), syllable.replace('i', 'í'), syllable.replace('i', 'ǐ'), syllable.replace('i', 'ì'));\n          }\n          if (syllable.includes('o')) {\n            extendedPinyin.push(syllable.replace('o', 'ō'), syllable.replace('o', 'ó'), syllable.replace('o', 'ǒ'), syllable.replace('o', 'ò'));\n          }\n          if (syllable.includes('u')) {\n            extendedPinyin.push(syllable.replace('u', 'ū'), syllable.replace('u', 'ú'), syllable.replace('u', 'ǔ'), syllable.replace('u', 'ù'));\n          }\n        });\n        distractorPool = extendedPinyin;\n      }\n      else if (targetSide === 'a') {\n        // Chinese character distractors - common characters\n        distractorPool = [\n          '我', '你', '他', '她', '的', '是', '在', '有', '个', '了',\n          '到', '上', '下', '来', '去', '好', '很', '都', '不', '没',\n          '看', '说', '做', '吃', '喝', '走', '跑', '飞', '开', '关',\n          '大', '小', '高', '矮', '胖', '瘦', '快', '慢', '新', '旧',\n          '多', '少', '长', '短', '远', '近', '里', '外', '中', '边',\n          '前', '后', '左', '右', '东', '西', '南', '北', '白', '黑',\n          '红', '绿', '黄', '蓝', '紫', '粉', '灰', '棕', '橙', '青'\n        ];\n      }\n      else {\n        // English distractors (side c or other)\n        // Check if target is very short (1-2 chars)\n        if (targetText.length <= 2) {\n          distractorPool = [\n            'a', 'I', 'it', 'is', 'to', 'be', 'of', 'in', 'on', 'at',\n            'or', 'an', 'as', 'by', 'we', 'he', 'me', 'my', 'up', 'so'\n          ];\n        } else {\n          // Group words by part of speech/meaning for better distractors\n          const pronouns = ['I', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them'];\n          const verbs = ['is', 'are', 'was', 'were', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'can', 'could', 'would', 'should', 'make', 'take', 'give', 'get', 'go', 'come', 'see', 'know', 'think', 'want'];\n          const adjectives = ['good', 'bad', 'big', 'small', 'new', 'old', 'happy', 'sad', 'fast', 'slow', 'hot', 'cold', 'easy', 'hard', 'beautiful', 'ugly'];\n          const articles = ['the', 'a', 'an', 'this', 'that', 'these', 'those'];\n          const prepositions = ['in', 'on', 'at', 'to', 'for', 'with', 'from', 'by', 'about', 'into', 'through', 'during', 'before', 'after'];\n          const adverbs = ['very', 'really', 'quite', 'too', 'so', 'just', 'still', 'already', 'yet', 'even', 'only', 'also', 'never', 'always', 'sometimes'];\n\n          // Try to match the target word type and select from appropriate pool\n          if (pronouns.includes(targetText.toLowerCase())) {\n            distractorPool = pronouns;\n          } else if (verbs.includes(targetText.toLowerCase())) {\n            distractorPool = verbs;\n          } else if (adjectives.includes(targetText.toLowerCase())) {\n            distractorPool = adjectives;\n          } else if (articles.includes(targetText.toLowerCase())) {\n            distractorPool = articles;\n          } else if (prepositions.includes(targetText.toLowerCase())) {\n            distractorPool = prepositions;\n          } else if (adverbs.includes(targetText.toLowerCase())) {\n            distractorPool = adverbs;\n          } else {\n            // Default mixed pool for unknown words\n            distractorPool = [...verbs.slice(0, 5), ...adjectives.slice(0, 5), ...pronouns.slice(0, 5)];\n          }\n        }\n      }\n\n      // Filter out the correct answer and select random distractors\n      const availableDisractors = distractorPool.filter(d =>\n        d.toLowerCase() !== targetText.toLowerCase()\n      );\n\n      while (options.length < (settings.optionsCount || 4) && availableDisractors.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availableDisractors.length);\n        const distractor = availableDisractors[randomIndex];\n        if (!options.includes(distractor)) {\n          options.push(distractor);\n          availableDisractors.splice(randomIndex, 1);\n        }\n      }\n\n      // If we still need more options, add language-appropriate fallbacks\n      while (options.length < (settings.optionsCount || 4)) {\n        let fallbackOptions: string[];\n        if (targetSide === 'b') {\n          // Pinyin fallbacks\n          fallbackOptions = ['shénme', 'nǎlǐ', 'zěnme', 'shéi'];\n        } else if (targetSide === 'a') {\n          // Chinese character fallbacks\n          fallbackOptions = ['什么', '哪里', '怎么', '谁'];\n        } else {\n          // English fallbacks\n          fallbackOptions = ['something', 'nothing', 'anything', 'everything'];\n        }\n        const fallback = fallbackOptions[options.length - 1] || `option${options.length}`;\n        if (!options.includes(fallback)) {\n          options.push(fallback);\n        }\n      }\n\n      // Shuffle options\n      setMcOptions(options.sort(() => Math.random() - 0.5));\n    }\n  }, [isActive, settings, targetText, sourceText, onClick]);\n\n  // Calculate popup position when token becomes active\n  useEffect(() => {\n    if (isActive && tokenRef.current) {\n      const rect = tokenRef.current.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n\n      // Calculate position that keeps popup in viewport\n      let top = rect.bottom + 10;\n      let left = rect.left + (rect.width / 2);\n\n      // Check if popup would go off bottom of screen\n      if (top + 300 > viewportHeight) {\n        top = rect.top - 310; // Show above instead\n      }\n\n      // Ensure horizontal position stays in viewport\n      const popupWidth = 250;\n      if (left - (popupWidth / 2) < 10) {\n        left = popupWidth / 2 + 10;\n      } else if (left + (popupWidth / 2) > viewportWidth - 10) {\n        left = viewportWidth - (popupWidth / 2) - 10;\n      }\n\n      setPopupPosition({ top, left });\n    }\n  }, [isActive]);\n\n  // Handle answer submission\n  const handleSubmit = useCallback((answer: string) => {\n\n    if (settings.checkMode === 'live') {\n      // Live checking - check immediately\n      // Use pinyin-aware matching if target is pinyin (side b)\n      const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n      const correct = isAnswerClose(answer, targetText, 2, answerType);\n      setIsCorrect(correct);\n      setShowAnswer(true);\n\n      // Don't auto-advance - let user manually advance\n    } else {\n      // Wait mode - just store answer\n      setUserAnswer(answer);\n    }\n  }, [settings, targetText, sourceText]);\n\n  // Handle reveal\n  const handleReveal = useCallback(() => {\n    if (userAnswer) {\n      // Use pinyin-aware matching if target is pinyin (side b)\n      const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n      const correct = isAnswerClose(userAnswer, targetText, 2, answerType);\n      setIsCorrect(correct);\n      setShowAnswer(true);\n\n      // Auto-advance to next token after a short delay\n      if (correct && onComplete) {\n        setTimeout(() => {\n          onComplete(); // Move to next token\n        }, 1000);\n      }\n    } else {\n      setShowAnswer(true);\n    }\n  }, [userAnswer, targetText, settings, onComplete]);\n\n  // Handle multiple choice selection\n  const handleMCSelect = useCallback((option: string) => {\n    // Use pinyin-aware matching if target is pinyin (side b)\n    const answerType = settings.translationDirection.to === 'b' ? 'pinyin' : 'text';\n    const correct = isAnswerClose(option, targetText, 2, answerType);\n    setIsCorrect(correct);\n    setShowAnswer(true);\n    setUserAnswer(option);\n\n    // Auto-advance to next token after a short delay\n    if (correct && onComplete) {\n      setTimeout(() => {\n        onComplete(); // Move to next token\n      }, 1000);\n    }\n  }, [targetText, settings, onComplete]);\n\n  return (\n    <div\n      ref={tokenRef}\n      className={`\n        ${styles.token}\n        ${isActive ? styles.active : ''}\n        ${isCompleted ? styles.completed : ''}\n        ${isCorrect === true ? styles.correct : ''}\n        ${isCorrect === false ? styles.incorrect : ''}\n      `}\n      onClick={onClick}\n    >\n      <span className={styles.tokenText}>{sourceText}</span>\n\n      {/* Show interaction UI when active - skip for punctuation */}\n      {isActive && !showAnswer && !shouldSkipToken(sourceText, targetText) && (\n        <div\n          className={styles.interactionArea}\n          style={{\n            position: 'fixed',\n            top: `${popupPosition.top}px`,\n            left: `${popupPosition.left}px`,\n            transform: 'translateX(-50%)'\n          }}\n        >\n          {/* Close button to dismiss popup */}\n          <button\n            className={styles.closeButton}\n            onClick={(e) => {\n              e.stopPropagation();\n              if (onClose) {\n                onClose(); // Deactivate this token\n              }\n            }}\n            aria-label=\"Close input\"\n            title=\"Close (to see translations below)\"\n          >\n            ✕\n          </button>\n\n          {settings.answerType === 'free_text' ? (\n            <div className={styles.freeTextInput}>\n              <input\n                type=\"text\"\n                value={userAnswer}\n                onChange={(e) => setUserAnswer(e.target.value)}\n                onKeyPress={(e) => {\n                  if (e.key === 'Enter') {\n                    if (settings.checkMode === 'live') {\n                      handleSubmit(userAnswer);\n                    } else {\n                      handleReveal();\n                    }\n                  }\n                }}\n                placeholder=\"Type translation...\"\n                className={styles.textInput}\n                autoFocus\n              />\n              {settings.checkMode === 'wait' && (\n                <Button\n                  size=\"small\"\n                  variant=\"primary\"\n                  onClick={handleReveal}\n                  disabled={!userAnswer}\n                >\n                  Check\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className={styles.multipleChoice}>\n              {mcOptions.map((option, idx) => (\n                <Button\n                  key={idx}\n                  size=\"small\"\n                  variant=\"secondary\"\n                  onClick={() => handleMCSelect(option)}\n                  className={styles.mcOption}\n                >\n                  {option}\n                </Button>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Show answer when revealed */}\n      {showAnswer && (\n        <div className={styles.answerDisplay}>\n          <span className={styles.correctAnswer}>{targetText}</span>\n          {isCorrect !== null && (\n            <span className={isCorrect ? styles.feedbackCorrect : styles.feedbackIncorrect}>\n              {isCorrect ? '✓' : '✗'}\n            </span>\n          )}\n        </div>\n      )}\n\n      {/* Show hints if enabled */}\n      {pinyinText && !isActive && (\n        <span className={styles.pinyinHint}>{pinyinText}</span>\n      )}\n      {translationText && !isActive && (\n        <span className={styles.translationHint}>{translationText}</span>\n      )}\n    </div>\n  );\n};","import { FC, useMemo, useCallback } from 'react';\nimport { Deck, ReadingLine, ReadModeSettings } from '@/types';\nimport {\n  hasWordAlignments,\n  createInteractiveTokens\n} from '@/utils/wordAlignments';\nimport { tokenizeLine } from '@/utils/tokenize';\nimport { ReadToken } from './ReadToken';\nimport styles from './AlignedReadLine.module.css';\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface Props {\n  line: ReadingLine;\n  deck: Deck;\n  session: ReadSessionState;\n  settings: ReadModeSettings;\n  onTokenClick: (tokenIndex: number) => void;\n  onTokenComplete: () => void;\n}\n\nexport const AlignedReadLine: FC<Props> = ({\n  line,\n  deck,\n  session,\n  settings,\n  onTokenClick,\n  onTokenComplete\n}) => {\n  // Check if we have word alignments for this line\n  const hasAlignments = useMemo(() => hasWordAlignments(line), [line]);\n\n  // Get aligned tokens if available\n  const alignedTokens = useMemo(() => {\n    if (hasAlignments) {\n      return createInteractiveTokens(line);\n    }\n    return [];\n  }, [line, hasAlignments]);\n\n\n\n  // Fall back to traditional tokenization if no alignments\n  const lineTokens = useMemo(() => {\n    if (hasAlignments) return null; // Don't compute if we have alignments\n\n    const config = deck.reading?.tokenization || {\n      unit: {\n        a: 'character',\n        b: 'space',\n        c: 'space',\n        d: undefined,\n        e: undefined,\n        f: undefined\n      },\n      preservePunctuation: true\n    };\n\n    return tokenizeLine(line, config);\n  }, [line, deck, hasAlignments]);\n\n  // Get tokens for interactive mode - use wordAlignments if available, fallback to traditional\n  const sourceTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format for ReadToken components\n      const tokens = alignedTokens.map((alignedToken, index) => ({\n        text: alignedToken.chinese,\n        start: index,\n        end: index + 1\n      }));\n      return tokens;\n    }\n\n    if (!lineTokens) return [];\n    const sourceSide = settings.translationDirection.from;\n    return lineTokens[sourceSide] || [];\n  }, [hasAlignments, alignedTokens, lineTokens, settings]);\n\n  const targetTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format\n      const targetSide = settings.translationDirection.to;\n      return alignedTokens.map((alignedToken, index) => ({\n        text: targetSide === 'b' ? alignedToken.pinyin : alignedToken.english,\n        start: index,\n        end: index + 1\n      }));\n    }\n\n    if (!lineTokens) return [];\n    const targetSide = settings.translationDirection.to;\n    return lineTokens[targetSide] || [];\n  }, [hasAlignments, alignedTokens, lineTokens, settings]);\n\n  const pinyinTokens = useMemo(() => {\n    if (hasAlignments && alignedTokens.length > 0) {\n      // Convert aligned tokens to traditional token format for pinyin\n      return alignedTokens.map((alignedToken, index) => ({\n        text: alignedToken.pinyin,\n        start: index,\n        end: index + 1\n      }));\n    }\n\n    if (!lineTokens) return [];\n    return lineTokens['b'] || [];\n  }, [hasAlignments, alignedTokens, lineTokens]);\n\n\n  // Traditional token click handler\n  const handleTokenClick = useCallback((tokenIndex: number) => {\n    onTokenClick(tokenIndex);\n  }, [onTokenClick]);\n\n  // Traditional token completion handler\n  const handleTokenComplete = useCallback(() => {\n    onTokenComplete();\n  }, [onTokenComplete]);\n\n  // Get target text for tokens (now supports wordAlignment-based tokens)\n  const getTargetForSourceToken = useCallback((sourceIndex: number) => {\n    if (!targetTokens.length) return '';\n    const targetToken = targetTokens[sourceIndex];\n    return targetToken?.text || '';\n  }, [targetTokens]);\n\n  // Get pinyin for tokens (now supports wordAlignment-based tokens)\n  const getPinyinForSourceToken = useCallback((sourceIndex: number) => {\n    if (!pinyinTokens.length) return '';\n    const pinyinToken = pinyinTokens[sourceIndex];\n    return pinyinToken?.text || '';\n  }, [pinyinTokens]);\n\n  // Get side labels\n  const getSideLabel = useCallback((sideId: string) => {\n    if (!deck.reading?.sides) {\n      const defaultLabels: Record<string, string> = {\n        a: 'Characters',\n        b: 'Pinyin',\n        c: 'English',\n        d: 'Side D',\n        e: 'Side E',\n        f: 'Side F'\n      };\n      return defaultLabels[sideId] || sideId.toUpperCase();\n    }\n    return deck.reading.sides[sideId as keyof typeof deck.reading.sides] || sideId.toUpperCase();\n  }, [deck]);\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.lineHeader}>\n        <span className={styles.lineNumber}>Line {session.currentLineIndex + 1}</span>\n        <span className={styles.translationDirection}>\n          {getSideLabel(settings.translationDirection.from)} → {getSideLabel(settings.translationDirection.to)}\n        </span>\n        {hasAlignments && (\n          <span className={styles.alignmentBadge}>Word Aligned</span>\n        )}\n      </div>\n\n      <div className={styles.lineContent}>\n        {/* Always use interactive ReadToken components for token-by-token practice */}\n        {/* Now uses wordAlignment-based tokens when available for correct boundaries */}\n        <div className={styles.sourceSide}>\n          <div className={styles.sideLabel}>\n            {getSideLabel(settings.translationDirection.from)}\n            {hasAlignments && (\n              <span className={styles.alignmentBadge}>Word Aligned</span>\n            )}\n          </div>\n          <div className={styles.tokens}>\n            {sourceTokens.map((token, index) => (\n              <ReadToken\n                key={`${session.currentLineIndex}-${index}`}\n                token={token}\n                index={index}\n                isActive={session.currentTokenIndex === index}\n                isCompleted={false}\n                onClick={() => handleTokenClick(index)}\n                onClose={() => handleTokenClick(-1)} // Deactivate by setting to -1\n                onComplete={handleTokenComplete}\n                settings={settings}\n                sourceText={token.text}\n                targetText={getTargetForSourceToken(index)}\n                pinyinText={session.showPinyin ? getPinyinForSourceToken(index) : ''}\n                translationText={session.showTranslation ? getTargetForSourceToken(index) : ''}\n              />\n            ))}\n          </div>\n        </div>\n\n        {/* Show additional sides if enabled and not using word alignments */}\n        {!hasAlignments && session.showPinyin && line.b && (\n          <div className={styles.additionalSide}>\n            <div className={styles.sideLabel}>Pinyin</div>\n            <div className={styles.sideText}>{line.b}</div>\n          </div>\n        )}\n\n        {!hasAlignments && session.showTranslation && (\n          <div className={styles.additionalSide}>\n            <div className={styles.sideLabel}>{getSideLabel(settings.translationDirection.to)}</div>\n            <div className={styles.sideText}>{line[settings.translationDirection.to] || ''}</div>\n          </div>\n        )}\n\n        {/* For aligned content, show full sentences when enabled */}\n        {hasAlignments && (session.showPinyin || session.showTranslation) && (\n          <div className={styles.fullSentences}>\n            {session.showPinyin && line.b && (\n              <div className={styles.fullSentence}>\n                <div className={styles.sideLabel}>Full Pinyin</div>\n                <div className={styles.sideText}>{line.b}</div>\n              </div>\n            )}\n            {session.showTranslation && line.c && (\n              <div className={styles.fullSentence}>\n                <div className={styles.sideLabel}>Full Translation</div>\n                <div className={styles.sideText}>{line.c}</div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};","import { FC, useMemo, useCallback } from 'react';\nimport { Deck, ReadingLine, ReadModeSettings, SentenceTranslationResult } from '@/types';\nimport { SentenceTranslation } from './SentenceTranslation';\nimport { AlignedReadLine } from './AlignedReadLine';\nimport styles from './EnhancedReadLine.module.css';\n\ninterface ReadSessionState {\n  deckId: string;\n  currentDialogueId: string | null;\n  currentLineIndex: number;\n  currentTokenIndex: number;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  correctCount: number;\n  incorrectCount: number;\n  startTime: number;\n  responseStartTime: number;\n  responseTimes: number[];\n}\n\ninterface Props {\n  line: ReadingLine;\n  deck: Deck;\n  session: ReadSessionState;\n  settings: ReadModeSettings;\n  allLines: ReadingLine[]; // For MC distractors\n  onAnswer?: (result: SentenceTranslationResult) => void;\n  onTokenClick?: (tokenIndex: number) => void;\n  onTokenComplete?: () => void;\n  onNext?: () => void;\n  showControls?: boolean;\n}\n\nexport const EnhancedReadLine: FC<Props> = ({\n  line,\n  deck,\n  session,\n  settings,\n  allLines,\n  onAnswer,\n  onTokenClick,\n  onTokenComplete,\n  onNext: _onNext // Reserved for potential future auto-advance feature\n  // showControls = true // Reserved for future use\n}) => {\n  // Get side labels\n  const getSideLabel = useCallback((sideId: string) => {\n    if (!deck.reading?.sides) {\n      const defaultLabels: Record<string, string> = {\n        a: 'Characters',\n        b: 'Pinyin',\n        c: 'English',\n        d: 'Side D',\n        e: 'Side E',\n        f: 'Side F'\n      };\n      return defaultLabels[sideId] || sideId.toUpperCase();\n    }\n    return deck.reading.sides[sideId as keyof typeof deck.reading.sides] || sideId.toUpperCase();\n  }, [deck]);\n\n  // Handle sentence translation answer\n  const handleSentenceAnswer = useCallback((result: SentenceTranslationResult) => {\n    if (onAnswer) {\n      onAnswer(result);\n    }\n\n    // Don't auto-advance - let user manually navigate with keyboard or buttons\n  }, [onAnswer]);\n\n  // Render based on translation mode\n  const renderContent = useMemo(() => {\n    if (settings.translationMode === 'sentence') {\n      return (\n        <div className={styles.sentenceMode}>\n          <div className={styles.lineHeader}>\n            <span className={styles.lineNumber}>Line {session.currentLineIndex + 1}</span>\n            <span className={styles.translationDirection}>\n              {getSideLabel(settings.translationDirection.from)} → {getSideLabel(settings.translationDirection.to)}\n            </span>\n          </div>\n\n          <SentenceTranslation\n            line={line}\n            allLines={allLines}\n            settings={settings}\n            onAnswer={handleSentenceAnswer}\n            showResult={true}\n          />\n\n          {/* Show additional content if enabled */}\n          {(session.showPinyin || session.showTranslation) && (\n            <div className={styles.additionalContent}>\n              {session.showPinyin && line.b && (\n                <div className={styles.additionalSide}>\n                  <div className={styles.sideLabel}>Pinyin</div>\n                  <div className={styles.sideText}>{line.b}</div>\n                </div>\n              )}\n              {session.showTranslation && line[settings.translationDirection.to] && (\n                <div className={styles.additionalSide}>\n                  <div className={styles.sideLabel}>{getSideLabel(settings.translationDirection.to)}</div>\n                  <div className={styles.sideText}>{line[settings.translationDirection.to]}</div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      );\n    }\n\n    // Fall back to token-based mode\n    return (\n      <AlignedReadLine\n        line={line}\n        deck={deck}\n        session={session}\n        settings={settings}\n        onTokenClick={onTokenClick || (() => {})}\n        onTokenComplete={onTokenComplete || (() => {})}\n      />\n    );\n  }, [\n    settings.translationMode,\n    line,\n    deck,\n    session,\n    settings,\n    allLines,\n    getSideLabel,\n    handleSentenceAnswer,\n    onTokenClick,\n    onTokenComplete\n  ]);\n\n  return (\n    <div className={styles.container}>\n      {renderContent}\n    </div>\n  );\n};","import { FC } from 'react';\nimport { Button } from '@/components/ui/Button';\nimport styles from './ReadControls.module.css';\n\ninterface Props {\n  canGoPrevious: boolean;\n  canGoNext: boolean;\n  showPinyin: boolean;\n  showTranslation: boolean;\n  onPrevious: () => void;\n  onNext: () => void;\n  onTogglePinyin: () => void;\n  onToggleTranslation: () => void;\n}\n\nexport const ReadControls: FC<Props> = ({\n  canGoPrevious,\n  canGoNext,\n  showPinyin,\n  showTranslation,\n  onPrevious,\n  onNext,\n  onTogglePinyin,\n  onToggleTranslation\n}) => {\n  return (\n    <div className={styles.container}>\n      <div className={styles.navigationControls}>\n        <Button\n          variant=\"secondary\"\n          size=\"medium\"\n          onClick={onPrevious}\n          disabled={!canGoPrevious}\n          className={styles.navButton}\n        >\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <path d=\"M19 12H5M5 12L12 19M5 12L12 5\" />\n          </svg>\n          Previous\n        </Button>\n        <Button\n          variant=\"secondary\"\n          size=\"medium\"\n          onClick={onNext}\n          disabled={!canGoNext}\n          className={styles.navButton}\n        >\n          Next\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <path d=\"M5 12H19M19 12L12 5M19 12L12 19\" />\n          </svg>\n        </Button>\n      </div>\n\n      <div className={styles.toggleControls}>\n        <Button\n          variant={showPinyin ? 'primary' : 'secondary'}\n          size=\"small\"\n          onClick={onTogglePinyin}\n          className={styles.toggleButton}\n        >\n          {showPinyin ? (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\" />\n              <circle cx=\"12\" cy=\"12\" r=\"3\" />\n            </svg>\n          ) : (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24\" />\n              <line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\" />\n            </svg>\n          )}\n          Pinyin (R)\n        </Button>\n        <Button\n          variant={showTranslation ? 'primary' : 'secondary'}\n          size=\"small\"\n          onClick={onToggleTranslation}\n          className={styles.toggleButton}\n        >\n          {showTranslation ? (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\" />\n              <circle cx=\"12\" cy=\"12\" r=\"3\" />\n            </svg>\n          ) : (\n            <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24\" />\n              <line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\" />\n            </svg>\n          )}\n          Translation (T)\n        </Button>\n      </div>\n\n      <div className={styles.shortcuts}>\n        <span className={styles.shortcutHint}>\n          Use ↑/↓ or J/K to navigate • R for pinyin • T for translation\n        </span>\n      </div>\n    </div>\n  );\n};","import { FC } from 'react';\nimport styles from './ReadProgress.module.css';\n\ninterface Props {\n  currentLineIndex: number;\n  totalLines: number;\n  correctCount: number;\n  incorrectCount: number;\n}\n\nexport const ReadProgress: FC<Props> = ({\n  currentLineIndex,\n  totalLines,\n  correctCount,\n  incorrectCount\n}) => {\n  const progressPercentage = ((currentLineIndex + 1) / totalLines) * 100;\n  const accuracy = correctCount + incorrectCount > 0\n    ? (correctCount / (correctCount + incorrectCount)) * 100\n    : 0;\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.stats}>\n        <div className={styles.stat}>\n          <span className={styles.statLabel}>Line</span>\n          <span className={styles.statValue}>\n            {currentLineIndex + 1} / {totalLines}\n          </span>\n        </div>\n        {(correctCount > 0 || incorrectCount > 0) && (\n          <>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Correct</span>\n              <span className={`${styles.statValue} ${styles.correct}`}>\n                {correctCount}\n              </span>\n            </div>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Incorrect</span>\n              <span className={`${styles.statValue} ${styles.incorrect}`}>\n                {incorrectCount}\n              </span>\n            </div>\n            <div className={styles.stat}>\n              <span className={styles.statLabel}>Accuracy</span>\n              <span className={styles.statValue}>\n                {accuracy.toFixed(0)}%\n              </span>\n            </div>\n          </>\n        )}\n      </div>\n      <div className={styles.progressBar}>\n        <div\n          className={styles.progressFill}\n          style={{ width: `${progressPercentage}%` }}\n        />\n      </div>\n    </div>\n  );\n};","import { FC, useEffect, useMemo, useState, useCallback } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useReadStore } from '@/store/readStore';\nimport { SentenceTranslationResult } from '@/types';\nimport { PageHeader } from '@/components/common/PageHeader';\nimport { ReadDialoguePicker } from '@/components/read/ReadDialoguePicker';\nimport { EnhancedReadLine } from '@/components/read/EnhancedReadLine';\nimport { ReadControls } from '@/components/read/ReadControls';\nimport { ReadProgress } from '@/components/read/ReadProgress';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport SettingsIcon from '@/components/icons/SettingsIcon';\nimport { Button } from '@/components/ui/Button';\nimport styles from './Read.module.css';\n\nconst Read: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n\n  // Store hooks\n  const { currentDeck, isLoading, error, loadDeck } = useDeckStore();\n  const {\n    session,\n    settings,\n    initSession,\n    setCurrentDialogue,\n    setCurrentLine,\n    setCurrentToken,\n    togglePinyin,\n    toggleTranslation,\n    recordAnswer,\n    getProgress\n  } = useReadStore();\n\n\n  // Local state\n  const [showSettings, setShowSettings] = useState(false);\n  const [selectedDialogueId, setSelectedDialogueId] = useState<string | null>(null);\n\n  // Load deck on mount\n  useEffect(() => {\n    if (deckId) {\n      loadDeck(deckId);\n    }\n  }, [deckId, loadDeck]);\n\n  // Initialize session when deck loads\n  useEffect(() => {\n    if (currentDeck?.reading && deckId) {\n      const dialogueIds = Object.keys(currentDeck.reading.dialogues);\n      if (dialogueIds.length > 0) {\n        // Check for saved progress\n        const savedProgress = getProgress(deckId);\n        const dialogueId = savedProgress?.dialogueId || dialogueIds[0];\n\n        // Always set the selected dialogue (even if session exists)\n        setSelectedDialogueId(dialogueId);\n\n        // Only initialize session if it doesn't exist\n        if (!session) {\n          initSession(deckId, dialogueId);\n        }\n      }\n    }\n  }, [currentDeck, deckId, initSession, getProgress]);\n\n  // Restore progress when session initializes\n  useEffect(() => {\n    if (session && deckId && session.currentLineIndex === 0 && session.currentTokenIndex === 0) {\n      const savedProgress = getProgress(deckId);\n      if (savedProgress && savedProgress.lineIndex > 0) {\n        setCurrentLine(savedProgress.lineIndex);\n        setCurrentToken(savedProgress.tokenIndex);\n      }\n    }\n  }, [session?.currentDialogueId]); // Only run when dialogue changes\n\n  // Get current dialogue and line data\n  const currentDialogue = useMemo(() => {\n    if (!currentDeck?.reading || !selectedDialogueId) return null;\n    return currentDeck.reading.dialogues[selectedDialogueId];\n  }, [currentDeck, selectedDialogueId]);\n\n  const currentLine = useMemo(() => {\n    if (!currentDialogue || !session) return null;\n    return currentDialogue.lines[session.currentLineIndex];\n  }, [currentDialogue, session]);\n\n  // Get all lines for MC generation\n  const allLines = useMemo(() => {\n    if (!currentDialogue) return [];\n    return currentDialogue.lines;\n  }, [currentDialogue]);\n\n  // Handle dialogue selection\n  const handleSelectDialogue = useCallback((dialogueId: string) => {\n    setSelectedDialogueId(dialogueId);\n    setCurrentDialogue(dialogueId);\n    setCurrentLine(0);\n    setCurrentToken(0);\n  }, [setCurrentDialogue, setCurrentLine, setCurrentToken]);\n\n  // Handle navigation\n  const handlePreviousLine = useCallback(() => {\n    if (!session) return;\n\n    if (session.currentLineIndex > 0) {\n      setCurrentLine(session.currentLineIndex - 1);\n      setCurrentToken(0);\n    }\n  }, [session, setCurrentLine, setCurrentToken]);\n\n  const handleNextLine = useCallback(() => {\n    if (!session || !currentDialogue) return;\n\n    if (session.currentLineIndex < currentDialogue.lines.length - 1) {\n      setCurrentLine(session.currentLineIndex + 1);\n      setCurrentToken(0);\n    }\n  }, [session, currentDialogue, setCurrentLine, setCurrentToken]);\n\n  // Handle sentence translation answer\n  const handleSentenceAnswer = useCallback((result: SentenceTranslationResult) => {\n    if (!session) return;\n\n    const responseTime = Date.now() - session.responseStartTime;\n    recordAnswer(result.isCorrect, responseTime);\n\n  }, [session, recordAnswer]);\n\n  // Handle keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      switch (e.key) {\n        case 'ArrowUp':\n        case 'k':\n          e.preventDefault();\n          handlePreviousLine();\n          break;\n        case 'ArrowDown':\n        case 'j':\n          e.preventDefault();\n          handleNextLine();\n          break;\n        case 'r':\n          e.preventDefault();\n          togglePinyin();\n          break;\n        case 't':\n          e.preventDefault();\n          toggleTranslation();\n          break;\n        default:\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handlePreviousLine, handleNextLine, togglePinyin, toggleTranslation]);\n\n  // Handle cleanup\n  useEffect(() => {\n    return () => {\n      // Save progress when leaving\n      if (session && deckId) {\n        // Progress is already saved in the store\n      }\n    };\n  }, [session, deckId]);\n\n  // Loading state - removed LoadingScreen to avoid duplicate with PageLazyBoundary\n  if (isLoading) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  // Error state\n  if (error || !currentDeck) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>Unable to load deck</h2>\n        <p>The deck could not be loaded. Please try again.</p>\n        <button onClick={() => navigate('/')} className={styles.backButton}>\n          Back to Home\n        </button>\n      </div>\n    );\n  }\n\n  // Check if deck has reading content\n  if (!currentDeck.reading || Object.keys(currentDeck.reading.dialogues).length === 0) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>No reading content available</h2>\n        <p>This deck doesn't have any reading dialogues. Please choose a different deck.</p>\n        <button onClick={() => navigate(`/deck/${deckId}`)} className={styles.backButton}>\n          Back to Deck\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.readPage}>\n      <PageHeader\n        title={currentDeck.metadata.deck_name}\n        subtitle=\"Read Mode\"\n        onBackClick={() => navigate(`/deck/${deckId}`)}\n        backLabel=\"Back to Deck\"\n        rightContent={\n          <Button\n            variant=\"secondary\"\n            size=\"small\"\n            onClick={() => setShowSettings(true)}\n            className={styles.settingsButton}\n          >\n            <SettingsIcon size={20} />\n          </Button>\n        }\n      />\n\n      <div className={styles.container}>\n        <div className={styles.leftPanel}>\n          <ReadDialoguePicker\n            deck={currentDeck}\n            selectedDialogueId={selectedDialogueId}\n            onSelectDialogue={handleSelectDialogue}\n            progress={getProgress(deckId || '')}\n          />\n        </div>\n\n        <div className={styles.mainPanel}>\n          {session && currentDialogue && currentLine && (\n            <>\n              <ReadProgress\n                currentLineIndex={session.currentLineIndex}\n                totalLines={currentDialogue.lines.length}\n                correctCount={session.correctCount}\n                incorrectCount={session.incorrectCount}\n              />\n\n              <EnhancedReadLine\n                line={currentLine}\n                deck={currentDeck}\n                session={session}\n                settings={settings}\n                allLines={allLines}\n                onAnswer={handleSentenceAnswer}\n                onNext={handleNextLine}\n                onTokenClick={(tokenIndex: number) => {\n                  // Set the current token when clicked\n                  setCurrentToken(tokenIndex);\n                }}\n                onTokenComplete={() => {\n                  // Advance to next token when current one is completed\n                  if (!session || !currentDialogue) return;\n\n                  const nextTokenIndex = session.currentTokenIndex + 1;\n                  const currentLine = currentDialogue.lines[session.currentLineIndex];\n\n                  // Check if we have wordAlignments to determine max tokens\n                  const maxTokens = currentLine.wordAlignments ?\n                    currentLine.wordAlignments.length :\n                    (currentLine.a?.length || 0);\n\n\n                  if (nextTokenIndex < maxTokens) {\n                    // Move to next token in same line\n                    setCurrentToken(nextTokenIndex);\n                  } else {\n                    // Move to next line if available\n                    if (session.currentLineIndex < currentDialogue.lines.length - 1) {\n                      handleNextLine();\n                    }\n                  }\n                }}\n              />\n\n              {settings.translationMode === 'token' && (\n                <ReadControls\n                  canGoPrevious={session.currentLineIndex > 0}\n                  canGoNext={session.currentLineIndex < currentDialogue.lines.length - 1}\n                  showPinyin={session.showPinyin}\n                  showTranslation={session.showTranslation}\n                  onPrevious={handlePreviousLine}\n                  onNext={handleNextLine}\n                  onTogglePinyin={togglePinyin}\n                  onToggleTranslation={toggleTranslation}\n                />\n              )}\n\n              {settings.translationMode === 'sentence' && (\n                <div className={styles.sentenceControls}>\n                  <button\n                    onClick={handlePreviousLine}\n                    disabled={session.currentLineIndex === 0}\n                    className={styles.navButton}\n                  >\n                    ← Previous Sentence\n                  </button>\n                  <button\n                    onClick={handleNextLine}\n                    disabled={session.currentLineIndex >= currentDialogue.lines.length - 1}\n                    className={styles.navButton}\n                  >\n                    Next Sentence →\n                  </button>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n\n      {showSettings && (\n        <UnifiedSettings\n          visible={showSettings}\n          onClose={() => setShowSettings(false)}\n          mode=\"read\"\n          deck={currentDeck}\n          settings={settings}\n          onUpdateSettings={(newSettings) => {\n            useReadStore.getState().updateSettings(newSettings as any);\n          }}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default Read;"],"names":["defaultSettings","answerType","checkMode","translationDirection","from","to","optionsCount","showPinyinDefault","multipleChoiceDifficulty","unit","translationMode","accuracyThreshold","showWordHints","useReadStore","create","persist","set","get","progress","session","settings","initSession","deckId","dialogueId","state","currentDialogueId","currentLineIndex","currentTokenIndex","showPinyin","showTranslation","correctCount","incorrectCount","startTime","Date","now","responseStartTime","responseTimes","setCurrentDialogue","currentProgress","lineIndex","tokenIndex","completedTokens","Set","masteredTokens","setCurrentLine","setCurrentToken","markTokenComplete","tokenKey","newCompletedTokens","add","markTokenMastered","newMasteredTokens","togglePinyin","toggleTranslation","updateSettings","recordAnswer","correct","responseTime","clearSession","resetProgress","newProgress","getProgress","name","version","partialize","migrate","persistedState","ReadDialoguePicker","deck","selectedDialogueId","onSelectDialogue","dialogueProgress","useMemo","reading","result","Object","entries","dialogues","forEach","dialogue","totalTokens","lines","reduce","acc","line","tokenCount","a","b","c","Array","filter","key","startsWith","length","completed","total","dialogueEntries","jsxs","className","styles","children","jsx","map","isSelected","dialogueStats","progressPercentage","displayName","replace","l","toUpperCase","Button","variant","onClick","width","height","viewBox","fill","stroke","strokeWidth","d","style","calculateSimilarity","str1","str2","normalizedStr1","normalizeText","normalizedStr2","maxLength","Math","max","distance","matrix","i","j","indicator","min","levenshteinDistance","text","toLowerCase","trim","extractWords","split","word","checkSentenceTranslation","userAnswer","targetSide","alternatives","mainText","push","wordAlignments","words","alignment","english","join","generateAlternativeAnswers","correctAnswer","accuracy","isCorrect","suggestions","bestAccuracy","bestCorrectAnswer","alternative","wordMatches","userWords","correctWords","matchedCorrectWords","userWord","bestMatch","bestSimilarity","correctWord","has","similarity","matched","calculateWordMatches","round","slice","extractAlignedTokens","index","chinese","pinyin","hasWordAlignments","Boolean","SentenceTranslation","allLines","onAnswer","onSkip","showResult","disabled","setUserAnswer","useState","selectedOption","setSelectedOption","setResult","sourceText","mcOptions","difficulty","options","usedAnswers","potentialDistractors","keys","side","otherLine","shuffledDistractors","sort","random","generateSentenceMultipleChoice","hasAlignments","alignedTokens","handleSubmit","useCallback","translationResult","handleOptionSelect","option","setTimeout","handleTextChange","e","target","value","handleKeyPress","shiftKey","preventDefault","handleWordClick","chineseWord","find","translation","getWordHint","useEffect","canSubmit","token","title","onChange","onKeyPress","placeholder","rows","fromCharCode","match","suggestion","DEFAULT_TOKENIZATION","f","preservePunctuation","isCJKCharacter","char","code","charCodeAt","tokenizeByCharacter","tokens","test","start","end","tokenizeByWord","currentWord","wordStart","wordText","tokenizeBySpace","tokenizeSmart","totalChars","cjkChars","tokenizeWithWordAlignments","chinesePos","pinyinPos","englishPos","normalized","opts","caseSensitive","removeSpaces","removePunctuation","calculateEditDistance","m","n","dp","normalizePinyin","isAnswerClose","maxEditDistance","normalizedUser","normalizedCorrect","floor","isPinyinAnswerClose","ReadToken","isActive","isCompleted","onClose","onComplete","targetText","pinyinText","translationText","showAnswer","setShowAnswer","setIsCorrect","setMcOptions","popupPosition","setPopupPosition","top","left","tokenRef","useRef","isPunctuation","shouldSkipToken","source","distractorPool","num","parseInt","toString","pinyinSyllables","extendedPinyin","syllable","includes","pronouns","verbs","adjectives","articles","prepositions","adverbs","availableDisractors","randomIndex","distractor","splice","fallbackOptions","fallback","current","rect","getBoundingClientRect","viewportHeight","window","innerHeight","viewportWidth","innerWidth","bottom","popupWidth","answer","handleReveal","handleMCSelect","ref","position","transform","stopPropagation","type","autoFocus","size","idx","AlignedReadLine","onTokenClick","onTokenComplete","createInteractiveTokens","lineTokens","config","tokenization","tokenConfig","sideIds","tokenizeLine","sourceTokens","alignedToken","sourceSide","targetTokens","pinyinTokens","handleTokenClick","handleTokenComplete","getTargetForSourceToken","sourceIndex","targetToken","getPinyinForSourceToken","pinyinToken","getSideLabel","sideId","sides","EnhancedReadLine","onNext","_onNext","handleSentenceAnswer","renderContent","ReadControls","canGoPrevious","canGoNext","onPrevious","onTogglePinyin","onToggleTranslation","cx","cy","r","x1","y1","x2","y2","ReadProgress","totalLines","Fragment","toFixed","Read","useParams","navigate","useNavigate","currentDeck","isLoading","error","loadDeck","useDeckStore","showSettings","setShowSettings","setSelectedDialogueId","dialogueIds","savedProgress","currentDialogue","currentLine","handleSelectDialogue","handlePreviousLine","handleNextLine","handleKeyDown","tagName","isContentEditable","addEventListener","removeEventListener","PageHeader","metadata","deck_name","subtitle","onBackClick","backLabel","rightContent","SettingsIcon","nextTokenIndex","UnifiedSettings","visible","mode","onUpdateSettings","newSettings","getState"],"mappings":"kOAoDA,MAAMA,EAAoC,CACxCC,WAAY,YACZC,UAAW,OACXC,qBAAsB,CAAEC,KAAM,IAAKC,GAAI,KACvCC,aAAc,EACdC,mBAAmB,EACnBC,yBAA0B,SAC1BC,KAAM,YACNC,gBAAiB,WACjBC,kBAAmB,GACnBC,eAAe,GAGJC,EAAeC,IAC1BC,EACE,CAACC,EAAKC,KAAA,CACJC,SAAU,CAAA,EACVC,QAAS,KACTC,SAAUpB,EAEVqB,YAAa,CAACC,EAAgBC,KAC5BP,EAAIQ,IAAA,CACFL,QAAS,CACPG,SACAG,kBAAmBF,EACnBG,iBAAkB,EAClBC,kBAAmB,EACnBC,WAAYJ,EAAMJ,SAASb,kBAC3BsB,iBAAiB,EACjBC,aAAc,EACdC,eAAgB,EAChBC,UAAWC,KAAKC,MAChBC,kBAAmBF,KAAKC,MACxBE,cAAe,QAKrBC,mBAAqBd,IACnBP,EAAIQ,IACF,IAAKA,EAAML,QAAS,OAAOK,EAG3B,MAAMF,EAASE,EAAML,QAAQG,OACvBgB,EAAkBd,EAAMN,SAASI,IAAW,CAChDC,aACAgB,UAAW,EACXC,WAAY,EACZC,oBAAqBC,IACrBC,mBAAoBD,KAGtB,MAAO,CACLxB,SAAU,IACLM,EAAMN,SACTI,CAACA,GAAS,IACLgB,EACHf,eAGJJ,QAAS,IACJK,EAAML,QACTM,kBAAmBF,EACnBG,iBAAkB,EAClBC,kBAAmB,OAM3BiB,eAAiBL,IACfvB,EAAIQ,IACF,IAAKA,EAAML,QAAS,OAAOK,EAE3B,MAAMF,EAASE,EAAML,QAAQG,OACvBC,EAAaC,EAAML,QAAQM,mBAAqB,GAChDa,EAAkBd,EAAMN,SAASI,IAAW,CAChDC,aACAgB,UAAW,EACXC,WAAY,EACZC,oBAAqBC,IACrBC,mBAAoBD,KAGtB,MAAO,CACLxB,SAAU,IACLM,EAAMN,SACTI,CAACA,GAAS,IACLgB,EACHC,cAGJpB,QAAS,IACJK,EAAML,QACTO,iBAAkBa,EAClBZ,kBAAmB,OAM3BkB,gBAAkBL,IAChBxB,EAAIQ,IACF,IAAKA,EAAML,QAAS,OAAOK,EAE3B,MAAMF,EAASE,EAAML,QAAQG,OACvBC,EAAaC,EAAML,QAAQM,mBAAqB,GAChDc,EAAYf,EAAML,QAAQO,iBAC1BY,EAAkBd,EAAMN,SAASI,IAAW,CAChDC,aACAgB,YACAC,WAAY,EACZC,oBAAqBC,IACrBC,mBAAoBD,KAGtB,MAAO,CACLxB,SAAU,IACLM,EAAMN,SACTI,CAACA,GAAS,IACLgB,EACHE,eAGJrB,QAAS,IACJK,EAAML,QACTQ,kBAAmBa,EACnBL,kBAAmBF,KAAKC,WAMhCY,kBAAmB,CAACvB,EAAoBgB,EAAmBC,KACzDxB,EAAIQ,IACF,IAAKA,EAAML,QAAS,OAAOK,EAE3B,MAAMF,EAASE,EAAML,QAAQG,OACvByB,EAAW,GAAGxB,KAAcgB,KAAaC,IACzCF,EAAkBd,EAAMN,SAASI,IAAW,CAChDC,aACAgB,UAAW,EACXC,WAAY,EACZC,oBAAqBC,IACrBC,mBAAoBD,KAGhBM,EAAqB,IAAIN,IAAIJ,EAAgBG,iBAGnD,OAFAO,EAAmBC,IAAIF,GAEhB,CACL7B,SAAU,IACLM,EAAMN,SACTI,CAACA,GAAS,IACLgB,EACHG,gBAAiBO,QAO3BE,kBAAmB,CAAC3B,EAAoBgB,EAAmBC,KACzDxB,EAAIQ,IACF,IAAKA,EAAML,QAAS,OAAOK,EAE3B,MAAMF,EAASE,EAAML,QAAQG,OACvByB,EAAW,GAAGxB,KAAcgB,KAAaC,IACzCF,EAAkBd,EAAMN,SAASI,IAAW,CAChDC,aACAgB,UAAW,EACXC,WAAY,EACZC,oBAAqBC,IACrBC,mBAAoBD,KAGhBS,EAAoB,IAAIT,IAAIJ,EAAgBK,gBAClDQ,EAAkBF,IAAIF,GAEtB,MAAMC,EAAqB,IAAIN,IAAIJ,EAAgBG,iBAGnD,OAFAO,EAAmBC,IAAIF,GAEhB,CACL7B,SAAU,IACLM,EAAMN,SACTI,CAACA,GAAS,IACLgB,EACHG,gBAAiBO,EACjBL,eAAgBQ,QAO1BC,aAAc,KACZpC,EAAIQ,GACGA,EAAML,QAEJ,CACLA,QAAS,IACJK,EAAML,QACTS,YAAaJ,EAAML,QAAQS,aALJJ,IAW/B6B,kBAAmB,KACjBrC,EAAIQ,GACGA,EAAML,QAEJ,CACLA,QAAS,IACJK,EAAML,QACTU,iBAAkBL,EAAML,QAAQU,kBALTL,IAW/B8B,eAAiBlC,IACfJ,EAAIQ,IAAA,CACFJ,SAAU,IACLI,EAAMJ,YACNA,GAGLD,QAASK,EAAML,cAA0C,IAA/BC,EAASb,kBAC/B,IACKiB,EAAML,QACTS,WAAYR,EAASb,mBAEvBiB,EAAML,YAIdoC,aAAc,CAACC,EAAkBC,KAC/BzC,EAAIQ,GACGA,EAAML,QAEJ,CACLA,QAAS,IACJK,EAAML,QACTW,aAAcN,EAAML,QAAQW,cAAgB0B,EAAU,EAAI,GAC1DzB,eAAgBP,EAAML,QAAQY,gBAAkByB,EAAU,EAAI,GAC9DpB,cAAe,IAAIZ,EAAML,QAAQiB,cAAeqB,KAPzBjC,IAa/BkC,aAAc,KACZ1C,EAAI,CAAEG,QAAS,QAGjBwC,cAAgBrC,IACdN,EAAIQ,IACF,MAAMoC,EAAc,IAAKpC,EAAMN,UAE/B,cADO0C,EAAYtC,GACZ,CAAEJ,SAAU0C,MAIvBC,YAAcvC,GACLL,IAAMC,SAASI,IAAW,OAGrC,CACEwC,KAAM,aACNC,QAAS,EACTC,WAAYxC,IAAA,CACVN,SAAUM,EAAMN,SAChBE,SAAUI,EAAMJ,WAElB6C,QAAS,CAACC,EAAqBH,IACzBA,EAAU,EAEL,IACFG,EACH9C,SAAU,IACLpB,KACAkE,EAAe9C,SAClBV,gBAAiBwD,EAAe9C,UAAUV,iBAAmB,WAC7DC,kBAAmBuD,EAAe9C,UAAUT,mBAAqB,GACjEC,eAA0D,IAA3CsD,EAAe9C,UAAUR,gBAIvCsD,gXChUFC,EAAgC,EAC3CC,OACAC,qBACAC,mBACApD,eAGA,MAAMqD,EAAmBC,EAAAA,QAAQ,KAC/B,IAAKJ,EAAKK,QAAS,MAAO,CAAA,EAE1B,MAAMC,EAA+D,CAAA,EAwBrE,OAtBAC,OAAOC,QAAQR,EAAKK,QAAQI,WAAWC,QAAQ,EAAEvD,EAAYwD,MAC3D,MAAMC,EAAcD,EAASE,MAAMC,OAAO,CAACC,EAAKC,KAE9C,IAAIC,EAAa,EAIjB,OAHID,EAAKE,GAAGD,IACRD,EAAKG,GAAGF,IACRD,EAAKI,GAAGH,IACLF,EAAME,GACZ,GAEG5C,EAAkBvB,GAAUuB,gBAC9BgD,MAAMrF,KAAKc,EAASuB,iBAAiBiD,OAAOC,GAC1CA,EAAIC,WAAW,GAAGrE,OAClBsE,OACF,EAEJnB,EAAOnD,GAAc,CACnBuE,UAAWrD,EACXsD,MAAOf,KAIJN,GACN,CAACN,EAAMlD,IAEV,IAAKkD,EAAKK,QAAS,OAAO,KAE1B,MAAMuB,EAAkBrB,OAAOC,QAAQR,EAAKK,QAAQI,WAEpD,OACEoB,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAC,EAAAA,IAAC,KAAA,CAAGH,UAAWC,EAAcC,SAAA,cAC7BC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EACbC,SAAAJ,EAAgBM,IAAI,EAAE/E,EAAYwD,MACjC,MAAMwB,EAAalC,IAAuB9C,EACpCiF,EAAgBjC,EAAiBhD,GACjCkF,EAAqBD,EACtBA,EAAcV,UAAYU,EAAcT,MAAS,IAClD,EAGEW,EAAcnF,EACjBoF,QAAQ,gBAAiB,eACzBA,QAAQ,KAAM,KACdA,QAAQ,QAASC,GAAKA,EAAEC,eAE3B,OACER,EAAAA,IAACS,EAAA,CAECC,QAASR,EAAa,UAAY,YAClCL,UAAW,GAAGC,KAAyBI,EAAaJ,EAAkB,KACtEa,QAAS,IAAM1C,EAAiB/C,GAEhC6E,SAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,EAAsBC,SAAAM,IACf,MAAvBD,GACCJ,MAAC,MAAA,CAAIY,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAAIpB,UAAWC,EAC3GC,SAAAC,EAAAA,IAAC,OAAA,CAAKkB,EAAE,yBAIdtB,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAH,EAAAA,KAAC,OAAA,CAAKC,UAAWC,EACdC,SAAA,CAAArB,EAASE,MAAMY,OAAO,YAExBW,GAAiBA,EAAcV,UAAY,UACzC,OAAA,CAAKI,UAAWC,EACdC,SAAA,CAAAI,EAAcV,UAAU,IAAEU,EAAcT,MAAM,gBAIpDU,EAAqB,GAAKA,EAAqB,WAC7C,MAAA,CAAIP,UAAWC,EACdC,SAAAC,EAAAA,IAAC,MAAA,CACCH,UAAWC,EACXqB,MAAO,CAAEP,MAAO,GAAGR,cA5BtBlF,WChDnB,SAASkG,EAAoBC,EAAcC,GACzC,MAAMC,EAAiBC,EAAcH,GAC/BI,EAAiBD,EAAcF,GAErC,GAAIC,IAAmBE,EAAgB,OAAO,IAC9C,GAA8B,IAA1BF,EAAe/B,QAA0C,IAA1BiC,EAAejC,OAAc,OAAO,IACvE,GAA8B,IAA1B+B,EAAe/B,QAA0C,IAA1BiC,EAAejC,OAAc,OAAO,EAEvE,MAAMkC,EAAYC,KAAKC,IAAIL,EAAe/B,OAAQiC,EAAejC,QAC3DqC,EArCR,SAA6B5C,EAAWC,GACtC,MAAM4C,EAAS1C,MAAMF,EAAEM,OAAS,GAAGuB,KAAK,MAAMd,IAAI,IAAMb,MAAMH,EAAEO,OAAS,GAAGuB,KAAK,OAEjF,IAAA,IAASgB,EAAI,EAAGA,GAAK9C,EAAEO,OAAQuC,GAAK,EAClCD,EAAO,GAAGC,GAAKA,EAGjB,IAAA,IAASC,EAAI,EAAGA,GAAK9C,EAAEM,OAAQwC,GAAK,EAClCF,EAAOE,GAAG,GAAKA,EAGjB,IAAA,IAASA,EAAI,EAAGA,GAAK9C,EAAEM,OAAQwC,GAAK,EAClC,IAAA,IAASD,EAAI,EAAGA,GAAK9C,EAAEO,OAAQuC,GAAK,EAAG,CACrC,MAAME,EAAYhD,EAAE8C,EAAI,KAAO7C,EAAE8C,EAAI,GAAK,EAAI,EAC9CF,EAAOE,GAAGD,GAAKJ,KAAKO,IAClBJ,EAAOE,GAAGD,EAAI,GAAK,EACnBD,EAAOE,EAAI,GAAGD,GAAK,EACnBD,EAAOE,EAAI,GAAGD,EAAI,GAAKE,EAE3B,CAGF,OAAOH,EAAO5C,EAAEM,QAAQP,EAAEO,OAC5B,CAcmB2C,CAAoBZ,EAAgBE,GAErD,OAAOE,KAAKC,IAAI,GAAIF,EAAYG,GAAYH,EAAY,IAC1D,CAKA,SAASF,EAAcY,GACrB,OAAOA,EACJC,cACAC,OACAhC,QAAQ,0CAA2C,IACnDA,QAAQ,OAAQ,KAChBgC,MACL,CAKA,SAASC,EAAaH,GACpB,OAAOZ,EAAcY,GAClBI,MAAM,OACNnD,OAAOoD,GAAQA,EAAKjD,OAAS,EAClC,CA0EO,SAASkD,EACdC,EACA5D,EACA6D,EACAtI,EAA4B,IAE5B,MAAMuI,EAhCR,SAAoC9D,EAAmB6D,GACrD,MAAMC,EAAyB,GAGzBC,EAAW/D,EAAK6D,GAMtB,GALIE,GACFD,EAAaE,KAAKD,GAIhB/D,EAAKiE,gBAAiC,MAAfJ,EAAoB,CAC7C,MAAMK,EAAQlE,EAAKiE,eAChB3D,OAAO6D,GAAaA,EAAUC,QAAQb,OAAO9C,OAAS,GACtDS,OAAiBiD,EAAUC,QAAQb,QAElCW,EAAMzD,OAAS,GACjBqD,EAAaE,KAAKE,EAAMG,KAAK,KAEjC,CAEA,MAAO,IAAI,IAAI/G,IAAIwG,GACrB,CAWuBQ,CAA2BtE,EAAM6D,GAChDU,EAAgBT,EAAa,IAAM,GAEzC,IAAKS,EACH,MAAO,CACLX,aACAW,cAAe,GACfC,SAAU,EACVC,WAAW,EACXC,YAAa,IAKjB,IAAIC,EAAe,EACfC,EAAoBL,EAExBT,EAAapE,QAAQmF,IACnB,MAAML,EAAWnC,EAAoBuB,EAAYiB,GAC7CL,EAAWG,IACbA,EAAeH,EACfI,EAAoBC,KAIxB,MAAMC,EApGR,SAA8BlB,EAAoBW,GAKhD,MAAMQ,EAAYvB,EAAaI,GACzBoB,EAAexB,EAAae,GAC5BU,MAA0B3H,IAEhC,OAAOyH,EAAU7D,IAAIgE,IAEnB,IAAIC,EAA2B,KAC3BC,EAAiB,EAYrB,OAVAJ,EAAatF,QAAQ2F,IACnB,GAAIJ,EAAoBK,IAAID,GAAc,OAE1C,MAAME,EAAalD,EAAoB6C,EAAUG,GAC7CE,EAAaH,GAAkBG,GAAc,KAC/CJ,EAAYE,EACZD,EAAiBG,KAIjBJ,GACFF,EAAoBpH,IAAIsH,GACjB,CACLzB,KAAMwB,EACNM,SAAS,EACTD,WAAYH,IAIT,CACL1B,KAAMwB,EACNM,SAAS,IAGf,CA8DsBC,CAAqB7B,EAAYgB,GAC/CH,EAAYE,GAAgBpJ,EAElC,MAAO,CACLqI,aACAW,cAAeK,EACfJ,SAAU5B,KAAK8C,MAAMf,GACrBF,YACAK,cACAJ,YAAaZ,EAAa6B,MAAM,GAEpC,CCzKO,SAASC,EAAqB5F,GACnC,OAAKA,EAAKiE,gBAAiD,IAA/BjE,EAAKiE,eAAexD,OAIzCT,EAAKiE,eAAe/C,IAAI,CAACiD,EAAW0B,KAAA,CACzCC,QAAS3B,EAAU2B,QACnBC,OAAQ5B,EAAU4B,OAClB3B,QAASD,EAAUC,QACnByB,WAPO,EASX,CAKO,SAASG,EAAkBhG,GAChC,OAAOiG,QAAQjG,EAAKiE,gBAAkBjE,EAAKiE,eAAexD,OAAS,EACrE,woCCdayF,GAAiC,EAC5ClG,OACAmG,WACAnK,WACAoK,WACAC,SACAC,cAAa,EACbC,YAAW,MAEX,MAAO3C,EAAY4C,GAAiBC,EAAAA,SAAS,KACtCC,EAAgBC,GAAqBF,EAAAA,SAAwB,OAC7DnH,EAAQsH,GAAaH,EAAAA,SAA2C,MAIjEI,EAAa7G,EAAKhE,EAASjB,qBAAqBC,OAAS,GAIzD8L,EAAY1H,EAAAA,QAAQ,IACI,oBAAxBpD,EAASnB,WFsJV,SACLmF,EACA6D,EACAsC,EACAjL,EAAuB,EACvB6L,EAAyC,UAEzC,MAAMxC,EAAgBvE,EAAK6D,GAC3B,IAAKU,EAAe,MAAO,GAE3B,MAAMyC,EAAU,CAACzC,GACX0C,EAAc,IAAI3J,IAAI,CAACmF,EAAc8B,KAGrC2C,EAAiC,GAEpB,SAAfH,GAEFxH,OAAO4H,KAAKnH,GAAMN,QAAQ0H,IACxB,GAAIA,IAASvD,GAAyD,iBAApC7D,EAAKoH,GAAyC,CAC9E,MAAM/D,EAAOrD,EAAKoH,GACd/D,IAAS4D,EAAY3B,IAAI7C,EAAcY,KACzC6D,EAAqBlD,KAAKX,EAE9B,IAKJ8C,EAASzG,QAAQ2H,IACf,GAAIA,IAAcrH,EAAM,OAExB,MAAMqD,EAAOgE,EAAUxD,GACnBR,IAAS4D,EAAY3B,IAAI7C,EAAcY,KACzC6D,EAAqBlD,KAAKX,KAK9B,MAAMiE,EAAsBJ,EACzBK,KAAK,IAAM3E,KAAK4E,SAAW,IAC3B7B,MAAM,EAAGzK,EAAe,GAK3B,OAHA8L,EAAQhD,QAAQsD,GAGTN,EAAQO,KAAK,IAAM3E,KAAK4E,SAAW,GAC5C,CEpMaC,CACLzH,EACAhE,EAASjB,qBAAqBE,GAC9BkL,EACAnK,EAASd,cAAgB,EACzBc,EAASZ,0BAA4B,UAGlC,GACN,CAAC4E,EAAMmG,EAAUnK,IAGd0L,EAAgBtI,EAAAA,QAAQ,IAAM4G,EAAkBhG,GAAO,CAACA,IACxD2H,EAAgBvI,EAAAA,QAAQ,IACrBsI,EAAgB9B,EAAqB5F,GAAQ,GACnD,CAACA,EAAM0H,IAGJE,EAAeC,EAAAA,YAAY,KAC/B,GAAItB,GAAYjH,EAAQ,OAExB,MACMwI,EAAoBnE,EADa,oBAAxB3H,EAASnB,WAAmC6L,GAAkB,GAAK9C,EAGhF5D,EACAhE,EAASjB,qBAAqBE,GAC9Be,EAAST,mBAAqB,IAGhCqL,EAAUkB,GACV1B,EAAS0B,IACR,CAAClE,EAAY8C,EAAgB1K,EAAUgE,EAAMoG,EAAUG,EAAUjH,IAG9DyI,EAAqBF,cAAaG,IAClCzB,GAAYjH,IAChBqH,EAAkBqB,GAES,SAAvBhM,EAASlB,WAEXmN,WAAW,KACT,MAAMH,EAAoBnE,EACxBqE,EACAhI,EACAhE,EAASjB,qBAAqBE,GAC9Be,EAAST,mBAAqB,IAEhCqL,EAAUkB,GACV1B,EAAS0B,IACR,OAEJ,CAAC9L,EAAUgE,EAAMoG,EAAUG,EAAUjH,IAGlC4I,EAAmBL,cAAaM,IAChC5B,GAAYjH,IAChBkH,EAAc2B,EAAEC,OAAOC,OAEI,SAAvBrM,EAASlB,WAAwBqN,EAAEC,OAAOC,MAAM9E,SAGnD,CAACvH,EAAUuK,EAAUjH,IAGlBgJ,EAAiBT,cAAaM,IACpB,UAAVA,EAAE5H,KAAoB4H,EAAEI,WAC1BJ,EAAEK,iBACFZ,MAED,CAACA,IAGEa,EAAkBZ,cAAaa,IACnC,IAAK1M,EAASR,gBAAkBkM,EAAe,QFgI5C,SACL1H,EACA0I,EACA7E,GAEA,IAAK7D,EAAKiE,eAAgB,OAAO,KAEjC,MAAME,EAAYnE,EAAKiE,eAAe0E,KACpCxE,GAAaA,EAAU2B,UAAY4C,GAGrC,IAAKvE,EAAW,OAAO,KAEvB,MAAM7E,EAAoD,CAAA,EAEtD6E,EAAU4B,QAAU5B,EAAU4B,OAAOxC,SACvCjE,EAAOyG,OAAS5B,EAAU4B,QAGT,MAAflC,GAAsBM,EAAUC,SAAWD,EAAUC,QAAQb,SAC/DjE,EAAOsJ,YAAczE,EAAUC,SAG1B7E,OAAO4H,KAAK7H,GAAQmB,MAC7B,CEtJiBoI,CAAY7I,EAAM0I,EAAa1M,EAASjB,qBAAqBE,KAKzE,CAAC+E,EAAMhE,EAAU0L,IAGpBoB,EAAAA,UAAU,KACRtC,EAAc,IACdG,EAAkB,MAClBC,EAAU,OAET,CAAC5G,IAEJ,MAAM+I,EAAoC,oBAAxB/M,EAASnB,WACJ,OAAnB6L,EACA9C,EAAWL,OAAO9C,OAAS,EAE/B,OACEI,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EAEdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EAAqBC,SAAA,6BAGrCC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EACbC,SAAA0G,GAAiB1L,EAASR,cACzBqF,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EACbC,WAAcE,IAAI,CAAC8H,EAAOnD,IACzB5E,EAAAA,IAAC,OAAA,CAECH,UAAW,GAAGC,KAAoBiI,EAAM5E,QAAUrD,EAAmBA,IACrEa,QAAS,IAAM6G,EAAgBO,EAAMlD,SACrCmD,MAAOD,EAAM5E,QAAU,GAAG4E,EAAMjD,YAAYiD,EAAM5E,eAAY,EAE7DpD,SAAAgI,EAAMlD,SALFD,MASX5E,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EAAiBC,SAAA,2BAKnCC,MAAC,MAAA,CAAIH,UAAWC,EAAsBC,kBAM5CH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,EACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EAAqBC,SAAA,sBAIZ,cAAxBhF,EAASnB,iBACP,MAAA,CAAIiG,UAAWC,EACdC,SAAAC,EAAAA,IAAC,WAAA,CACCH,UAAW,GAAGC,KAAoBzB,EAASyB,EAAmB,KAC9DsH,MAAOzE,EACPsF,SAAUhB,EACViB,WAAYb,EACZc,YAAY,gCACZ7C,SAAUA,KAAcjH,EACxB+J,KAAM,MAIVpI,EAAAA,IAAC,MAAA,CAAIH,UAAWC,EACbC,SAAA8F,EAAU5F,IAAI,CAAC8G,EAAQnC,IACtBhF,EAAAA,KAAC,SAAA,CAECC,UAAW,GAAGC,KACZ2F,IAAmBsB,EAASjH,EAAkB,MAC5CzB,EACF0I,IAAW1I,EAAOiF,cAAgBxD,EAClC2F,IAAmBsB,EAASjH,EAAmB,GAC7C,KACJa,QAAS,IAAMmG,EAAmBC,GAClCzB,SAAUA,KAAcjH,EAExB0B,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GACdC,gBAAOsI,aAAa,GAAKzD,KAE5B5E,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAoBC,SAAAgH,MAbhCnC,UAqBbvG,GACAuB,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACbC,SAAA,CAAuB,SAAvBhF,EAASlB,WACRmG,EAAAA,IAACS,EAAA,CACCC,QAAQ,UACRC,QAASgG,EACTrB,UAAWwC,GAAaxC,EACxBzF,UAAWC,GACZC,SAAA,iBAIFqF,GACCpF,EAAAA,IAACS,EAAA,CACCC,QAAQ,YACRC,QAASyE,EACTE,WACAzF,UAAWC,GACZC,SAAA,YAQN1B,GAAUgH,GACTzF,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAW,GAAGC,MAAuBzB,EAAOmF,UAAY1D,EAAiBA,IAC5EC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACbC,SAAA,CAAA1B,EAAOkF,SAAS,gBAEnBvD,EAAAA,IAAC,OAAIH,UAAWC,GACbC,SAAA1B,EAAOmF,UAAY,WAAa,0BAInCnF,EAAOmF,kBACN,MAAA,CAAI3D,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAqBC,SAAA,0BACpC,MAAA,CAAIF,UAAWC,GAAqBC,WAAOuD,mBAI/CjF,EAAOwF,aAAexF,EAAOwF,YAAYrE,OAAS,GACjDI,OAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAsBC,SAAA,mBACtCC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACbC,WAAO8D,YAAY5D,IAAI,CAACqI,EAAO1D,IAC9B5E,EAAAA,IAAC,OAAA,CAECH,UAAW,GAAGC,MAAoBwI,EAAM/D,QAAUzE,GAAiBA,KACnEkI,MAAOM,EAAMhE,WAAa,GAAG3C,KAAK8C,MAAM6D,EAAMhE,0BAAuB,EAEpEvE,SAAAuI,EAAM7F,MAJFmC,SAWdvG,EAAOoF,aAAepF,EAAOoF,YAAYjE,OAAS,GACjDI,OAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAyBC,SAAA,+BACxC,MAAA,CAAIF,UAAWC,GACbC,SAAA1B,EAAOoF,YAAYxD,IAAI,CAACsI,EAAY3D,IACnC5E,MAAC,OAAgBH,UAAWC,GACzBC,SAAAwI,GADO3D,gBCtQtB4D,GAAkD,CACtDpO,KAAM,CACJ6E,EAAG,YACHC,EAAG,QACHC,EAAG,QACH+B,OAAG,EACHgG,OAAG,EACHuB,OAAG,GAELC,qBAAqB,GAIjBC,GAAkBC,IACtB,MAAMC,EAAOD,EAAKE,WAAW,GAC7B,OACGD,GAAQ,OAAUA,GAAQ,OAC1BA,GAAQ,OAAUA,GAAQ,OAC1BA,GAAQ,QAAWA,GAAQ,QAC3BA,GAAQ,QAAWA,GAAQ,QAC3BA,GAAQ,QAAWA,GAAQ,QAC3BA,GAAQ,OAAUA,GAAQ,OAC1BA,GAAQ,OAAUA,GAAQ,OAC1BA,GAAQ,OAAUA,GAAQ,OAKzBE,GAAsB,CAAC3G,EAAcsG,KACzC,MAAMM,EAAkB,GAExB,IAAA,IAASjH,EAAI,EAAGA,EAAIK,EAAK5C,OAAQuC,IAAK,CACpC,MAAM6G,EAAOxG,EAAKL,IAGb2G,GAAuB,cAAcO,KAAKL,KAK3C,KAAKK,KAAKL,IAIdI,EAAOjG,KAAK,CACVX,KAAMwG,EACNM,MAAOnH,EACPoH,IAAKpH,EAAI,IAEb,CAEA,OAAOiH,GAIHI,GAAiB,CAAChH,EAAcsG,KACpC,MAAMM,EAAkB,GACxB,IAAIK,EAAc,GACdC,EAAY,EAEhB,IAAA,IAASvH,EAAI,EAAGA,GAAKK,EAAK5C,OAAQuC,IAAK,CACrC,MAAM6G,EAAOxG,EAAKL,GAElB,GAAIA,IAAMK,EAAK5C,QAAU,KAAKyJ,KAAKL,GAAO,CACxC,GAAIS,EAAa,CAEf,IAAIE,EAAWF,EACVX,IACHa,EAAWA,EAASjJ,QAAQ,aAAc,KAGxCiJ,GACFP,EAAOjG,KAAK,CACVX,KAAMmH,EACNL,MAAOI,EACPH,IAAKG,EAAYC,EAAS/J,SAI9B6J,EAAc,EAChB,CACAC,EAAYvH,EAAI,CAClB,KACsB,KAAhBsH,IACFC,EAAYvH,GAEdsH,GAAeT,CAEnB,CAEA,OAAOI,GAIHQ,GAAkB,CAACpH,EAAcsG,IAC9BU,GAAehH,EAAMsG,GAIxBe,GAAgB,CAACrH,EAAcsG,KAEnC,MAAMgB,EAAatH,EAAK9B,QAAQ,MAAO,IAAId,OACrCmK,EAAWvK,MAAMrF,KAAKqI,GAAM/C,OAAOsJ,IAAgBnJ,OAGzD,OAAImK,EAAW,GAAKA,EAAWD,EAAa,GACnCX,GAAoB3G,EAAMsG,GAI5BU,GAAehH,EAAMsG,IA8CxBkB,GAA8B5G,IAClC,MAAM3E,EAAqB,CACzBY,EAAG,GACHC,EAAG,GACHC,EAAG,IAGL,IAAI0K,EAAa,EACbC,EAAY,EACZC,EAAa,EA4BjB,OA1BA/G,EAAevE,QAAQyE,IAErB7E,EAAOY,EAAG8D,KAAK,CACbX,KAAMc,EAAU2B,QAChBqE,MAAOW,EACPV,IAAKU,EAAa3G,EAAU2B,QAAQrF,SAEtCqK,GAAc3G,EAAU2B,QAAQrF,OAGhCnB,EAAOa,EAAG6D,KAAK,CACbX,KAAMc,EAAU4B,OAChBoE,MAAOY,EACPX,IAAKW,EAAY5G,EAAU4B,OAAOtF,SAEpCsK,GAAa5G,EAAU4B,OAAOtF,OAAS,EAGvCnB,EAAOc,EAAG4D,KAAK,CACbX,KAAMc,EAAUC,QAChB+F,MAAOa,EACPZ,IAAKY,EAAa7G,EAAUC,QAAQ3D,SAEtCuK,GAAc7G,EAAUC,QAAQ3D,OAAS,IAGpCnB,GAmDImD,GAAgB,CAACY,EAAc2D,KAK1C,IAAIiE,EAAa5H,EAEjB,MAAM6H,EAAO,CACXC,eAAe,EACfC,cAAc,EACdC,mBAAmB,KAChBrE,GAkBL,OAfKkE,EAAKC,gBACRF,EAAaA,EAAW3H,eAGtB4H,EAAKG,oBACPJ,EAAaA,EAAW1J,QAAQ,cAAe,KAI/C0J,EADEC,EAAKE,aACMH,EAAW1J,QAAQ,OAAQ,IAG3B0J,EAAW1J,QAAQ,OAAQ,KAAKgC,OAGxC0H,GAIIK,GAAwB,CAAChJ,EAAcC,KAClD,MAAMgJ,EAAIjJ,EAAK7B,OACT+K,EAAIjJ,EAAK9B,OAEf,GAAU,IAAN8K,EAAS,OAAOC,EACpB,GAAU,IAANA,EAAS,OAAOD,EAEpB,MAAME,EAAiBpL,MAAMkL,EAAI,GAC9BvJ,KAAK,MACLd,IAAI,IAAMb,MAAMmL,EAAI,GAAGxJ,KAAK,IAE/B,IAAA,IAASgB,EAAI,EAAGA,GAAKuI,EAAGvI,IAAKyI,EAAGzI,GAAG,GAAKA,EACxC,IAAA,IAASC,EAAI,EAAGA,GAAKuI,EAAGvI,IAAKwI,EAAG,GAAGxI,GAAKA,EAExC,IAAA,IAASD,EAAI,EAAGA,GAAKuI,EAAGvI,IACtB,IAAA,IAASC,EAAI,EAAGA,GAAKuI,EAAGvI,IAClBX,EAAKU,EAAI,KAAOT,EAAKU,EAAI,GAC3BwI,EAAGzI,GAAGC,GAAKwI,EAAGzI,EAAI,GAAGC,EAAI,GAEzBwI,EAAGzI,GAAGC,GAAKL,KAAKO,IACdsI,EAAGzI,EAAI,GAAGC,GAAK,EACfwI,EAAGzI,GAAGC,EAAI,GAAK,EACfwI,EAAGzI,EAAI,GAAGC,EAAI,GAAK,GAM3B,OAAOwI,EAAGF,GAAGC,IAIFE,GAAmB3F,GACvBA,EACJzC,cACA/B,QAAQ,UAAW,KACnBA,QAAQ,UAAW,KACnBA,QAAQ,UAAW,KACnBA,QAAQ,UAAW,KACnBA,QAAQ,UAAW,KACnBA,QAAQ,WAAY,KACpBA,QAAQ,SAAU,KAClBA,QAAQ,OAAQ,KAChBgC,OAwBQoI,GAAgB,CAC3B/H,EACAW,EACAqH,EAA0B,EAC1B/Q,EAAgC,UAGhC,GAAmB,WAAfA,EACF,MA5B+B,EACjC+I,EACAW,EACAqH,EAA0B,KAG1B,MAAMC,EAAiBH,GAAgB9H,GACjCkI,EAAoBJ,GAAgBnH,GAG1C,OAAIsH,IAAmBC,GAGNR,GAAsBO,EAAgBC,IACnClJ,KAAKO,IAAIyI,EAAiBhJ,KAAKmJ,MAAiC,IAA3BD,EAAkBrL,UAclEuL,CAAoBpI,EAAYW,EAAeqH,GAIxD,MAAMC,EAAiBpJ,GAAcmB,GAC/BkI,EAAoBrJ,GAAc8B,GAExC,GAAIsH,IAAmBC,EAAmB,OAAO,EAKjD,OAHiBR,GAAsBO,EAAgBC,IACnClJ,KAAKO,IAAIyI,EAAiBhJ,KAAKmJ,MAAiC,GAA3BD,EAAkBrL,ufC1VhEwL,GAAuB,EAClCC,WACAC,cACAvK,UACAwK,UACAC,aACArQ,WACA6K,aACAyF,aACAC,aACAC,sBAEA,MAAO5I,EAAY4C,GAAiBC,EAAAA,SAAS,KACtCgG,EAAYC,GAAiBjG,EAAAA,UAAS,IACtChC,EAAWkI,GAAgBlG,EAAAA,SAAyB,OACpDK,EAAW8F,GAAgBnG,EAAAA,SAAmB,KAC9CoG,EAAeC,GAAoBrG,EAAAA,SAAS,CAAEsG,IAAK,EAAGC,KAAM,IAC7DC,EAAWC,EAAAA,OAAuB,MAGlCC,EAAiB9J,GACd,4CAA4C6G,KAAK7G,GAIpD+J,EAAkB,CAACC,EAAgBjF,OAEnC+E,EAAcE,KAAWF,EAAc/E,OAEtCA,IAAWA,EAAO7E,QAKzBuF,EAAAA,UAAU,KACR,GAA4B,oBAAxB9M,EAASnB,YAAoCqR,GAAYI,EAAY,CAEvE,GAAIc,EAAgBvG,EAAYyF,GAK9B,YAHID,GACFpE,WAAW,IAAMoE,IAAc,MAMnC,MAAMrF,EAAU,CAACsF,GAGjB,IAAIgB,EAA2B,GAC/B,MAAMzJ,EAAa7H,EAASjB,qBAAqBE,GAGjD,GAAI,QAAQiP,KAAKoC,GAAa,CAE5B,MAAMiB,EAAMC,SAASlB,GACrBgB,EAAiB,EACdC,EAAM,GAAGE,YACTF,EAAM,GAAGE,YACH,EAANF,GAASE,YACTF,EAAM,IAAIE,WACX7K,KAAKmJ,MAAMwB,EAAM,GAAGE,YACpBnN,OAAOkL,GAAKA,IAAMc,GAAckB,SAAShC,IAAM,EACnD,MAAA,GAEwB,MAAf3H,EAAoB,CAE3B,MAAM6J,EAAkB,CACtB,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MAAO,KAAM,KACzD,MAAO,QAAS,MAAO,MAAO,KAAM,MAAO,MAAO,MAAO,KAAM,MAC/D,MAAO,OAAQ,MAAO,MAAO,KAAM,MAAO,MAAO,MAAO,MAAO,OAC/D,KAAM,OAAQ,MAAO,KAAM,OAAQ,OAAQ,OAAQ,MAAO,MAAO,MACjE,MAAO,OAAQ,QAAS,OAAQ,OAAQ,MAAO,KAAM,MAAO,QAAS,OACrE,OAAQ,MAAO,MAAO,MAAO,OAAQ,KAAM,MAAO,MAAO,MAAO,MAChE,OAAQ,KAAM,QAAS,MAAO,KAAM,MAAO,MAAO,OAAQ,QAAS,QAG/DC,EAAiB,IAAID,GAC3BA,EAAgBhO,QAAQkO,IAClBA,EAASC,SAAS,MACpBF,EAAe3J,KAAK4J,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,MAE5HqM,EAASC,SAAS,MACpBF,EAAe3J,KAAK4J,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,MAE5HqM,EAASC,SAAS,MACpBF,EAAe3J,KAAK4J,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,MAE5HqM,EAASC,SAAS,MACpBF,EAAe3J,KAAK4J,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,MAE5HqM,EAASC,SAAS,MACpBF,EAAe3J,KAAK4J,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,KAAMqM,EAASrM,QAAQ,IAAK,QAGlI+L,EAAiBK,CACnB,MAAA,GACwB,MAAf9J,EAEPyJ,EAAiB,CACf,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,UAM/C,GAAIhB,EAAW7L,QAAU,EACvB6M,EAAiB,CACf,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpD,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,UAEnD,CAEL,MAAMQ,EAAW,CAAC,IAAK,MAAO,KAAM,MAAO,KAAM,KAAM,OAAQ,KAAM,MAAO,MAAO,KAAM,QACnFC,EAAQ,CAAC,KAAM,MAAO,MAAO,OAAQ,OAAQ,MAAO,MAAO,KAAM,OAAQ,MAAO,OAAQ,MAAO,QAAS,QAAS,SAAU,OAAQ,OAAQ,OAAQ,MAAO,KAAM,OAAQ,MAAO,OAAQ,QAAS,QAChMC,EAAa,CAAC,OAAQ,MAAO,MAAO,QAAS,MAAO,MAAO,QAAS,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,OAAQ,YAAa,QACvIC,EAAW,CAAC,MAAO,IAAK,KAAM,OAAQ,OAAQ,QAAS,SACvDC,EAAe,CAAC,KAAM,KAAM,KAAM,KAAM,MAAO,OAAQ,OAAQ,KAAM,QAAS,OAAQ,UAAW,SAAU,SAAU,SACrHC,EAAU,CAAC,OAAQ,SAAU,QAAS,MAAO,KAAM,OAAQ,QAAS,UAAW,MAAO,OAAQ,OAAQ,OAAQ,QAAS,SAAU,aAIrIb,EADEQ,EAASD,SAASvB,EAAWhJ,eACdwK,EACRC,EAAMF,SAASvB,EAAWhJ,eAClByK,EACRC,EAAWH,SAASvB,EAAWhJ,eACvB0K,EACRC,EAASJ,SAASvB,EAAWhJ,eACrB2K,EACRC,EAAaL,SAASvB,EAAWhJ,eACzB4K,EACRC,EAAQN,SAASvB,EAAWhJ,eACpB6K,EAGA,IAAIJ,EAAMpI,MAAM,EAAG,MAAOqI,EAAWrI,MAAM,EAAG,MAAOmI,EAASnI,MAAM,EAAG,GAE5F,CAIF,MAAMyI,EAAsBd,EAAehN,OAAO6B,GAChDA,EAAEmB,gBAAkBgJ,EAAWhJ,eAGjC,KAAO0D,EAAQvG,QAAUzE,EAASd,cAAgB,IAAMkT,EAAoB3N,OAAS,GAAG,CACtF,MAAM4N,EAAczL,KAAKmJ,MAAMnJ,KAAK4E,SAAW4G,EAAoB3N,QAC7D6N,EAAaF,EAAoBC,GAClCrH,EAAQ6G,SAASS,KACpBtH,EAAQhD,KAAKsK,GACbF,EAAoBG,OAAOF,EAAa,GAE5C,CAGA,KAAOrH,EAAQvG,QAAUzE,EAASd,cAAgB,IAAI,CACpD,IAAIsT,EAGFA,EAFiB,MAAf3K,EAEgB,CAAC,SAAU,OAAQ,QAAS,QACtB,MAAfA,EAES,CAAC,KAAM,KAAM,KAAM,KAGnB,CAAC,YAAa,UAAW,WAAY,cAEzD,MAAM4K,EAAWD,EAAgBxH,EAAQvG,OAAS,IAAM,SAASuG,EAAQvG,SACpEuG,EAAQ6G,SAASY,IACpBzH,EAAQhD,KAAKyK,EAEjB,CAGA7B,EAAa5F,EAAQO,KAAK,IAAM3E,KAAK4E,SAAW,IAClD,GACC,CAAC0E,EAAUlQ,EAAUsQ,EAAYzF,EAAYjF,IAGhDkH,EAAAA,UAAU,KACR,GAAIoD,GAAYe,EAASyB,QAAS,CAChC,MAAMC,EAAO1B,EAASyB,QAAQE,wBACxBC,EAAiBC,OAAOC,YACxBC,EAAgBF,OAAOG,WAG7B,IAAIlC,EAAM4B,EAAKO,OAAS,GACpBlC,EAAO2B,EAAK3B,KAAQ2B,EAAK9M,MAAQ,EAGjCkL,EAAM,IAAM8B,IACd9B,EAAM4B,EAAK5B,IAAM,KAInB,MAAMoC,EAAa,IACfnC,EAAQmC,EAAa,EAAK,GAC5BnC,EAAOmC,EAAa,EAAI,GACfnC,EAAQmC,EAAa,EAAKH,EAAgB,KACnDhC,EAAOgC,EAAiBG,EAAa,EAAK,IAG5CrC,EAAiB,CAAEC,MAAKC,QAC1B,GACC,CAACd,IAGJ,MAAMtE,EAAeC,cAAauH,IAEhC,GAA2B,SAAvBpT,EAASlB,UAAsB,CAGjC,MAAMD,EAAkD,MAArCmB,EAASjB,qBAAqBE,GAAa,SAAW,OACnEmD,EAAUuN,GAAcyD,EAAQ9C,EAAY,EAAGzR,GACrD8R,EAAavO,GACbsO,GAAc,EAGhB,MAEElG,EAAc4I,IAEf,CAACpT,EAAUsQ,EAAYzF,IAGpBwI,EAAexH,EAAAA,YAAY,KAC/B,GAAIjE,EAAY,CAEd,MAAM/I,EAAkD,MAArCmB,EAASjB,qBAAqBE,GAAa,SAAW,OACnEmD,EAAUuN,GAAc/H,EAAY0I,EAAY,EAAGzR,GACzD8R,EAAavO,GACbsO,GAAc,GAGVtO,GAAWiO,GACbpE,WAAW,KACToE,KACC,IAEP,MACEK,GAAc,IAEf,CAAC9I,EAAY0I,EAAYtQ,EAAUqQ,IAGhCiD,EAAiBzH,cAAaG,IAElC,MAAMnN,EAAkD,MAArCmB,EAASjB,qBAAqBE,GAAa,SAAW,OACnEmD,EAAUuN,GAAc3D,EAAQsE,EAAY,EAAGzR,GACrD8R,EAAavO,GACbsO,GAAc,GACdlG,EAAcwB,GAGV5J,GAAWiO,GACbpE,WAAW,KACToE,KACC,MAEJ,CAACC,EAAYtQ,EAAUqQ,IAE1B,OACExL,EAAAA,KAAC,MAAA,CACC0O,IAAKtC,EACLnM,UAAW,aACPC,eACAmL,EAAWnL,GAAgB,eAC3BoL,EAAcpL,GAAmB,gBACnB,IAAd0D,EAAqB1D,GAAiB,gBACxB,IAAd0D,EAAsB1D,GAAmB,aAE7Ca,UAEAZ,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAmBC,SAAA6F,IAGnCqF,IAAaO,IAAeW,EAAgBvG,EAAYyF,IACvDzL,EAAAA,KAAC,MAAA,CACCC,UAAWC,GACXqB,MAAO,CACLoN,SAAU,QACVzC,IAAK,GAAGF,EAAcE,QACtBC,KAAM,GAAGH,EAAcG,SACvByC,UAAW,oBAIbzO,SAAA,CAAAC,EAAAA,IAAC,SAAA,CACCH,UAAWC,GACXa,QAAUuG,IACRA,EAAEuH,kBACEtD,GACFA,KAGJ,aAAW,cACXnD,MAAM,oCACPjI,SAAA,MAIwB,cAAxBhF,EAASnB,kBACP,MAAA,CAAIiG,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,QAAA,CACC0O,KAAK,OACLtH,MAAOzE,EACPsF,SAAWf,GAAM3B,EAAc2B,EAAEC,OAAOC,OACxCc,WAAahB,IACG,UAAVA,EAAE5H,MACuB,SAAvBvE,EAASlB,UACX8M,EAAahE,GAEbyL,MAINjG,YAAY,sBACZtI,UAAWC,GACX6O,WAAS,IAEa,SAAvB5T,EAASlB,WACRmG,EAAAA,IAACS,EAAA,CACCmO,KAAK,QACLlO,QAAQ,UACRC,QAASyN,EACT9I,UAAW3C,EACZ5C,SAAA,aAMLC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACbC,SAAA8F,EAAU5F,IAAI,CAAC8G,EAAQ8H,IACtB7O,EAAAA,IAACS,EAAA,CAECmO,KAAK,QACLlO,QAAQ,YACRC,QAAS,IAAM0N,EAAetH,GAC9BlH,UAAWC,GAEVC,SAAAgH,GANI8H,SAehBrD,GACC5L,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAuBC,SAAAsL,IACzB,OAAd7H,GACCxD,EAAAA,IAAC,OAAA,CAAKH,UAAW2D,EAAY1D,GAAyBA,GACnDC,SAAAyD,EAAY,IAAM,SAO1B8H,IAAeL,GACdjL,EAAAA,IAAC,QAAKH,UAAWC,GAAoBC,SAAAuL,IAEtCC,IAAoBN,GACnBjL,EAAAA,IAAC,QAAKH,UAAWC,GAAyBC,SAAAwL,+WC9WrCuD,GAA6B,EACxC/P,OACAhB,OACAjD,UACAC,WACAgU,eACAC,sBAGA,MAAMvI,EAAgBtI,EAAAA,QAAQ,IAAM4G,EAAkBhG,GAAO,CAACA,IAGxD2H,EAAgBvI,EAAAA,QAAQ,IACxBsI,EJ0BD,SAAiC1H,GAItC,OAHe4F,EAAqB5F,GAGtBkB,IAAI8H,IAAA,IACbA,EAEH5E,QAAS4E,EAAM5E,QAAQb,QAAU,KAErC,CIlCa2M,CAAwBlQ,GAE1B,GACN,CAACA,EAAM0H,IAKJyI,EAAa/Q,EAAAA,QAAQ,KACzB,GAAIsI,EAAe,OAAO,KAE1B,MAAM0I,EAASpR,EAAKK,SAASgR,cAAgB,CAC3ChV,KAAM,CACJ6E,EAAG,YACHC,EAAG,QACHC,EAAG,QACH+B,OAAG,EACHgG,OAAG,EACHuB,OAAG,GAELC,qBAAqB,GAGvB,MFuDwB,EAC1B3J,EACAoQ,KAEA,MAAME,EAAcF,GAAU3G,GAG9B,GAAIzJ,EAAKiE,gBAAkBjE,EAAKiE,eAAexD,OAAS,EACtD,OAAOoK,GAA2B7K,EAAKiE,gBAIzC,MAAM3E,EAAqB,CAAA,EACrBiR,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,KAEpD,IAAA,MAAWnJ,KAAQmJ,EAAS,CAC1B,MAAMlN,EAAOrD,EAAKoH,GAClB,IAAK/D,EAAM,SAEX,MAAMhI,EAAOiV,EAAYjV,KAAK+L,GAC9B,GAAK/L,EAEL,OAAQA,GACN,IAAK,YACHiE,EAAO8H,GAAQ4C,GAAoB3G,EAAMiN,EAAY3G,qBACrD,MACF,IAAK,OACHrK,EAAO8H,GAAQiD,GAAehH,EAAMiN,EAAY3G,qBAChD,MACF,IAAK,QACHrK,EAAO8H,GAAQqD,GAAgBpH,EAAMiN,EAAY3G,qBACjD,MACF,QAEErK,EAAO8H,GAAQsD,GAAcrH,EAAMiN,EAAY3G,qBAErD,CAEA,OAAOrK,GE7FEkR,CAAaxQ,EAAMoQ,IACzB,CAACpQ,EAAMhB,EAAM0I,IAGV+I,EAAerR,EAAAA,QAAQ,KAC3B,GAAIsI,GAAiBC,EAAclH,OAAS,EAAG,CAO7C,OALekH,EAAczG,IAAI,CAACwP,EAAc7K,KAAA,CAC9CxC,KAAMqN,EAAa5K,QACnBqE,MAAOtE,EACPuE,IAAKvE,EAAQ,IAGjB,CAEA,IAAKsK,EAAY,MAAO,GACxB,MAAMQ,EAAa3U,EAASjB,qBAAqBC,KACjD,OAAOmV,EAAWQ,IAAe,IAChC,CAACjJ,EAAeC,EAAewI,EAAYnU,IAExC4U,EAAexR,EAAAA,QAAQ,KAC3B,GAAIsI,GAAiBC,EAAclH,OAAS,EAAG,CAE7C,MAAMoD,EAAa7H,EAASjB,qBAAqBE,GACjD,OAAO0M,EAAczG,IAAI,CAACwP,EAAc7K,KAAA,CACtCxC,KAAqB,MAAfQ,EAAqB6M,EAAa3K,OAAS2K,EAAatM,QAC9D+F,MAAOtE,EACPuE,IAAKvE,EAAQ,IAEjB,CAEA,IAAKsK,EAAY,MAAO,GACxB,MAAMtM,EAAa7H,EAASjB,qBAAqBE,GACjD,OAAOkV,EAAWtM,IAAe,IAChC,CAAC6D,EAAeC,EAAewI,EAAYnU,IAExC6U,EAAezR,EAAAA,QAAQ,IACvBsI,GAAiBC,EAAclH,OAAS,EAEnCkH,EAAczG,IAAI,CAACwP,EAAc7K,KAAA,CACtCxC,KAAMqN,EAAa3K,OACnBoE,MAAOtE,EACPuE,IAAKvE,EAAQ,KAIZsK,GACEA,EAAc,GADG,GAEvB,CAACzI,EAAeC,EAAewI,IAI5BW,EAAmBjJ,cAAazK,IACpC4S,EAAa5S,IACZ,CAAC4S,IAGEe,EAAsBlJ,EAAAA,YAAY,KACtCoI,KACC,CAACA,IAGEe,EAA0BnJ,cAAaoJ,IAC3C,IAAKL,EAAanQ,OAAQ,MAAO,GACjC,MAAMyQ,EAAcN,EAAaK,GACjC,OAAOC,GAAa7N,MAAQ,IAC3B,CAACuN,IAGEO,EAA0BtJ,cAAaoJ,IAC3C,IAAKJ,EAAapQ,OAAQ,MAAO,GACjC,MAAM2Q,EAAcP,EAAaI,GACjC,OAAOG,GAAa/N,MAAQ,IAC3B,CAACwN,IAGEQ,EAAexJ,cAAayJ,IAChC,IAAKtS,EAAKK,SAASkS,MAAO,CASxB,MAR8C,CAC5CrR,EAAG,aACHC,EAAG,SACHC,EAAG,UACH+B,EAAG,SACHgG,EAAG,SACHuB,EAAG,UAEgB4H,IAAWA,EAAO7P,aACzC,CACA,OAAOzC,EAAKK,QAAQkS,MAAMD,IAA8CA,EAAO7P,eAC9E,CAACzC,IAEJ,OACE6B,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GAAmBC,SAAA,CAAA,QAAMjF,EAAQO,iBAAmB,KACrEuE,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GACdC,SAAA,CAAAqQ,EAAarV,EAASjB,qBAAqBC,MAAM,MAAIqW,EAAarV,EAASjB,qBAAqBE,OAElGyM,GACCzG,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAuBC,SAAA,oBAI5CH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GAGdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACbC,SAAA,CAAAqQ,EAAarV,EAASjB,qBAAqBC,MAC3C0M,GACCzG,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAuBC,SAAA,oBAG5CC,EAAAA,IAAC,OAAIH,UAAWC,GACbC,SAAAyP,EAAavP,IAAI,CAAC8H,EAAOnD,IACxB5E,EAAAA,IAACgL,GAAA,CAECjD,QACAnD,QACAqG,SAAUnQ,EAAQQ,oBAAsBsJ,EACxCsG,aAAa,EACbvK,QAAS,IAAMkP,EAAiBjL,GAChCuG,QAAS,IAAM0E,MACfzE,WAAY0E,EACZ/U,WACA6K,WAAYmC,EAAM3F,KAClBiJ,WAAY0E,EAAwBnL,GACpC0G,WAAYxQ,EAAQS,WAAa2U,EAAwBtL,GAAS,GAClE2G,gBAAiBzQ,EAAQU,gBAAkBuU,EAAwBnL,GAAS,IAZvE,GAAG9J,EAAQO,oBAAoBuJ,YAmB1C6B,GAAiB3L,EAAQS,YAAcwD,EAAKG,GAC5CU,OAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAkBC,SAAA,iBACjC,MAAA,CAAIF,UAAWC,GAAkBC,WAAKb,QAIzCuH,GAAiB3L,EAAQU,wBACxB,MAAA,CAAIqE,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAmBC,WAAahF,EAASjB,qBAAqBE,MAC9EgG,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAkBC,WAAKhF,EAASjB,qBAAqBE,KAAO,QAK/EyM,IAAkB3L,EAAQS,YAAcT,EAAQU,kBAC/CoE,OAAC,MAAA,CAAIC,UAAWC,GACbC,SAAA,CAAAjF,EAAQS,YAAcwD,EAAKG,UACzB,MAAA,CAAIW,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAkBC,SAAA,sBACjC,MAAA,CAAIF,UAAWC,GAAkBC,WAAKb,OAG1CpE,EAAQU,iBAAmBuD,EAAKI,UAC9B,MAAA,CAAIU,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAkBC,SAAA,2BACjC,MAAA,CAAIF,UAAWC,GAAkBC,WAAKZ,4QCtM1CoR,GAA8B,EACzCxR,OACAhB,OACAjD,UACAC,WACAmK,WACAC,WACA4J,eACAC,kBACAwB,OAAQC,MAIR,MAAML,EAAexJ,cAAayJ,IAChC,IAAKtS,EAAKK,SAASkS,MAAO,CASxB,MAR8C,CAC5CrR,EAAG,aACHC,EAAG,SACHC,EAAG,UACH+B,EAAG,SACHgG,EAAG,SACHuB,EAAG,UAEgB4H,IAAWA,EAAO7P,aACzC,CACA,OAAOzC,EAAKK,QAAQkS,MAAMD,IAA8CA,EAAO7P,eAC9E,CAACzC,IAGE2S,EAAuB9J,cAAavI,IACpC8G,GACFA,EAAS9G,IAIV,CAAC8G,IAGEwL,EAAgBxS,EAAAA,QAAQ,IACK,aAA7BpD,EAASV,gBAETuF,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GAAmBC,SAAA,CAAA,QAAMjF,EAAQO,iBAAmB,KACrEuE,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GACdC,SAAA,CAAAqQ,EAAarV,EAASjB,qBAAqBC,MAAM,MAAIqW,EAAarV,EAASjB,qBAAqBE,UAIrGgG,EAAAA,IAACiF,GAAA,CACClG,OACAmG,WACAnK,WACAoK,SAAUuL,EACVrL,YAAY,KAIZvK,EAAQS,YAAcT,EAAQU,yBAC7B,MAAA,CAAIqE,UAAWC,GACbC,SAAA,CAAAjF,EAAQS,YAAcwD,EAAKG,UACzB,MAAA,CAAIW,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAkBC,SAAA,iBACjC,MAAA,CAAIF,UAAWC,GAAkBC,WAAKb,OAG1CpE,EAAQU,iBAAmBuD,EAAKhE,EAASjB,qBAAqBE,KAC7D4F,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GAAmBC,WAAahF,EAASjB,qBAAqBE,MAC9EgG,EAAAA,IAAC,OAAIH,UAAWC,GAAkBC,SAAAhB,EAAKhE,EAASjB,qBAAqBE,eAWjFgG,EAAAA,IAAC8O,GAAA,CACC/P,OACAhB,OACAjD,UACAC,WACAgU,aAAcA,SAAwB,GACtCC,gBAAiBA,SAA2B,KAG/C,CACDjU,EAASV,gBACT0E,EACAhB,EACAjD,EACAC,EACAmK,EACAkL,EACAM,EACA3B,EACAC,IAGF,OACEhP,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACbC,SAAA4Q,uMC1HMC,GAA0B,EACrCC,gBACAC,YACAvV,aACAC,kBACAuV,aACAP,SACAQ,iBACAC,yBAGErR,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAACa,EAAA,CACCC,QAAQ,YACRkO,KAAK,SACLjO,QAASoQ,EACTzL,UAAWuL,EACXhR,UAAWC,GAEXC,SAAA,CAAAC,MAAC,OAAIY,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,eAAC,OAAA,CAAKmB,EAAE,oCACJ,cAGRtB,EAAAA,KAACa,EAAA,CACCC,QAAQ,YACRkO,KAAK,SACLjO,QAAS6P,EACTlL,UAAWwL,EACXjR,UAAWC,GACZC,SAAA,CAAA,aAEE,MAAA,CAAIa,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,eAAC,OAAA,CAAKmB,EAAE,4CAKdtB,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAACa,EAAA,CACCC,QAASnF,EAAa,UAAY,YAClCqT,KAAK,QACLjO,QAASqQ,EACTnR,UAAWC,GAEVC,SAAA,CAAAxE,EACCqE,EAAAA,KAAC,MAAA,CAAIgB,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKkB,EAAE,uDACP,SAAA,CAAOgQ,GAAG,KAAKC,GAAG,KAAKC,EAAE,SAG5BxR,EAAAA,KAAC,MAAA,CAAIgB,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKkB,EAAE,iLACRlB,EAAAA,IAAC,QAAKqR,GAAG,IAAIC,GAAG,IAAIC,GAAG,KAAKC,GAAG,UAEjC,gBAGJ5R,EAAAA,KAACa,EAAA,CACCC,QAASlF,EAAkB,UAAY,YACvCoT,KAAK,QACLjO,QAASsQ,EACTpR,UAAWC,GAEVC,SAAA,CAAAvE,EACCoE,EAAAA,KAAC,MAAA,CAAIgB,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKkB,EAAE,uDACP,SAAA,CAAOgQ,GAAG,KAAKC,GAAG,KAAKC,EAAE,SAG5BxR,EAAAA,KAAC,MAAA,CAAIgB,MAAM,KAAKC,OAAO,KAAKC,QAAQ,YAAYC,KAAK,OAAOC,OAAO,eAAeC,YAAY,IAC5FlB,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKkB,EAAE,iLACRlB,EAAAA,IAAC,QAAKqR,GAAG,IAAIC,GAAG,IAAIC,GAAG,KAAKC,GAAG,UAEjC,wBAKNxR,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACdC,SAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAqBC,SAAA,iSCtFjC0R,GAA0B,EACrCpW,mBACAqW,aACAjW,eACAC,qBAEA,MAAM0E,GAAuB/E,EAAmB,GAAKqW,EAAc,IAC7DnO,EAAW9H,EAAeC,EAAiB,EAC5CD,GAAgBA,EAAeC,GAAmB,IACnD,EAEJ,OACEkE,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAkBC,SAAA,SACnCH,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GACdC,SAAA,CAAA1E,EAAmB,EAAE,MAAIqW,SAG5BjW,EAAe,GAAKC,EAAiB,IACrCkE,OAAA+R,EAAAA,SAAA,CACE5R,SAAA,CAAAH,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAkBC,SAAA,YACnCC,EAAAA,IAAC,OAAA,CAAKH,UAAW,GAAGC,MAAoBA,KACrCC,SAAAtE,OAGLmE,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAkBC,SAAA,cACnCC,EAAAA,IAAC,OAAA,CAAKH,UAAW,GAAGC,MAAoBA,KACrCC,SAAArE,OAGLkE,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,OAAA,CAAKH,UAAWC,GAAkBC,SAAA,aACnCH,EAAAA,KAAC,OAAA,CAAKC,UAAWC,GACdC,SAAA,CAAAwD,EAASqO,QAAQ,GAAG,gBAM/B5R,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACdC,SAAAC,EAAAA,IAAC,MAAA,CACCH,UAAWC,GACXqB,MAAO,CAAEP,MAAO,GAAGR,iQCzCvByR,GAAW,KACf,MAAM5W,OAAEA,GAAW6W,IACbC,EAAWC,KAGXC,YAAEA,EAAAC,UAAaA,EAAAC,MAAWA,EAAAC,SAAOA,GAAaC,KAC9CvX,QACJA,EAAAC,SACAA,EAAAC,YACAA,EAAAgB,mBACAA,EAAAO,eACAA,EAAAC,gBACAA,EAAAO,aACAA,EAAAC,kBACAA,EAAAE,aACAA,EAAAM,YACAA,GACEhD,KAIG8X,EAAcC,GAAmB/M,EAAAA,UAAS,IAC1CxH,EAAoBwU,GAAyBhN,EAAAA,SAAwB,MAG5EqC,EAAAA,UAAU,KACJ5M,GACFmX,EAASnX,IAEV,CAACA,EAAQmX,IAGZvK,EAAAA,UAAU,KACR,GAAIoK,GAAa7T,SAAWnD,EAAQ,CAClC,MAAMwX,EAAcnU,OAAO4H,KAAK+L,EAAY7T,QAAQI,WACpD,GAAIiU,EAAYjT,OAAS,EAAG,CAE1B,MAAMkT,EAAgBlV,EAAYvC,GAC5BC,EAAawX,GAAexX,YAAcuX,EAAY,GAG5DD,EAAsBtX,GAGjBJ,GACHE,EAAYC,EAAQC,EAExB,CACF,GACC,CAAC+W,EAAahX,EAAQD,EAAawC,IAGtCqK,EAAAA,UAAU,KACR,GAAI/M,GAAWG,GAAuC,IAA7BH,EAAQO,kBAAwD,IAA9BP,EAAQQ,kBAAyB,CAC1F,MAAMoX,EAAgBlV,EAAYvC,GAC9ByX,GAAiBA,EAAcxW,UAAY,IAC7CK,EAAemW,EAAcxW,WAC7BM,EAAgBkW,EAAcvW,YAElC,GACC,CAACrB,GAASM,oBAGb,MAAMuX,EAAkBxU,EAAAA,QAAQ,IACzB8T,GAAa7T,SAAYJ,EACvBiU,EAAY7T,QAAQI,UAAUR,GADoB,KAExD,CAACiU,EAAajU,IAEX4U,EAAczU,EAAAA,QAAQ,IACrBwU,GAAoB7X,EAClB6X,EAAgB/T,MAAM9D,EAAQO,kBADI,KAExC,CAACsX,EAAiB7X,IAGfoK,EAAW/G,EAAAA,QAAQ,IAClBwU,EACEA,EAAgB/T,MADM,GAE5B,CAAC+T,IAGEE,EAAuBjM,cAAa1L,IACxCsX,EAAsBtX,GACtBc,EAAmBd,GACnBqB,EAAe,GACfC,EAAgB,IACf,CAACR,EAAoBO,EAAgBC,IAGlCsW,EAAqBlM,EAAAA,YAAY,KAChC9L,GAEDA,EAAQO,iBAAmB,IAC7BkB,EAAezB,EAAQO,iBAAmB,GAC1CmB,EAAgB,KAEjB,CAAC1B,EAASyB,EAAgBC,IAEvBuW,EAAiBnM,EAAAA,YAAY,KAC5B9L,GAAY6X,GAEb7X,EAAQO,iBAAmBsX,EAAgB/T,MAAMY,OAAS,IAC5DjD,EAAezB,EAAQO,iBAAmB,GAC1CmB,EAAgB,KAEjB,CAAC1B,EAAS6X,EAAiBpW,EAAgBC,IAGxCkU,EAAuB9J,cAAavI,IACxC,IAAKvD,EAAS,OAEd,MAAMsC,EAAexB,KAAKC,MAAQf,EAAQgB,kBAC1CoB,EAAamB,EAAOmF,UAAWpG,IAE9B,CAACtC,EAASoC,IAuDb,OApDA2K,EAAAA,UAAU,KACR,MAAMmL,EAAiB9L,IAErB,MAAMC,EAASD,EAAEC,OACjB,IACEA,GACoB,UAAnBA,EAAO8L,SACa,aAAnB9L,EAAO8L,UACN9L,EAAe+L,kBAKpB,OAAQhM,EAAE5H,KACR,IAAK,UACL,IAAK,IACH4H,EAAEK,iBACFuL,IACA,MACF,IAAK,YACL,IAAK,IACH5L,EAAEK,iBACFwL,IACA,MACF,IAAK,IACH7L,EAAEK,iBACFxK,IACA,MACF,IAAK,IACHmK,EAAEK,iBACFvK,MAQN,OADA6Q,OAAOsF,iBAAiB,UAAWH,GAC5B,IAAMnF,OAAOuF,oBAAoB,UAAWJ,IAClD,CAACF,EAAoBC,EAAgBhW,EAAcC,IAGtD6K,EAAAA,UAAU,IACD,OAMN,CAAC/M,EAASG,IAGTiX,EACK,KAILC,IAAUF,EAEVrS,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAGD,SAAA,wBACJC,EAAAA,IAAC,KAAED,SAAA,oDACHC,EAAAA,IAAC,SAAA,CAAOW,QAAS,IAAMoR,EAAS,KAAMlS,UAAWC,GAAmBC,SAAA,oBAQrEkS,EAAY7T,SAAiE,IAAtDE,OAAO4H,KAAK+L,EAAY7T,QAAQI,WAAWgB,OAarEI,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAACqT,EAAA,CACCrL,MAAOiK,EAAYqB,SAASC,UAC5BC,SAAS,YACTC,YAAa,IAAM1B,EAAS,SAAS9W,KACrCyY,UAAU,eACVC,aACE3T,EAAAA,IAACS,EAAA,CACCC,QAAQ,YACRkO,KAAK,QACLjO,QAAS,IAAM4R,GAAgB,GAC/B1S,UAAWC,GAEXC,SAAAC,EAAAA,IAAC4T,EAAA,CAAahF,KAAM,SAK1BhP,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAA,CAAIH,UAAWC,GACdC,SAAAC,EAAAA,IAAClC,EAAA,CACCC,KAAMkU,EACNjU,qBACAC,iBAAkB4U,EAClBhY,SAAU2C,EAAYvC,GAAU,QAIpC+E,EAAAA,IAAC,OAAIH,UAAWC,GACbC,SAAAjF,GAAW6X,GAAmBC,GAC7BhT,EAAAA,KAAA+R,EAAAA,SAAA,CACE5R,SAAA,CAAAC,EAAAA,IAACyR,GAAA,CACCpW,iBAAkBP,EAAQO,iBAC1BqW,WAAYiB,EAAgB/T,MAAMY,OAClC/D,aAAcX,EAAQW,aACtBC,eAAgBZ,EAAQY,iBAG1BsE,EAAAA,IAACuQ,GAAA,CACCxR,KAAM6T,EACN7U,KAAMkU,EACNnX,UACAC,WACAmK,WACAC,SAAUuL,EACVF,OAAQuC,EACRhE,aAAe5S,IAEbK,EAAgBL,IAElB6S,gBAAiB,KAEf,IAAKlU,IAAY6X,EAAiB,OAElC,MAAMkB,EAAiB/Y,EAAQQ,kBAAoB,EAC7CsX,EAAcD,EAAgB/T,MAAM9D,EAAQO,kBAQ9CwY,GALcjB,EAAY5P,eAC5B4P,EAAY5P,eAAexD,OAC1BoT,EAAY3T,GAAGO,QAAU,GAK1BhD,EAAgBqX,GAGZ/Y,EAAQO,iBAAmBsX,EAAgB/T,MAAMY,OAAS,GAC5DuT,OAMsB,UAA7BhY,EAASV,iBACR2F,EAAAA,IAAC4Q,GAAA,CACCC,cAAe/V,EAAQO,iBAAmB,EAC1CyV,UAAWhW,EAAQO,iBAAmBsX,EAAgB/T,MAAMY,OAAS,EACrEjE,WAAYT,EAAQS,WACpBC,gBAAiBV,EAAQU,gBACzBuV,WAAY+B,EACZtC,OAAQuC,EACR/B,eAAgBjU,EAChBkU,oBAAqBjU,IAIK,aAA7BjC,EAASV,wBACP,MAAA,CAAIwF,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,SAAA,CACCW,QAASmS,EACTxN,SAAuC,IAA7BxK,EAAQO,iBAClBwE,UAAWC,GACZC,SAAA,wBAGDC,EAAAA,IAAC,SAAA,CACCW,QAASoS,EACTzN,SAAUxK,EAAQO,kBAAoBsX,EAAgB/T,MAAMY,OAAS,EACrEK,UAAWC,GACZC,SAAA,+BAUZuS,GACCtS,EAAAA,IAAC8T,EAAA,CACCC,QAASzB,EACTnH,QAAS,IAAMoH,GAAgB,GAC/ByB,KAAK,OACLjW,KAAMkU,EACNlX,WACAkZ,iBAAmBC,IACjB1Z,EAAa2Z,WAAWlX,eAAeiX,SAlI7CtU,EAAAA,KAAC,MAAA,CAAIC,UAAWC,GACdC,SAAA,CAAAC,EAAAA,IAAC,MAAGD,SAAA,iCACJC,EAAAA,IAAC,KAAED,SAAA,kFACHC,EAAAA,IAAC,SAAA,CAAOW,QAAS,IAAMoR,EAAS,SAAS9W,KAAW4E,UAAWC,GAAmBC,SAAA"}