{"version":3,"file":"Learn.module-DHiza-ia.js","sources":["../../src/services/questionGenerator.ts","../../src/services/cardScheduler.ts","../../src/hooks/useCardScheduler.ts","../../src/components/modes/learn/hooks/useSessionState.ts","../../node_modules/classnames/index.js","../../src/components/modes/learn/MultipleChoiceOptions.tsx","../../src/utils/textMatching.ts","../../src/components/modes/learn/FreeTextInput.tsx","../../src/components/modes/learn/FeedbackSection.tsx","../../src/components/modes/learn/QuestionCard.tsx","../../src/components/modes/learn/components/QuestionFlow.tsx","../../src/components/modals/CardDetailsModal.tsx","../../src/components/modes/learn/LearnContainer.tsx","../../src/hooks/useQuestionGenerator.ts"],"sourcesContent":["import { Card, Question, QuestionGeneratorOptions } from '@/types';\n\nexport class QuestionGenerator {\n  /**\n   * Generate questions from a set of cards based on provided options\n   */\n  static generateQuestions(\n    cards: Card[],\n    options: QuestionGeneratorOptions,\n    masteredCardIndices?: number[],\n    allDeckCards?: Card[]\n  ): Question[] {\n    const questions: Question[] = [];\n    const usedCardIndices = new Set<number>();\n\n    cards.forEach(card => {\n      if (options.excludeCards?.has(card.idx)) {\n        return;\n      }\n\n      // Generate initial questions as multiple choice primarily\n      // Free text will be added dynamically after correct MC answers\n      const questionType = options.forceMultipleChoice\n        ? 'multiple_choice'\n        : this.selectQuestionType(options.questionTypes, options.questionTypeMix);\n\n      if (questionType === 'multiple_choice') {\n        questions.push(\n          this.generateMultipleChoice(\n            card,\n            allDeckCards || cards, // Use all deck cards if available, otherwise use round cards\n            { front: options.frontSides, back: options.backSides },\n            card.idx, // Use card's original index\n            masteredCardIndices\n          )\n        );\n      } else {\n        questions.push(\n          this.generateFreeText(\n            card,\n            { front: options.frontSides, back: options.backSides },\n            card.idx // Use card's original index\n          )\n        );\n      }\n\n      usedCardIndices.add(card.idx);\n    });\n\n    return this.shuffleQuestions(questions, options.difficulty);\n  }\n\n  /**\n   * Generate a multiple choice question from a card\n   */\n  static generateMultipleChoice(\n    card: Card,\n    allCards: Card[],\n    sides: { front: string[]; back: string[] },\n    cardIndex: number,\n    masteredCardIndices?: number[]\n  ): Question {\n    const questionText = this.buildQuestionText(card, sides.front);\n    const correctAnswer = this.buildAnswerText(card, sides.back);\n    const distractors = this.generateDistractors(\n      correctAnswer,\n      allCards,\n      sides.back,\n      cardIndex,\n      masteredCardIndices\n    );\n\n    return {\n      id: `mc_${card.idx}_${Date.now()}`,\n      type: 'multiple_choice',\n      cardIndex,\n      questionText,\n      questionSides: sides.front,\n      correctAnswer,\n      options: this.shuffleOptions([correctAnswer, ...distractors]),\n      difficulty: card.level || 1,\n    };\n  }\n\n  /**\n   * Generate a free text question from a card\n   */\n  public static generateFreeText(\n    card: Card,\n    sides: { front: string[]; back: string[] },\n    cardIndex: number\n  ): Question {\n    const questionText = this.buildQuestionText(card, sides.front);\n    const correctAnswer = this.buildAnswerText(card, sides.back);\n    const acceptedAnswers = this.generateAcceptedAnswers(correctAnswer);\n\n    return {\n      id: `ft_${card.idx}_${Date.now()}`,\n      type: 'free_text',\n      cardIndex,\n      questionText,\n      questionSides: sides.front,\n      correctAnswer,\n      acceptedAnswers,\n      difficulty: card.level || 1,\n    };\n  }\n\n  /**\n   * Generate distractor options for multiple choice questions\n   * Prioritizes non-mastered cards as distractors, falls back to mastered cards if needed\n   */\n  static generateDistractors(\n    correctAnswer: string,\n    allCards: Card[],\n    answerSides: string[],\n    excludeIndex: number,\n    masteredCardIndices?: number[]\n  ): string[] {\n    const distractors: string[] = [];\n    const nonMasteredDistractors: string[] = [];\n    const masteredDistractors: string[] = [];\n    const masteredSet = new Set(masteredCardIndices || []);\n\n    // Collect potential distractors from other cards, separating by mastery status\n    allCards.forEach(card => {\n      if (card.idx === excludeIndex) return;\n\n      // Build the answer text the same way as the correct answer\n      // This ensures all options (correct and distractors) use the same format\n      const distractor = this.buildAnswerText(card, answerSides);\n\n      if (distractor && distractor !== correctAnswer) {\n        if (masteredSet.has(card.idx)) {\n          if (!masteredDistractors.includes(distractor)) {\n            masteredDistractors.push(distractor);\n          }\n        } else {\n          if (!nonMasteredDistractors.includes(distractor)) {\n            nonMasteredDistractors.push(distractor);\n          }\n        }\n      }\n    });\n\n    // First, try to use only non-mastered distractors\n    const primaryPool = nonMasteredDistractors.length > 0 ? nonMasteredDistractors : [];\n    const fallbackPool = masteredDistractors;\n\n    // Helper function to select distractors from a pool\n    const selectFromPool = (pool: string[], needed: number): string[] => {\n      const selected: string[] = [];\n\n      if (pool.length === 0) return selected;\n\n      // Calculate similarity scores for the pool\n      const scores = pool.map(distractor => ({\n        text: distractor,\n        similarity: this.calculateSimilarity(correctAnswer, distractor),\n      }));\n\n      // Sort by similarity\n      scores.sort((a, b) => b.similarity - a.similarity);\n\n      // Try to get a mix of similar and different options\n      if (scores.length >= needed) {\n        const indices = [\n          0, // Most similar\n          Math.floor(scores.length / 2), // Medium similarity\n          scores.length - 1, // Least similar\n        ];\n\n        indices.forEach(i => {\n          if (i < scores.length && selected.length < needed) {\n            const text = scores[i].text;\n            if (!selected.includes(text)) {\n              selected.push(text);\n            }\n          }\n        });\n      }\n\n      // Fill remaining slots randomly from the pool\n      while (selected.length < needed && selected.length < pool.length) {\n        const randomDistractor = pool[Math.floor(Math.random() * pool.length)];\n        if (!selected.includes(randomDistractor)) {\n          selected.push(randomDistractor);\n        }\n      }\n\n      return selected;\n    };\n\n    // Try to get 3 distractors from non-mastered cards first\n    distractors.push(...selectFromPool(primaryPool, 3));\n\n    // If we don't have enough, supplement with mastered cards\n    if (distractors.length < 3) {\n      const remaining = 3 - distractors.length;\n      distractors.push(...selectFromPool(fallbackPool, remaining));\n    }\n\n    // If still not enough distractors, generate generic ones\n    while (distractors.length < 3) {\n      distractors.push(`Option ${distractors.length + 2}`);\n    }\n\n    return distractors.slice(0, 3);\n  }\n\n  /**\n   * Calculate semantic similarity between two strings\n   */\n  private static calculateSimilarity(text1: string, text2: string): number {\n    const words1 = text1.toLowerCase().split(/\\s+/);\n    const words2 = text2.toLowerCase().split(/\\s+/);\n\n    const set1 = new Set(words1);\n    const set2 = new Set(words2);\n\n    const intersection = new Set([...set1].filter(x => set2.has(x)));\n    const union = new Set([...set1, ...set2]);\n\n    // Jaccard similarity\n    return intersection.size / union.size;\n  }\n\n  /**\n   * Build question text from card sides\n   */\n  private static buildQuestionText(card: Card, frontSides: string[]): string {\n    const parts: string[] = [];\n\n    frontSides.forEach(side => {\n      // Type-safe card property access using keyof\n      const sideKey = side as keyof Card;\n      const value = card[sideKey];\n      if (typeof value === 'string' && value) {\n        parts.push(value);\n      }\n    });\n\n    return parts.join(' - ') || 'Question';\n  }\n\n  /**\n   * Build answer text from card sides\n   */\n  private static buildAnswerText(card: Card, backSides: string[]): string {\n    const parts: string[] = [];\n\n    backSides.forEach(side => {\n      // Type-safe card property access using keyof\n      const sideKey = side as keyof Card;\n      const value = card[sideKey];\n      if (typeof value === 'string' && value) {\n        parts.push(value);\n      }\n    });\n\n    return parts.join(' - ') || 'Answer';\n  }\n\n  /**\n   * Generate accepted answer variations for free text questions\n   */\n  private static generateAcceptedAnswers(correctAnswer: string): string[] {\n    const variations: string[] = [correctAnswer];\n\n    // Add lowercase version\n    variations.push(correctAnswer.toLowerCase());\n\n    // Add uppercase version\n    variations.push(correctAnswer.toUpperCase());\n\n    // Add version without punctuation\n    const noPunctuation = correctAnswer.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, '');\n    if (noPunctuation !== correctAnswer) {\n      variations.push(noPunctuation);\n      variations.push(noPunctuation.toLowerCase());\n    }\n\n    // Add version with trimmed whitespace\n    const trimmed = correctAnswer.trim();\n    if (trimmed !== correctAnswer) {\n      variations.push(trimmed);\n    }\n\n    // Remove duplicates\n    return [...new Set(variations)];\n  }\n\n  /**\n   * Select a question type based on configured probabilities\n   */\n  private static selectQuestionType(\n    types: ('multiple_choice' | 'free_text')[],\n    mix?: 'auto' | 'multiple_choice' | 'free_text' | 'mixed'\n  ): 'multiple_choice' | 'free_text' {\n    // Handle explicit type selection\n    if (mix === 'multiple_choice') return 'multiple_choice';\n    if (mix === 'free_text') return 'free_text';\n\n    // If only one type is available, use it\n    if (types.length === 1) {\n      return types[0];\n    }\n\n    // Handle probability-based selection\n    let mcProbability = 0.8; // Default 80% MC, 20% text for 'auto'\n\n    if (mix === 'mixed') {\n      mcProbability = 0.5; // 50/50 split for 'mixed'\n    }\n\n    return Math.random() < mcProbability ? 'multiple_choice' : 'free_text';\n  }\n\n  /**\n   * Shuffle questions based on difficulty\n   */\n  private static shuffleQuestions(questions: Question[], difficulty: number): Question[] {\n    // Sort by difficulty first\n    const sorted = [...questions].sort((a, b) => a.difficulty - b.difficulty);\n\n    // Apply some randomization based on difficulty setting\n    const shuffled = [...sorted];\n    const shuffleIntensity = 1 - difficulty * 0.2; // Higher difficulty = less shuffle\n\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      if (Math.random() < shuffleIntensity) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n      }\n    }\n\n    return shuffled;\n  }\n\n  /**\n   * Shuffle options array\n   */\n  private static shuffleOptions(options: string[]): string[] {\n    const shuffled = [...options];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n}\n","import { Card, MissedCard, SchedulerConfig, SchedulingAlgorithm } from '@/types';\n\n/**\n * Smart Spaced Reinforcement Algorithm\n * Adaptive spacing based on performance with anti-clustering\n */\nexport class SmartSpacedScheduler implements SchedulingAlgorithm {\n  name = 'Smart Spaced Reinforcement';\n  description = 'Adaptive spacing based on performance with anti-clustering';\n\n  schedule(missedCards: MissedCard[], upcomingCards: Card[], config: SchedulerConfig): Card[] {\n    // Calculate dynamic position for each missed card\n    const positions = missedCards.map(card => ({\n      card,\n      position: this.calculatePosition(card, upcomingCards.length, config),\n    }));\n\n    // Sort by priority (higher difficulty first)\n    positions.sort((a, b) => b.card.difficulty - a.card.difficulty);\n\n    // Apply anti-clustering rules\n    return this.mergeWithAntiClustering(positions, upcomingCards, config);\n  }\n\n  private calculatePosition(card: MissedCard, queueSize: number, config: SchedulerConfig): number {\n    const base = config.minSpacing;\n    const range = config.maxSpacing - base;\n\n    // Factors affecting position\n    const difficultyFactor = 1 - card.difficulty * config.difficultyWeight;\n    const attemptFactor = Math.min(1, card.missCount / 3);\n    const timeFactor = Math.min(1, (Date.now() - card.lastSeen) / 60000); // cap at 1 minute\n\n    const spacing =\n      base + Math.floor(range * difficultyFactor * (1 - attemptFactor) * Math.max(0.5, timeFactor));\n    const jitter = Math.floor(Math.random() * 3) - 1; // ±1 randomness\n\n    return Math.max(base, Math.min(queueSize - 1, spacing + jitter));\n  }\n\n  private mergeWithAntiClustering(\n    positions: Array<{ card: MissedCard; position: number }>,\n    upcomingCards: Card[],\n    config: SchedulerConfig\n  ): Card[] {\n    const result = [...upcomingCards];\n    const insertedPositions = new Set<number>();\n\n    // Track clustering\n    let consecutiveMissed = 0;\n\n    for (const { card, position } of positions) {\n      let finalPosition = position;\n\n      // Adjust for clustering limit\n      if (consecutiveMissed >= config.clusterLimit) {\n        finalPosition += config.clusterLimit;\n        consecutiveMissed = 0;\n      }\n\n      // Ensure minimum spacing between missed cards\n      while (insertedPositions.has(finalPosition)) {\n        finalPosition += config.minSpacing;\n      }\n\n      // Convert MissedCard to Card for insertion\n      const cardToInsert = this.convertMissedToCard(card, upcomingCards);\n      if (cardToInsert) {\n        result.splice(finalPosition, 0, cardToInsert);\n        insertedPositions.add(finalPosition);\n        consecutiveMissed++;\n      }\n    }\n\n    // Ensure progress ratio is maintained\n    const newCardsRatio = upcomingCards.length / result.length;\n    if (newCardsRatio < config.progressRatio) {\n      // Redistribute to maintain progress\n      return this.redistributeForProgress(result, upcomingCards, config.progressRatio);\n    }\n\n    return result;\n  }\n\n  private convertMissedToCard(missedCard: MissedCard, originalCards: Card[]): Card | null {\n    // Find the original card by index\n    const originalCard = originalCards.find(c => c.idx === missedCard.cardIndex);\n    if (originalCard) {\n      return { ...originalCard };\n    }\n\n    // If not found in upcoming cards, create a placeholder\n    // This should be replaced with actual card lookup from deck\n    return {\n      idx: missedCard.cardIndex,\n      name: `Card ${missedCard.cardIndex}`,\n      side_a: '',\n      side_b: '',\n      level: 1,\n    } as Card;\n  }\n\n  private redistributeForProgress(\n    cards: Card[],\n    originalCards: Card[],\n    targetRatio: number\n  ): Card[] {\n    // Calculate how many new cards we need\n    const totalNeeded = cards.length;\n    const newCardsNeeded = Math.floor(totalNeeded * targetRatio);\n    const currentNewCards = originalCards.filter(c => cards.includes(c)).length;\n\n    if (currentNewCards >= newCardsNeeded) {\n      return cards;\n    }\n\n    // Move some missed cards further back\n    const result: Card[] = [];\n    const missedCards: Card[] = [];\n\n    cards.forEach(card => {\n      if (originalCards.includes(card)) {\n        result.push(card);\n      } else {\n        missedCards.push(card);\n      }\n    });\n\n    // Redistribute missed cards to maintain ratio\n    const spacing = Math.floor((result.length + missedCards.length) / missedCards.length);\n    let insertPosition = spacing;\n\n    missedCards.forEach(card => {\n      result.splice(Math.min(insertPosition, result.length), 0, card);\n      insertPosition += spacing;\n    });\n\n    return result;\n  }\n}\n\n/**\n * Leitner Box Algorithm\n * Classic spaced repetition with exponential intervals\n */\nexport class LeitnerBoxScheduler implements SchedulingAlgorithm {\n  name = 'Leitner Box System';\n  description = 'Classic spaced repetition with exponential intervals';\n\n  private readonly boxes = [2, 4, 8, 16, 32]; // Review intervals per box\n\n  schedule(missedCards: MissedCard[], upcomingCards: Card[], config: SchedulerConfig): Card[] {\n    const result = [...upcomingCards];\n\n    // Group cards by their box level (based on miss count)\n    const boxGroups = this.groupByBox(missedCards);\n\n    // Insert cards based on their box interval\n    boxGroups.forEach((cards, boxLevel) => {\n      const interval = this.getBoxInterval(boxLevel, config);\n\n      cards.forEach((missedCard, index) => {\n        const position = Math.min(interval + index * config.minSpacing, result.length);\n\n        const cardToInsert = this.convertMissedToCard(missedCard, upcomingCards);\n        if (cardToInsert) {\n          result.splice(position, 0, cardToInsert);\n        }\n      });\n    });\n\n    return result;\n  }\n\n  private groupByBox(missedCards: MissedCard[]): Map<number, MissedCard[]> {\n    const groups = new Map<number, MissedCard[]>();\n\n    missedCards.forEach(card => {\n      // Move down boxes based on miss count\n      const boxLevel = Math.max(0, 5 - card.missCount);\n\n      if (!groups.has(boxLevel)) {\n        groups.set(boxLevel, []);\n      }\n      groups.get(boxLevel)!.push(card);\n    });\n\n    return groups;\n  }\n\n  private getBoxInterval(boxLevel: number, config: SchedulerConfig): number {\n    const baseInterval = this.boxes[Math.min(boxLevel, this.boxes.length - 1)];\n\n    // Adjust based on aggressiveness setting\n    const aggressivenessMultiplier = {\n      gentle: 1.5,\n      balanced: 1.0,\n      intensive: 0.5,\n    }[config.aggressiveness];\n\n    return Math.round(baseInterval * aggressivenessMultiplier);\n  }\n\n  private convertMissedToCard(missedCard: MissedCard, originalCards: Card[]): Card | null {\n    // Find the original card by index\n    const originalCard = originalCards.find(c => c.idx === missedCard.cardIndex);\n    if (originalCard) {\n      return { ...originalCard };\n    }\n\n    // Fallback\n    return {\n      idx: missedCard.cardIndex,\n      name: `Card ${missedCard.cardIndex}`,\n      side_a: '',\n      side_b: '',\n      level: 1,\n    } as Card;\n  }\n}\n\n/**\n * Factory for creating schedulers\n */\nexport class CardSchedulerFactory {\n  private static schedulers = new Map<string, SchedulingAlgorithm>([\n    ['smart_spaced', new SmartSpacedScheduler()],\n    ['leitner_box', new LeitnerBoxScheduler()],\n  ]);\n\n  static getScheduler(algorithm: string): SchedulingAlgorithm {\n    const scheduler = this.schedulers.get(algorithm);\n    if (!scheduler) {\n      throw new Error(`Unknown scheduling algorithm: ${algorithm}`);\n    }\n    return scheduler;\n  }\n\n  static registerScheduler(key: string, scheduler: SchedulingAlgorithm): void {\n    this.schedulers.set(key, scheduler);\n  }\n\n  static getAvailableAlgorithms(): Array<{ key: string; name: string; description: string }> {\n    return Array.from(this.schedulers.entries()).map(([key, scheduler]) => ({\n      key,\n      name: scheduler.name,\n      description: scheduler.description,\n    }));\n  }\n}\n","import { useState, useCallback, useMemo, useEffect } from 'react';\nimport { Card, MissedCard, LearnModeSettings, SchedulerConfig } from '@/types';\nimport { CardSchedulerFactory } from '@/services/cardScheduler';\n\ninterface UseCardSchedulerReturn {\n  missedCards: Map<string, MissedCard>;\n  trackMissedCard: (cardId: string, cardIndex: number, responseTime: number) => void;\n  markCardCorrect: (cardId: string) => void;\n  scheduleCards: (upcomingCards: Card[]) => Card[];\n  changeAlgorithm: (algorithm: string) => void;\n  availableAlgorithms: Array<{ key: string; name: string; description: string }>;\n  currentAlgorithm: string;\n  resetScheduler: () => void;\n}\n\nexport const useCardScheduler = (settings: LearnModeSettings): UseCardSchedulerReturn => {\n  const [missedCards, setMissedCards] = useState<Map<string, MissedCard>>(new Map());\n\n  // Map scheduling algorithm to supported ones\n  const getValidAlgorithm = (algorithm?: string): 'smart_spaced' | 'leitner_box' => {\n    if (algorithm === 'leitner_box') return 'leitner_box';\n    // Default all other options to smart_spaced for now\n    return 'smart_spaced';\n  };\n\n  const [currentAlgorithm, setCurrentAlgorithm] = useState<'smart_spaced' | 'leitner_box'>(\n    getValidAlgorithm(settings.schedulingAlgorithm)\n  );\n\n  // Update algorithm when settings change\n  useEffect(() => {\n    const newAlgorithm = getValidAlgorithm(settings.schedulingAlgorithm);\n    if (newAlgorithm !== currentAlgorithm) {\n      setCurrentAlgorithm(newAlgorithm);\n    }\n  }, [settings.schedulingAlgorithm, currentAlgorithm]);\n\n  const scheduler = useMemo(() => {\n    return CardSchedulerFactory.getScheduler(currentAlgorithm);\n  }, [currentAlgorithm]);\n\n  const config = useMemo<SchedulerConfig>(\n    () => ({\n      algorithm: currentAlgorithm as 'smart_spaced' | 'leitner_box',\n      aggressiveness: settings.aggressiveness || 'balanced',\n      minSpacing: settings.minSpacing || 2,\n      maxSpacing: settings.maxSpacing || 8,\n      clusterLimit: settings.clusterLimit || 2,\n      progressRatio: settings.progressRatio || 0.3,\n      difficultyWeight: settings.difficultyWeight || 0.5,\n    }),\n    [settings, currentAlgorithm]\n  );\n\n  const trackMissedCard = useCallback((cardId: string, cardIndex: number, responseTime: number) => {\n    setMissedCards(prev => {\n      const newMap = new Map(prev);\n      const existing = newMap.get(cardId);\n\n      const updated: MissedCard = existing\n        ? {\n            ...existing,\n            missCount: existing.missCount + 1,\n            lastSeen: Date.now(),\n            responseTime,\n            difficulty: Math.min(1, existing.difficulty + 0.1),\n          }\n        : {\n            cardId,\n            cardIndex,\n            missCount: 1,\n            lastSeen: Date.now(),\n            difficulty: 0.5,\n            responseTime,\n          };\n\n      // Calculate difficulty based on miss count and response time\n      updated.difficulty = Math.min(1, updated.missCount * 0.2 + (responseTime > 10000 ? 0.3 : 0));\n\n      newMap.set(cardId, updated);\n      return newMap;\n    });\n  }, []);\n\n  const markCardCorrect = useCallback((cardId: string) => {\n    setMissedCards(prev => {\n      const newMap = new Map(prev);\n      const existing = newMap.get(cardId);\n\n      if (!existing) return prev;\n\n      // If card was only missed once and now correct, remove it\n      if (existing.missCount === 1) {\n        newMap.delete(cardId);\n      } else {\n        // Reduce difficulty and miss count\n        newMap.set(cardId, {\n          ...existing,\n          difficulty: existing.difficulty * 0.7,\n          missCount: Math.max(0, existing.missCount - 1),\n        });\n      }\n\n      return newMap;\n    });\n  }, []);\n\n  const scheduleCards = useCallback(\n    (upcomingCards: Card[]): Card[] => {\n      if (missedCards.size === 0) return upcomingCards;\n\n      const missedArray = Array.from(missedCards.values());\n      return scheduler.schedule(missedArray, upcomingCards, config);\n    },\n    [missedCards, scheduler, config]\n  );\n\n  const changeAlgorithm = useCallback((algorithm: string) => {\n    setCurrentAlgorithm(algorithm as 'smart_spaced' | 'leitner_box');\n  }, []);\n\n  const resetScheduler = useCallback(() => {\n    setMissedCards(new Map());\n  }, []);\n\n  const availableAlgorithms = useMemo(() => {\n    return CardSchedulerFactory.getAvailableAlgorithms();\n  }, []);\n\n  return {\n    missedCards,\n    trackMissedCard,\n    markCardCorrect,\n    scheduleCards,\n    changeAlgorithm,\n    availableAlgorithms,\n    currentAlgorithm,\n    resetScheduler,\n  };\n};\n","import { useState, useCallback, useMemo } from 'react';\nimport { Deck, LearnModeSettings, LearnSessionState } from '@/types';\nimport { SessionStateManager, SessionMetrics, CardTrackingState } from '../types';\n\nconst initialSessionState: LearnSessionState = {\n  currentQuestion: null,\n  questionIndex: 0,\n  roundCards: [],\n  correctCards: new Set(),\n  incorrectCards: new Set(),\n  currentStreak: 0,\n  maxStreak: 0,\n  startTime: Date.now(),\n  responseStartTime: Date.now(),\n  responseTimes: [],\n};\n\nexport const useSessionState = (\n  deck: Deck,\n  _settings: LearnModeSettings\n): SessionStateManager & { cardTracking: CardTrackingState } => {\n  const [sessionState, setSessionState] = useState<LearnSessionState>(initialSessionState);\n\n  // Card tracking state\n  const [masteredCardIndices, setMasteredCardIndices] = useState<Set<number>>(new Set());\n  const [strugglingCardIndices, setStrugglingCardIndices] = useState<Set<number>>(new Set());\n  const [newlyMasteredCards, setNewlyMasteredCards] = useState<Set<number>>(new Set());\n\n  // Update session state\n  const updateSessionState = useCallback((updates: Partial<LearnSessionState>) => {\n    setSessionState(prev => ({\n      ...prev,\n      ...updates,\n    }));\n  }, []);\n\n  // Reset session\n  const resetSession = useCallback(() => {\n    setSessionState({\n      ...initialSessionState,\n      startTime: Date.now(),\n      responseStartTime: Date.now(),\n      responseTimes: [],\n    });\n    setMasteredCardIndices(new Set());\n    setStrugglingCardIndices(new Set());\n    setNewlyMasteredCards(new Set());\n  }, []);\n\n  // Handle answer submission\n  const handleAnswer = useCallback((_answer: string, isCorrect: boolean, cardIdx: number) => {\n    setSessionState(prev => {\n      // Track response time\n      const responseTime = Date.now() - prev.responseStartTime;\n      const newResponseTimes = [...prev.responseTimes, responseTime];\n\n      const newCorrectCards = new Set(prev.correctCards);\n      const newIncorrectCards = new Set(prev.incorrectCards);\n\n      if (isCorrect) {\n        newCorrectCards.add(cardIdx);\n        // Remove from incorrect if it was there\n        newIncorrectCards.delete(cardIdx);\n\n        // Update mastered cards\n        setMasteredCardIndices(prevMastered => {\n          const newMastered = new Set(prevMastered);\n          newMastered.add(cardIdx);\n          return newMastered;\n        });\n\n        // Remove from struggling if correct\n        setStrugglingCardIndices(prevStruggling => {\n          const newStruggling = new Set(prevStruggling);\n          newStruggling.delete(cardIdx);\n          return newStruggling;\n        });\n      } else {\n        newIncorrectCards.add(cardIdx);\n\n        // Add to struggling cards\n        setStrugglingCardIndices(prevStruggling => {\n          const newStruggling = new Set(prevStruggling);\n          newStruggling.add(cardIdx);\n          return newStruggling;\n        });\n      }\n\n      const newStreak = isCorrect ? prev.currentStreak + 1 : 0;\n      const newMaxStreak = Math.max(newStreak, prev.maxStreak);\n\n      return {\n        ...prev,\n        correctCards: newCorrectCards,\n        incorrectCards: newIncorrectCards,\n        currentStreak: newStreak,\n        maxStreak: newMaxStreak,\n        responseTimes: newResponseTimes,\n      };\n    });\n  }, []);\n\n  // Move to next question\n  const nextQuestion = useCallback(() => {\n    setSessionState(prev => ({\n      ...prev,\n      questionIndex: prev.questionIndex + 1,\n      responseStartTime: Date.now(),\n    }));\n  }, []);\n\n  // Calculate metrics\n  const metrics = useMemo<SessionMetrics>(() => {\n    const totalCards = sessionState.roundCards.length || deck.content.length;\n    const correctCount = sessionState.correctCards.size;\n    const incorrectCount = sessionState.incorrectCards.size;\n    const answeredCount = correctCount + incorrectCount;\n    const progressPercentage = totalCards > 0 ? (answeredCount / totalCards) * 100 : 0;\n    const timeElapsed = Date.now() - sessionState.startTime;\n\n    return {\n      correctCount,\n      incorrectCount,\n      currentStreak: sessionState.currentStreak,\n      maxStreak: sessionState.maxStreak,\n      timeElapsed,\n      progressPercentage,\n      totalCards,\n      masteredCount: masteredCardIndices.size,\n    };\n  }, [\n    sessionState.correctCards,\n    sessionState.incorrectCards,\n    sessionState.currentStreak,\n    sessionState.maxStreak,\n    sessionState.startTime,\n    sessionState.roundCards,\n    deck.content.length,\n    masteredCardIndices.size,\n  ]);\n\n  return {\n    sessionState,\n    updateSessionState,\n    resetSession,\n    handleAnswer,\n    nextQuestion,\n    metrics,\n    cardTracking: {\n      masteredCardIndices,\n      strugglingCardIndices,\n      newlyMasteredCards,\n    },\n  };\n};\n","/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import { FC, memo, useState, useCallback, useEffect } from 'react';\nimport cn from 'classnames';\nimport styles from './MultipleChoiceOptions.module.css';\n\ninterface MultipleChoiceOptionsProps {\n  options: string[];\n  correctAnswer: string;\n  onSelect: (answer: string, isCorrect: boolean) => void;\n  showFeedback: boolean;\n  feedback?: { isCorrect: boolean };\n  disabled: boolean;\n  resetKey?: string | number; // Key to reset selection when question changes\n}\n\nexport const MultipleChoiceOptions: FC<MultipleChoiceOptionsProps> = memo(\n  ({ options, correctAnswer, onSelect, showFeedback, feedback: _feedback, disabled, resetKey }) => {\n    const [selectedOption, setSelectedOption] = useState<string | null>(null);\n\n    // Reset selection when resetKey changes (new question)\n    useEffect(() => {\n      setSelectedOption(null);\n    }, [resetKey]);\n\n    const handleOptionClick = useCallback(\n      (option: string) => {\n        if (disabled || selectedOption) return;\n\n        setSelectedOption(option);\n        const isCorrect = option === correctAnswer;\n        onSelect(option, isCorrect);\n      },\n      [correctAnswer, onSelect, disabled, selectedOption]\n    );\n\n    // Handle keyboard shortcuts (1, 2, 3, 4) for desktop\n    useEffect(() => {\n      const handleKeyDown = (e: KeyboardEvent) => {\n        // Only process if not disabled and no option selected yet\n        if (disabled || selectedOption) return;\n\n        // Check if the target is an input element (to avoid conflicts with text input)\n        const target = e.target as HTMLElement;\n        if (\n          target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable\n        ) {\n          return;\n        }\n\n        // Map keys 1-4 to option indices 0-3\n        const keyMap: { [key: string]: number } = {\n          '1': 0,\n          '2': 1,\n          '3': 2,\n          '4': 3,\n        };\n\n        if (e.key in keyMap) {\n          const optionIndex = keyMap[e.key];\n          if (optionIndex < options.length) {\n            e.preventDefault();\n            handleOptionClick(options[optionIndex]);\n          }\n        }\n      };\n\n      window.addEventListener('keydown', handleKeyDown);\n      return () => window.removeEventListener('keydown', handleKeyDown);\n    }, [disabled, selectedOption, options, handleOptionClick]);\n\n    const getOptionStatus = (option: string) => {\n      if (!showFeedback) return null;\n\n      if (option === correctAnswer) return 'correct';\n      if (selectedOption === option && option !== correctAnswer) return 'incorrect';\n\n      return null;\n    };\n\n    return (\n      <div\n        className={styles.multipleChoice}\n        role=\"radiogroup\"\n        aria-label=\"Answer options\"\n        aria-describedby=\"keyboard-hint\"\n      >\n        {options.map((option, index) => {\n          const status = getOptionStatus(option);\n          const isSelected = selectedOption === option;\n\n          return (\n            <button\n              key={`${option}-${index}`}\n              className={cn(\n                styles.option,\n                isSelected && styles.selected,\n                status === 'correct' && styles.correct,\n                status === 'incorrect' && styles.incorrect,\n                disabled && styles.disabled\n              )}\n              onClick={() => handleOptionClick(option)}\n              disabled={disabled || selectedOption !== null}\n              role=\"radio\"\n              aria-checked={isSelected}\n              aria-label={`Option ${index + 1}: ${option}`}\n              data-testid={`option-${index}`}\n              title={`Press ${index + 1} to select`}\n            >\n              <span className={styles.optionLetter}>{index + 1}</span>\n              <span className={styles.optionText}>{option}</span>\n              {showFeedback && status && (\n                <span className={styles.statusIcon} aria-hidden=\"true\">\n                  {status === 'correct' ? '✓' : '✗'}\n                </span>\n              )}\n            </button>\n          );\n        })}\n        {!disabled && !selectedOption && (\n          <div id=\"keyboard-hint\" className={styles.keyboardHint}>\n            <span className={styles.hintIcon}>⌨️</span>\n            <span>Press 1-{Math.min(options.length, 4)} to select</span>\n          </div>\n        )}\n      </div>\n    );\n  }\n);\n\nMultipleChoiceOptions.displayName = 'MultipleChoiceOptions';\n","import { TextMatchOptions } from '@/types';\n\nconst defaultOptions: TextMatchOptions = {\n  caseSensitive: false,\n  allowTypos: true,\n  maxEditDistance: 2,\n  synonyms: new Map(),\n};\n\nexport class TextMatcher {\n  /**\n   * Check if user input matches any of the accepted answers\n   */\n  static isMatch(\n    userInput: string,\n    acceptedAnswers: string[],\n    options: TextMatchOptions = defaultOptions\n  ): boolean {\n    const normalizedInput = this.normalizeText(userInput, options.caseSensitive);\n\n    for (const acceptedAnswer of acceptedAnswers) {\n      const normalizedAnswer = this.normalizeText(acceptedAnswer, options.caseSensitive);\n\n      // Exact match\n      if (normalizedInput === normalizedAnswer) {\n        return true;\n      }\n\n      // Typo tolerance using Levenshtein distance\n      if (options.allowTypos) {\n        const distance = this.levenshteinDistance(normalizedInput, normalizedAnswer);\n        if (distance <= options.maxEditDistance) {\n          return true;\n        }\n      }\n\n      // Synonym matching\n      if (options.synonyms && options.synonyms.size > 0) {\n        if (this.matchesSynonym(normalizedInput, normalizedAnswer, options.synonyms)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate similarity between two strings (0-1)\n   */\n  static calculateSimilarity(text1: string, text2: string): number {\n    const normalized1 = this.normalizeText(text1, false);\n    const normalized2 = this.normalizeText(text2, false);\n\n    if (normalized1 === normalized2) {\n      return 1;\n    }\n\n    const distance = this.levenshteinDistance(normalized1, normalized2);\n    const maxLength = Math.max(normalized1.length, normalized2.length);\n\n    if (maxLength === 0) {\n      return 0;\n    }\n\n    return 1 - distance / maxLength;\n  }\n\n  /**\n   * Normalize text for comparison\n   */\n  static normalizeText(text: string, preserveCase: boolean = false): string {\n    let normalized = text.trim();\n\n    // Remove extra whitespace\n    normalized = normalized.replace(/\\s+/g, ' ');\n\n    // Remove common punctuation (but keep important ones like apostrophes in contractions)\n    normalized = normalized.replace(/[.,;:!?()[\\]{}\"\"\"''`]/g, '');\n\n    // Normalize pinyin tone marks to base letters\n    normalized = this.normalizePinyinTones(normalized);\n\n    // Convert to lowercase unless case sensitive\n    if (!preserveCase) {\n      normalized = normalized.toLowerCase();\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Normalize Chinese pinyin tone marks to base letters\n   */\n  private static normalizePinyinTones(text: string): string {\n    // Map of pinyin characters with tone marks to their base forms\n    const pinyinMap: { [key: string]: string } = {\n      // a tones\n      ā: 'a',\n      á: 'a',\n      ǎ: 'a',\n      à: 'a',\n      // e tones\n      ē: 'e',\n      é: 'e',\n      ě: 'e',\n      è: 'e',\n      // i tones\n      ī: 'i',\n      í: 'i',\n      ǐ: 'i',\n      ì: 'i',\n      // o tones\n      ō: 'o',\n      ó: 'o',\n      ǒ: 'o',\n      ò: 'o',\n      // u tones\n      ū: 'u',\n      ú: 'u',\n      ǔ: 'u',\n      ù: 'u',\n      // ü tones (u with umlaut)\n      ǖ: 'ü',\n      ǘ: 'ü',\n      ǚ: 'ü',\n      ǜ: 'ü',\n      ü: 'u',\n      // Also normalize the plain ü to u for easier matching\n      Ā: 'A',\n      Á: 'A',\n      Ǎ: 'A',\n      À: 'A',\n      Ē: 'E',\n      É: 'E',\n      Ě: 'E',\n      È: 'E',\n      Ī: 'I',\n      Í: 'I',\n      Ǐ: 'I',\n      Ì: 'I',\n      Ō: 'O',\n      Ó: 'O',\n      Ǒ: 'O',\n      Ò: 'O',\n      Ū: 'U',\n      Ú: 'U',\n      Ǔ: 'U',\n      Ù: 'U',\n      Ǖ: 'Ü',\n      Ǘ: 'Ü',\n      Ǚ: 'Ü',\n      Ǜ: 'Ü',\n      Ü: 'U',\n    };\n\n    // Replace each pinyin character with its base form\n    let result = text;\n    for (const [toned, base] of Object.entries(pinyinMap)) {\n      result = result.replace(new RegExp(toned, 'g'), base);\n    }\n\n    return result;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  private static levenshteinDistance(str1: string, str2: string): number {\n    const matrix: number[][] = [];\n\n    // Initialize the matrix\n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j;\n    }\n\n    // Fill the matrix\n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1, // substitution\n            matrix[i][j - 1] + 1, // insertion\n            matrix[i - 1][j] + 1 // deletion\n          );\n        }\n      }\n    }\n\n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Check if input matches via synonyms\n   */\n  private static matchesSynonym(\n    input: string,\n    answer: string,\n    synonyms: Map<string, string[]>\n  ): boolean {\n    // Check if input is a synonym of the answer\n    const answerSynonyms = synonyms.get(answer);\n    if (answerSynonyms && answerSynonyms.includes(input)) {\n      return true;\n    }\n\n    // Check if answer is a synonym of the input\n    const inputSynonyms = synonyms.get(input);\n    if (inputSynonyms && inputSynonyms.includes(answer)) {\n      return true;\n    }\n\n    // Check if they share a common synonym group\n    for (const [, values] of synonyms.entries()) {\n      if (values.includes(input) && values.includes(answer)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Generate common typos for a word (for testing)\n   */\n  static generateCommonTypos(word: string): string[] {\n    const typos: string[] = [];\n\n    // Adjacent key swaps (simplified)\n    for (let i = 0; i < word.length - 1; i++) {\n      const chars = word.split('');\n      [chars[i], chars[i + 1]] = [chars[i + 1], chars[i]];\n      typos.push(chars.join(''));\n    }\n\n    // Missing letters\n    for (let i = 0; i < word.length; i++) {\n      typos.push(word.slice(0, i) + word.slice(i + 1));\n    }\n\n    // Doubled letters\n    for (let i = 0; i < word.length; i++) {\n      typos.push(word.slice(0, i + 1) + word[i] + word.slice(i + 1));\n    }\n\n    return [...new Set(typos)];\n  }\n\n  /**\n   * Extract keywords from text\n   */\n  static extractKeywords(text: string): string[] {\n    const normalized = this.normalizeText(text, false);\n    const words = normalized.split(/\\s+/);\n\n    // Filter out common stop words\n    const stopWords = new Set([\n      'the',\n      'a',\n      'an',\n      'and',\n      'or',\n      'but',\n      'in',\n      'on',\n      'at',\n      'to',\n      'for',\n      'of',\n      'with',\n      'by',\n      'from',\n      'as',\n      'is',\n      'was',\n      'are',\n      'were',\n      'be',\n      'been',\n      'being',\n      'have',\n      'has',\n      'had',\n      'do',\n      'does',\n      'did',\n      'will',\n      'would',\n      'should',\n      'could',\n      'may',\n      'might',\n      'must',\n      'can',\n      'shall',\n      'this',\n      'that',\n      'these',\n      'those',\n      'it',\n      'its',\n      'he',\n      'she',\n      'they',\n      'we',\n      'you',\n      'i',\n      'me',\n      'him',\n      'her',\n      'us',\n      'them',\n      'my',\n      'your',\n      'his',\n      'her',\n      'our',\n      'their',\n      'what',\n      'which',\n      'who',\n      'whom',\n      'whose',\n      'when',\n      'where',\n      'why',\n      'how',\n      'all',\n      'any',\n      'both',\n      'each',\n      'few',\n      'more',\n      'most',\n      'other',\n      'some',\n      'such',\n      'no',\n      'nor',\n      'not',\n      'only',\n      'own',\n      'same',\n      'so',\n      'than',\n      'too',\n      'very',\n      'just',\n      'now',\n      'also',\n    ]);\n\n    return words.filter(word => word.length > 2 && !stopWords.has(word));\n  }\n}\n","import { FC, memo, useState, useCallback, FormEvent, useEffect } from 'react';\nimport cn from 'classnames';\nimport { TextMatcher } from '@/utils/textMatching';\nimport styles from './FreeTextInput.module.css';\n\ninterface FreeTextInputProps {\n  correctAnswer: string;\n  acceptedAnswers?: string[];\n  onSubmit: (answer: string, isCorrect: boolean) => void;\n  showFeedback: boolean;\n  feedback?: { isCorrect: boolean };\n  disabled: boolean;\n  resetKey?: string | number; // Key to reset input when question changes\n}\n\nexport const FreeTextInput: FC<FreeTextInputProps> = memo(\n  ({ correctAnswer, acceptedAnswers, onSubmit, showFeedback, feedback, disabled, resetKey }) => {\n    const [userInput, setUserInput] = useState('');\n    const [hasSubmitted, setHasSubmitted] = useState(false);\n\n    // Reset input when resetKey changes (new question)\n    useEffect(() => {\n      setUserInput('');\n      setHasSubmitted(false);\n    }, [resetKey]);\n\n    const handleSubmit = useCallback(\n      (e: FormEvent) => {\n        e.preventDefault();\n        if (!userInput.trim() || hasSubmitted || disabled) return;\n\n        const allAcceptedAnswers = [correctAnswer, ...(acceptedAnswers || [])];\n        const isCorrect = TextMatcher.isMatch(userInput, allAcceptedAnswers);\n\n        setHasSubmitted(true);\n        onSubmit(userInput, isCorrect);\n      },\n      [userInput, correctAnswer, acceptedAnswers, onSubmit, hasSubmitted, disabled]\n    );\n\n    const handleOverride = useCallback(() => {\n      // Allow user to mark their answer as correct\n      onSubmit(userInput, true);\n    }, [userInput, onSubmit]);\n\n    // Add keyboard listener for \"1\" key to trigger override\n    useEffect(() => {\n      if (!showFeedback || feedback?.isCorrect !== false) return;\n\n      const handleKeyPress = (e: KeyboardEvent) => {\n        // Check if \"1\" key is pressed and no input/textarea is focused\n        if (\n          e.key === '1' &&\n          document.activeElement?.tagName !== 'INPUT' &&\n          document.activeElement?.tagName !== 'TEXTAREA'\n        ) {\n          e.preventDefault();\n          handleOverride();\n        }\n      };\n\n      window.addEventListener('keydown', handleKeyPress);\n      return () => window.removeEventListener('keydown', handleKeyPress);\n    }, [showFeedback, feedback?.isCorrect, handleOverride]);\n\n    const handleKeyDown = useCallback(\n      (e: React.KeyboardEvent<HTMLInputElement>) => {\n        // Always stop propagation so global handlers (e.g., Continue on Enter) don't\n        // trigger on the same key press as the submission.\n        e.stopPropagation();\n\n        // Only handle Enter key for submission if not already submitted\n        if (e.key === 'Enter' && !e.shiftKey) {\n          if (!hasSubmitted && !disabled) {\n            handleSubmit(e as unknown as FormEvent);\n          }\n          // Do not let this Enter bubble; parent will handle next Enter after feedback\n          // when the input becomes disabled.\n        }\n      },\n      [handleSubmit, hasSubmitted, disabled]\n    );\n\n    return (\n      <form className={styles.freeTextForm} onSubmit={handleSubmit}>\n        <div className={styles.inputGroup}>\n          <input\n            type=\"text\"\n            value={userInput}\n            onChange={e => setUserInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            className={cn(\n              styles.textInput,\n              showFeedback && feedback?.isCorrect === true && styles.correct,\n              showFeedback && feedback?.isCorrect === false && styles.incorrect,\n              disabled && styles.disabled\n            )}\n            placeholder=\"Type your answer...\"\n            disabled={disabled || hasSubmitted}\n            aria-label=\"Your answer\"\n            aria-invalid={showFeedback && !feedback?.isCorrect}\n            aria-describedby={showFeedback ? 'feedback-message' : undefined}\n            autoComplete=\"off\"\n            autoFocus\n            data-testid=\"text-input\"\n          />\n          <button\n            type=\"submit\"\n            className={cn(\n              styles.submitButton,\n              (!userInput.trim() || disabled || hasSubmitted) && styles.disabled\n            )}\n            disabled={!userInput.trim() || disabled || hasSubmitted}\n            aria-label=\"Submit answer\"\n            data-testid=\"submit-button\"\n          >\n            {hasSubmitted ? 'Submitted' : 'Submit'}\n          </button>\n        </div>\n\n        {showFeedback && feedback?.isCorrect === false && (\n          <div id=\"feedback-message\" className={styles.feedbackWrapper}>\n            <div className={styles.overrideSection}>\n              <p className={styles.overrideText}>Think your answer was correct?</p>\n              <button\n                type=\"button\"\n                className={styles.overrideButton}\n                onClick={handleOverride}\n                aria-label=\"Mark my answer as correct\"\n                data-testid=\"override-button\"\n              >\n                Actually, I was correct\n              </button>\n            </div>\n          </div>\n        )}\n      </form>\n    );\n  }\n);\n\nFreeTextInput.displayName = 'FreeTextInput';\n","import { FC, memo } from 'react';\nimport cn from 'classnames';\nimport styles from './FeedbackSection.module.css';\n\ninterface FeedbackSectionProps {\n  isCorrect: boolean;\n  correctAnswer?: string;\n  explanation?: string;\n  isMastered?: boolean;\n  onShowCardDetails?: () => void;\n}\n\nexport const FeedbackSection: FC<FeedbackSectionProps> = memo(\n  ({ isCorrect, correctAnswer, explanation, isMastered, onShowCardDetails }) => {\n    return (\n      <div\n        className={cn(styles.feedbackSection, isCorrect ? styles.correct : styles.incorrect)}\n        role=\"alert\"\n        aria-live=\"polite\"\n        data-testid=\"feedback-section\"\n      >\n        <div className={styles.feedbackHeader}>\n          <span className={styles.feedbackIcon} aria-hidden=\"true\">\n            {isCorrect ? '✓' : '✗'}\n          </span>\n          <h3 className={styles.feedbackTitle}>\n            {isCorrect ? (isMastered ? 'Card Mastered! 🎯' : 'Correct!') : 'Not quite right'}\n          </h3>\n        </div>\n\n        <div className={styles.feedbackContent}>\n          {!isCorrect && correctAnswer && (\n            <div\n              className={cn(styles.correctAnswerWrapper, onShowCardDetails && styles.clickable)}\n              onClick={onShowCardDetails}\n              role={onShowCardDetails ? 'button' : undefined}\n              tabIndex={onShowCardDetails ? 0 : undefined}\n              onKeyDown={\n                onShowCardDetails\n                  ? e => {\n                      if (e.key === 'Enter' || e.key === ' ') {\n                        e.preventDefault();\n                        onShowCardDetails();\n                      }\n                    }\n                  : undefined\n              }\n              aria-label={onShowCardDetails ? 'Click to view full card details' : undefined}\n            >\n              <span className={styles.correctAnswerLabel}>Correct answer:</span>\n              <span className={styles.correctAnswerText}>{correctAnswer}</span>\n              {onShowCardDetails && (\n                <span className={styles.viewDetailsHint} aria-hidden=\"true\">\n                  Click to view card details\n                </span>\n              )}\n            </div>\n          )}\n\n          {explanation && (\n            <div className={styles.explanationWrapper}>\n              <p className={styles.explanationText}>{explanation}</p>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nFeedbackSection.displayName = 'FeedbackSection';\n","import { FC, memo } from 'react';\nimport { Question, Card } from '@/types';\nimport { MultipleChoiceOptions } from './MultipleChoiceOptions';\nimport { FreeTextInput } from './FreeTextInput';\nimport { FeedbackSection } from './FeedbackSection';\nimport styles from './QuestionCard.module.css';\n\ninterface QuestionCardProps {\n  question: Question;\n  card?: Card;\n  onAnswer: (answer: string, isCorrect: boolean) => void;\n  showFeedback: boolean;\n  feedback?: {\n    isCorrect: boolean;\n    correctAnswer?: string;\n    explanation?: string;\n    isMastered?: boolean;\n  };\n  disabled?: boolean;\n  onShowCardDetails?: () => void;\n}\n\nexport const QuestionCard: FC<QuestionCardProps> = memo(\n  ({\n    question,\n    card: _card,\n    onAnswer,\n    showFeedback,\n    feedback,\n    disabled = false,\n    onShowCardDetails,\n  }) => {\n    return (\n      <article\n        className={styles.questionCard}\n        role=\"region\"\n        aria-labelledby=\"question-text\"\n        data-testid=\"question-card\"\n        data-question-type={question.type}\n      >\n        <header className={styles.questionHeader}>\n          <h2 id=\"question-text\" className={styles.questionText}>\n            {question.questionText}\n          </h2>\n          {question.difficulty && (\n            <div\n              className={styles.difficultyIndicator}\n              aria-label={`Difficulty: ${Math.round(question.difficulty * 100)}%`}\n            >\n              <div\n                className={styles.difficultyBar}\n                style={{ width: `${question.difficulty * 100}%` }}\n              />\n            </div>\n          )}\n        </header>\n\n        <div className={styles.questionContent}>\n          {question.type === 'multiple_choice' ? (\n            <MultipleChoiceOptions\n              options={question.options!}\n              correctAnswer={question.correctAnswer}\n              onSelect={onAnswer}\n              showFeedback={showFeedback}\n              feedback={feedback}\n              disabled={disabled}\n              resetKey={question.id}\n            />\n          ) : (\n            <FreeTextInput\n              correctAnswer={question.correctAnswer}\n              acceptedAnswers={question.acceptedAnswers}\n              onSubmit={onAnswer}\n              showFeedback={showFeedback}\n              feedback={feedback}\n              disabled={disabled || showFeedback}\n              resetKey={question.id}\n            />\n          )}\n        </div>\n\n        {showFeedback && feedback && (\n          <FeedbackSection\n            isCorrect={feedback.isCorrect}\n            correctAnswer={feedback.correctAnswer}\n            explanation={feedback.explanation}\n            isMastered={feedback.isMastered}\n            onShowCardDetails={onShowCardDetails}\n          />\n        )}\n      </article>\n    );\n  }\n);\n\nQuestionCard.displayName = 'QuestionCard';\n","import { FC, memo, useCallback, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { QuestionFlowProps } from '../types';\r\nimport { QuestionCard } from '../QuestionCard';\r\nimport styles from './QuestionFlow.module.css';\r\n\r\nexport const QuestionFlow: FC<QuestionFlowProps> = memo(\r\n  ({\r\n    currentCard,\r\n    currentQuestion,\r\n    showFeedback,\r\n    feedback,\r\n    onAnswerSubmit,\r\n    onQuestionComplete,\r\n    onShowCardDetails,\r\n  }) => {\r\n    // Handle answer submission\r\n    const handleAnswerSubmit = useCallback(\r\n      (answer: string, isCorrect: boolean) => {\r\n        if (!currentCard) return;\r\n        onAnswerSubmit(answer, isCorrect, currentCard.idx);\r\n      },\r\n      [currentCard, onAnswerSubmit]\r\n    );\r\n\r\n    // Handle show card details\r\n    const handleShowDetails = useCallback(() => {\r\n      if (currentCard) {\r\n        onShowCardDetails(currentCard);\r\n      }\r\n    }, [currentCard, onShowCardDetails]);\r\n\r\n    // Handle keyboard shortcut for continue button (Enter key)\r\n    useEffect(() => {\r\n      const handleKeyDown = (e: KeyboardEvent) => {\r\n        if (!showFeedback || e.key !== 'Enter') return;\r\n\r\n        const target = e.target as HTMLElement | null;\r\n        const isTypingTarget =\r\n          !!target &&\r\n          (target.tagName === 'INPUT' ||\r\n            target.tagName === 'TEXTAREA' ||\r\n            target.getAttribute('contenteditable') === 'true');\r\n\r\n        if (isTypingTarget) return;\r\n\r\n        e.preventDefault();\r\n        onQuestionComplete();\r\n      };\r\n\r\n      window.addEventListener('keydown', handleKeyDown);\r\n      return () => window.removeEventListener('keydown', handleKeyDown);\r\n    }, [showFeedback, onQuestionComplete]);\r\n\r\n    if (!currentQuestion) {\r\n      return (\r\n        <div className={styles.noQuestion}>\r\n          <p>No questions available</p>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div className={styles.questionFlowContainer} data-testid=\"question-flow\">\r\n        <AnimatePresence mode=\"wait\">\r\n          <motion.div\r\n            key={currentQuestion?.id || 'no-question'}\r\n            initial={{ opacity: 0, x: 20 }}\r\n            animate={{ opacity: 1, x: 0 }}\r\n            exit={{ opacity: 0, x: -20 }}\r\n            transition={{ duration: 0.3 }}\r\n            className={styles.questionWrapper}\r\n          >\r\n            {/* Question Card handles all the question display and feedback */}\r\n            <QuestionCard\r\n              question={currentQuestion}\r\n              card={currentCard || undefined}\r\n              onAnswer={handleAnswerSubmit}\r\n              showFeedback={showFeedback}\r\n              feedback={feedback}\r\n              onShowCardDetails={handleShowDetails}\r\n            />\r\n\r\n            {/* Continue button when feedback is shown */}\r\n            {showFeedback && (\r\n              <div className={styles.continueSection}>\r\n                <button\r\n                  onClick={onQuestionComplete}\r\n                  className={styles.continueButton}\r\n                  autoFocus\r\n                  data-testid=\"continue-button\"\r\n                >\r\n                  Continue (Enter)\r\n                </button>\r\n              </div>\r\n            )}\r\n          </motion.div>\r\n        </AnimatePresence>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n","import { FC, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { Card } from '@/types';\nimport styles from './CardDetailsModal.module.css';\n\ninterface CardDetailsModalProps {\n  card: Card | null;\n  visible: boolean;\n  onClose: () => void;\n  frontSides?: string[];\n  backSides?: string[];\n}\n\nconst CardDetailsModal: FC<CardDetailsModalProps> = ({\n  card,\n  visible,\n  onClose,\n  frontSides = ['side_a'],\n  backSides = ['side_b'],\n}) => {\n  // Handle ESC key to close modal\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && visible) {\n        onClose();\n      }\n    };\n\n    if (visible) {\n      document.addEventListener('keydown', handleEscape);\n      // Prevent body scroll when modal is open\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.body.style.overflow = '';\n    };\n  }, [visible, onClose]);\n\n  if (!card) return null;\n\n  // Get content for each side\n  const getSideContent = (sides: string[]) => {\n    return sides\n      .filter(side => card[side as keyof Card])\n      .map(side => ({\n        label: side.replace('side_', 'Side ').toUpperCase(),\n        content: card[side as keyof Card] as string,\n      }));\n  };\n\n  const frontContent = getSideContent(frontSides);\n  const backContent = getSideContent(backSides);\n\n  // Get all available sides for full detail view\n  const allSides = ['side_a', 'side_b', 'side_c', 'side_d', 'side_e', 'side_f']\n    .filter(side => card[side as keyof Card])\n    .map(side => ({\n      label: side.replace('side_', 'Side ').toUpperCase(),\n      content: card[side as keyof Card] as string,\n    }));\n\n  return (\n    <AnimatePresence>\n      {visible && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            className={styles.backdrop}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            onClick={onClose}\n          />\n\n          {/* Modal */}\n          <motion.div\n            className={styles.modal}\n            initial={{ opacity: 0, scale: 0.95, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 20 }}\n            transition={{ duration: 0.2, type: 'spring', stiffness: 300, damping: 30 }}\n          >\n            <div className={styles.modalContent}>\n              <header className={styles.modalHeader}>\n                <h2 className={styles.modalTitle}>Card Details</h2>\n                <button className={styles.closeButton} onClick={onClose} aria-label=\"Close modal\">\n                  ×\n                </button>\n              </header>\n\n              <div className={styles.modalBody}>\n                {/* Show configured front/back content */}\n                <section className={styles.configuredContent}>\n                  <div className={styles.sideGroup}>\n                    <h3 className={styles.sideGroupTitle}>\n                      Front Side{frontContent.length > 1 ? 's' : ''}\n                    </h3>\n                    {frontContent.map((item, index) => (\n                      <div key={index} className={styles.sideItem}>\n                        <span className={styles.sideLabel}>{item.label}:</span>\n                        <p className={styles.sideContent}>{item.content}</p>\n                      </div>\n                    ))}\n                  </div>\n\n                  <div className={styles.sideGroup}>\n                    <h3 className={styles.sideGroupTitle}>\n                      Back Side{backContent.length > 1 ? 's' : ''}\n                    </h3>\n                    {backContent.map((item, index) => (\n                      <div key={index} className={styles.sideItem}>\n                        <span className={styles.sideLabel}>{item.label}:</span>\n                        <p className={styles.sideContent}>{item.content}</p>\n                      </div>\n                    ))}\n                  </div>\n                </section>\n\n                {/* Show all available sides if there are additional sides */}\n                {allSides.length > frontContent.length + backContent.length && (\n                  <section className={styles.allSides}>\n                    <h3 className={styles.allSidesTitle}>All Available Sides</h3>\n                    <div className={styles.sidesGrid}>\n                      {allSides.map((item, index) => (\n                        <div key={index} className={styles.sideCard}>\n                          <div className={styles.sideCardHeader}>\n                            <span className={styles.sideCardLabel}>{item.label}</span>\n                          </div>\n                          <p className={styles.sideCardContent}>{item.content}</p>\n                        </div>\n                      ))}\n                    </div>\n                  </section>\n                )}\n\n                {/* Card metadata */}\n                {(card.level !== undefined || card.idx !== undefined) && (\n                  <section className={styles.metadata}>\n                    <div className={styles.metadataItems}>\n                      {card.level !== undefined && (\n                        <span className={styles.metadataItem}>\n                          <strong>Level:</strong> {card.level}\n                        </span>\n                      )}\n                      {card.idx !== undefined && (\n                        <span className={styles.metadataItem}>\n                          <strong>Index:</strong> {card.idx + 1}\n                        </span>\n                      )}\n                    </div>\n                  </section>\n                )}\n              </div>\n\n              <footer className={styles.modalFooter}>\n                <button className={styles.actionButton} onClick={onClose}>\n                  Close\n                </button>\n              </footer>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n};\n\nexport default CardDetailsModal;\n","import { FC, useState, useCallback, useEffect, memo } from 'react';\r\nimport { Card, Deck, LearnModeSettings, LearnSessionResults } from '@/types';\r\nimport { useQuestionGenerator } from '@/hooks/useQuestionGenerator';\r\nimport { useCardScheduler } from '@/hooks/useCardScheduler';\r\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\r\nimport { useSessionState } from './hooks/useSessionState';\r\nimport { QuestionFlow } from './components/QuestionFlow';\r\nimport { FeedbackData } from './types';\r\nimport CardDetailsModal from '@/components/modals/CardDetailsModal';\r\nimport { SharedModeHeader } from '@/components/common/SharedModeHeader';\r\nimport styles from './LearnContainer.module.css';\r\n\r\ninterface LearnContainerProps {\r\n  deck: Deck;\r\n  settings: LearnModeSettings;\r\n  strugglingCardIndices?: number[];\r\n  onComplete: (results: LearnSessionResults) => void;\r\n  onExit: () => void;\r\n  onOpenSettings: () => void;\r\n  deckId?: string;\r\n  allDeckCards?: Card[];\r\n}\r\n\r\nconst LearnContainer: FC<LearnContainerProps> = memo(\r\n  ({\r\n    deck,\r\n    settings,\r\n    strugglingCardIndices: initialStrugglingCards,\r\n    onComplete,\r\n    onExit,\r\n    onOpenSettings,\r\n    deckId,\r\n    allDeckCards,\r\n  }) => {\r\n    // Use the new session state hook\r\n    const { sessionState, updateSessionState, handleAnswer, nextQuestion, cardTracking } =\r\n      useSessionState(deck, settings);\r\n\r\n    // Local UI state\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [showFeedback, setShowFeedback] = useState(false);\r\n    const [feedback, setFeedback] = useState<FeedbackData | undefined>(undefined);\r\n    const [showCardDetailsModal, setShowCardDetailsModal] = useState(false);\r\n    const [currentCard, setCurrentCard] = useState<Card | null>(null);\r\n    const [currentQuestion, setCurrentQuestion] = useState(sessionState.currentQuestion);\r\n  const [servedCount, setServedCount] = useState(0);\r\n\r\n    // Use existing hooks\r\n    const {\r\n      generateRound,\r\n      currentQuestion: generatedQuestion,\r\n      nextQuestion: nextGeneratedQuestion,\r\n    } = useQuestionGenerator(deck, settings);\r\n    const scheduler = useCardScheduler(settings);\r\n    const { isCardMastered } = useCardMasteryStore();\r\n\r\n    // Update current question when generator changes\r\n    useEffect(() => {\r\n      if (generatedQuestion) {\r\n        setCurrentQuestion(generatedQuestion);\r\n        updateSessionState({\r\n          currentQuestion: generatedQuestion,\r\n        });\r\n\r\n        // Update current card\r\n        const cardIndex = generatedQuestion.cardIndex;\r\n        const card = sessionState.roundCards.find(c => c.idx === cardIndex);\r\n        if (card) {\r\n          setCurrentCard(card);\r\n        }\r\n      }\r\n    }, [generatedQuestion, sessionState.roundCards]);\r\n\r\n    // Initialize session on mount or settings change\r\n    useEffect(() => {\r\n      const initializeSession = async () => {\r\n        setIsLoading(true);\r\n\r\n        // Check if deck has content\r\n        if (!deck.content || deck.content.length === 0) {\r\n          setIsLoading(false);\r\n          return;\r\n        }\r\n\r\n        // Get scheduled cards\r\n        const cardsToLearn: Card[] = [];\r\n\r\n        // First, add struggling cards if provided\r\n        if (initialStrugglingCards && initialStrugglingCards.length > 0) {\r\n          const strugglingCards = initialStrugglingCards\r\n            .map(idx => deck.content.find(c => c.idx === idx))\r\n            .filter((c): c is Card => c !== undefined);\r\n          cardsToLearn.push(...strugglingCards);\r\n        }\r\n\r\n        // If we need more cards to reach cardsPerRound, add new cards\r\n        if (cardsToLearn.length < settings.cardsPerRound) {\r\n          // Get cards that aren't already in the struggling list\r\n          const strugglingIndices = new Set(initialStrugglingCards || []);\r\n          const availableCards = deck.content.filter(card => !strugglingIndices.has(card.idx));\r\n\r\n          // Use scheduler to select additional cards\r\n          const additionalCards = scheduler.scheduleCards(availableCards);\r\n          const cardsNeeded = settings.cardsPerRound - cardsToLearn.length;\r\n          cardsToLearn.push(...additionalCards.slice(0, cardsNeeded));\r\n        }\r\n\r\n        if (cardsToLearn.length === 0) {\r\n          setIsLoading(false);\r\n          return;\r\n        }\r\n\r\n        // Take only the cards per round setting (in case we have more struggling cards than the round size)\r\n        const roundCards = cardsToLearn.slice(0, settings.cardsPerRound);\r\n\r\n        // Generate questions for the round\r\n        generateRound(roundCards, allDeckCards || deck.content);\r\n\r\n        // Update session state with round cards\r\n        updateSessionState({\r\n          roundCards,\r\n          responseStartTime: Date.now(),\r\n        });\r\n\r\n        // Reset served counter for new round\r\n        setServedCount(0);\r\n\r\n        setIsLoading(false);\r\n      };\r\n\r\n      initializeSession();\r\n    }, [deck, settings, initialStrugglingCards]);\r\n\r\n    // Handle answer submission\r\n    const handleAnswerSubmit = useCallback(\r\n      (answer: string, isCorrect: boolean, cardIdx: number) => {\r\n        // Update session state\r\n        handleAnswer(answer, isCorrect, cardIdx);\r\n\r\n        // Check if card is mastered\r\n        const isMastered = deckId ? isCardMastered(deckId, cardIdx) : false;\r\n\r\n        // Set feedback\r\n        setFeedback({\r\n          isCorrect,\r\n          correctAnswer: sessionState.currentQuestion?.correctAnswer || '',\r\n          explanation: sessionState.currentQuestion?.explanation,\r\n          isMastered,\r\n        });\r\n        setShowFeedback(true);\r\n      },\r\n      [handleAnswer, deckId, isCardMastered, sessionState.currentQuestion]\r\n    );\r\n\r\n    // Handle moving to next question\r\n    const handleQuestionComplete = useCallback(() => {\r\n      // Hard cap session to the number of round cards, regardless of generated follow-ups\r\n      const targetCount = sessionState.roundCards.length || 0;\r\n      if (servedCount + 1 >= targetCount) {\r\n        const totalAnswered = sessionState.correctCards.size + sessionState.incorrectCards.size;\r\n        const accuracyPercent =\r\n          totalAnswered > 0 ? (sessionState.correctCards.size / totalAnswered) * 100 : 0;\r\n\r\n        const results: LearnSessionResults = {\r\n          deckId: deckId || '',\r\n          totalQuestions: totalAnswered,\r\n          correctAnswers: sessionState.correctCards.size,\r\n          incorrectAnswers: sessionState.incorrectCards.size,\r\n          accuracy: accuracyPercent,\r\n          averageResponseTime:\r\n            sessionState.responseTimes.length > 0\r\n              ? sessionState.responseTimes.reduce((a, b) => a + b, 0) / sessionState.responseTimes.length\r\n              : 0,\r\n          maxStreak: sessionState.maxStreak,\r\n          duration: Date.now() - sessionState.startTime,\r\n          passedCards: Array.from(sessionState.correctCards),\r\n          strugglingCards: Array.from(cardTracking.strugglingCardIndices),\r\n          masteredCards: Array.from(cardTracking.masteredCardIndices),\r\n        };\r\n        onComplete(results);\r\n        return;\r\n      }\r\n\r\n      // Reset feedback BEFORE advancing so next question doesn't inherit feedback state\r\n      setShowFeedback(false);\r\n      setFeedback(undefined);\r\n\r\n      // Advance question generators/state\r\n      nextGeneratedQuestion();\r\n      nextQuestion();\r\n      setServedCount(prev => prev + 1);\r\n    }, [\r\n      sessionState,\r\n      cardTracking,\r\n      deckId,\r\n      nextGeneratedQuestion,\r\n      nextQuestion,\r\n      onComplete,\r\n      servedCount,\r\n    ]);\r\n\r\n    // Handle showing card details\r\n    const handleShowCardDetails = useCallback((card: Card) => {\r\n      setCurrentCard(card);\r\n      setShowCardDetailsModal(true);\r\n    }, []);\r\n\r\n    // Handle settings click\r\n    const handleSettingsClick = useCallback(() => {\r\n      onOpenSettings();\r\n    }, [onOpenSettings]);\r\n\r\n    if (isLoading) {\r\n      return (\r\n        <div className={styles.container}>\r\n          <div className={styles.loading}>Loading questions...</div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    if (sessionState.roundCards.length === 0) {\r\n      return (\r\n        <div className={styles.container}>\r\n          <div className={styles.emptyState}>\r\n            <h2>No cards available</h2>\r\n            <p>Adjust your settings to include more cards.</p>\r\n            <button onClick={onOpenSettings} className={styles.settingsButton}>\r\n              Open Settings\r\n            </button>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div className={styles.container}>\r\n        <SharedModeHeader\r\n          deckName={deck.metadata.deck_name}\r\n          currentCard={servedCount + 1}\r\n          totalCards={sessionState.roundCards.length}\r\n          onBackClick={onExit}\r\n          onSettingsClick={handleSettingsClick}\r\n          showSettings={true}\r\n        />\r\n\r\n        {/* Question Flow */}\r\n        <QuestionFlow\r\n          sessionState={sessionState}\r\n          deck={deck}\r\n          settings={settings}\r\n          currentCard={currentCard}\r\n          currentQuestion={currentQuestion}\r\n          showFeedback={showFeedback}\r\n          feedback={feedback}\r\n          onAnswerSubmit={handleAnswerSubmit}\r\n          onQuestionComplete={handleQuestionComplete}\r\n          onShowCardDetails={handleShowCardDetails}\r\n        />\r\n\r\n        {/* Card Details Modal */}\r\n        {showCardDetailsModal && currentCard && (\r\n          <CardDetailsModal\r\n            card={currentCard}\r\n            visible={showCardDetailsModal}\r\n            onClose={() => setShowCardDetailsModal(false)}\r\n            frontSides={settings.frontSides}\r\n            backSides={settings.backSides}\r\n          />\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\nexport default LearnContainer;\r\n","import { useState, useCallback, useMemo } from 'react';\nimport { Deck, Question, LearnModeSettings, Card } from '@/types';\nimport { QuestionGenerator } from '@/services/questionGenerator';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\n\ninterface UseQuestionGeneratorReturn {\n  questions: Question[];\n  currentQuestion: Question | null;\n  currentQuestionIndex: number;\n  hasNext: boolean;\n  nextQuestion: () => void;\n  generateRound: (cards: Card[], allDeckCards?: Card[]) => void;\n  reset: () => void;\n  addFollowUpQuestion: (cardIndex: number, parentQuestionId: string) => void;\n  markMCCorrect: (cardIndex: number) => void;\n}\n\nexport const useQuestionGenerator = (\n  deck: Deck,\n  settings: LearnModeSettings\n): UseQuestionGeneratorReturn => {\n  const { getMasteredCards } = useCardMasteryStore();\n  const [questions, setQuestions] = useState<Question[]>([]);\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n  const [correctMCCards, setCorrectMCCards] = useState<Set<number>>(new Set());\n  const [cardQuestionCounts, setCardQuestionCounts] = useState<Map<number, number>>(new Map());\n\n  const generateRound = useCallback(\n    (cards: Card[], allDeckCards?: Card[]) => {\n      // Get mastered cards for the current deck\n      const masteredCardIndices = getMasteredCards(deck.id);\n\n      const newQuestions = QuestionGenerator.generateQuestions(\n        cards,\n        {\n          questionTypes: settings.questionTypes || ['multiple_choice'],\n          frontSides: settings.questionSides || settings.frontSides || ['side_a'],\n          backSides: settings.answerSides || settings.backSides || ['side_b'],\n          difficulty: 1, // Can be adjusted based on user performance\n          excludeCards: new Set(),\n          forceMultipleChoice: false, // Use questionTypeMix setting instead\n          questionTypeMix: settings.questionTypeMix || 'auto',\n        },\n        masteredCardIndices,\n        allDeckCards || cards // Pass all deck cards if provided, otherwise use round cards\n      );\n\n      setQuestions(newQuestions);\n      setCurrentQuestionIndex(0);\n      setCorrectMCCards(new Set());\n      setCardQuestionCounts(new Map());\n    },\n    [settings, deck.id, getMasteredCards]\n  );\n\n  const addFollowUpQuestion = useCallback(\n    (cardIndex: number, parentQuestionId: string) => {\n      // Only add follow-up if progressive learning is enabled\n      if (!settings.questionTypes?.includes('free_text')) return;\n\n      // Create a follow-up free text question\n      const cards = questions\n        .filter(q => q.cardIndex === cardIndex)\n        .map(\n          q =>\n            ({\n              idx: cardIndex,\n              name: '',\n              side_a: q.questionText,\n              side_b: q.correctAnswer,\n              level: 1,\n            }) as Card\n        );\n\n      if (cards.length > 0) {\n        const followUpQuestion = QuestionGenerator.generateFreeText(\n          cards[0],\n          { front: settings.frontSides || ['side_a'], back: settings.backSides || ['side_b'] },\n          cardIndex\n        );\n\n        const enhancedFollowUp: Question = {\n          ...followUpQuestion,\n          id: `ft_followup_${parentQuestionId}_${Date.now()}`,\n          isFollowUp: true,\n          parentQuestionId,\n          questionText: `Now type the answer: ${followUpQuestion.questionText}`,\n        };\n\n        // Insert the follow-up question after the current question\n        setQuestions(prev => {\n          const newQuestions = [...prev];\n          newQuestions.splice(currentQuestionIndex + 1, 0, enhancedFollowUp);\n          return newQuestions;\n        });\n      }\n    },\n    [questions, currentQuestionIndex, settings]\n  );\n\n  const shouldAddFollowUp = useCallback(\n    (cardIndex: number): boolean => {\n      // Don't add follow-up if free text is not enabled\n      if (!settings.questionTypes?.includes('free_text')) return false;\n\n      // Get progressive learning configuration\n      const progressiveLearning = settings.progressiveLearning ?? 'spaced';\n      const minSpacing = settings.progressiveLearningSpacing ?? 3;\n\n      if (progressiveLearning === 'disabled') return false;\n\n      if (progressiveLearning === 'immediate') {\n        // Immediate mode should still respect spacing settings\n        // Only add follow-up if we haven't already asked for this card AND respect spacing\n        const count = cardQuestionCounts.get(cardIndex) || 0;\n\n        // For immediate mode with spacing, we ensure there's a gap\n        if (minSpacing > 1) {\n          // Must have at least (minSpacing - 1) other questions in between\n          const otherQuestionsSince =\n            currentQuestionIndex -\n            questions\n              .slice(0, currentQuestionIndex)\n              .reverse()\n              .findIndex(q => q.cardIndex === cardIndex);\n\n          return count < 2 && otherQuestionsSince >= minSpacing;\n        }\n\n        // If spacing is 1 or not set, allow immediate follow-up\n        return count < 2;\n      }\n\n      if (progressiveLearning === 'spaced') {\n        // For spaced mode, we need proper spacing between MC and FT for the same card\n        // This is called right after an MC question is answered correctly\n\n        // Find the most recent question for this card (should be the current MC question)\n        let lastCardQuestionIndex = -1;\n        for (let i = currentQuestionIndex; i >= 0; i--) {\n          if (questions[i].cardIndex === cardIndex && !questions[i].isFollowUp) {\n            lastCardQuestionIndex = i;\n            break;\n          }\n        }\n\n        // If we just answered this card's MC question (it's at currentQuestionIndex)\n        if (lastCardQuestionIndex === currentQuestionIndex) {\n          // Don't add follow-up immediately - need spacing in spaced mode\n          return false;\n        }\n\n        // Check if enough questions have passed since we last saw this card\n        const questionsSince = currentQuestionIndex - lastCardQuestionIndex;\n\n        // Only add follow-up if we have proper spacing\n        return questionsSince >= minSpacing;\n      }\n\n      if (progressiveLearning === 'random') {\n        // 30% chance of adding a follow-up\n        return Math.random() < 0.3;\n      }\n\n      return false;\n    },\n    [settings, cardQuestionCounts, questions, currentQuestionIndex]\n  );\n\n  const nextQuestion = useCallback(() => {\n    const currentQ = questions[currentQuestionIndex];\n\n    // Update card question count\n    if (currentQ) {\n      setCardQuestionCounts(prev => {\n        const newCounts = new Map(prev);\n        newCounts.set(currentQ.cardIndex, (prev.get(currentQ.cardIndex) || 0) + 1);\n        return newCounts;\n      });\n    }\n\n    // Check if we should add a follow-up question for correctly answered MC\n    if (\n      currentQ &&\n      currentQ.type === 'multiple_choice' &&\n      !currentQ.isFollowUp &&\n      correctMCCards.has(currentQ.cardIndex) &&\n      !questions[currentQuestionIndex + 1]?.isFollowUp &&\n      // Do not insert a follow-up if we're on the last question\n      currentQuestionIndex < questions.length - 1 &&\n      shouldAddFollowUp(currentQ.cardIndex)\n    ) {\n      // Add a follow-up free text question\n      addFollowUpQuestion(currentQ.cardIndex, currentQ.id);\n    }\n\n    setCurrentQuestionIndex(prev => Math.min(prev + 1, questions.length - 1));\n  }, [questions, currentQuestionIndex, correctMCCards, addFollowUpQuestion, shouldAddFollowUp]);\n\n  const reset = useCallback(() => {\n    setQuestions([]);\n    setCurrentQuestionIndex(0);\n    setCorrectMCCards(new Set());\n    setCardQuestionCounts(new Map());\n  }, []);\n\n  const currentQuestion = useMemo(() => {\n    return questions[currentQuestionIndex] || null;\n  }, [questions, currentQuestionIndex]);\n\n  const hasNext = useMemo(() => {\n    return currentQuestionIndex < questions.length - 1;\n  }, [currentQuestionIndex, questions.length]);\n\n  // Track correctly answered MC questions\n  const markMCCorrect = useCallback((cardIndex: number) => {\n    setCorrectMCCards(prev => new Set(prev).add(cardIndex));\n  }, []);\n\n  return {\n    questions,\n    currentQuestion,\n    currentQuestionIndex,\n    hasNext,\n    nextQuestion,\n    generateRound,\n    reset,\n    addFollowUpQuestion,\n    markMCCorrect,\n  };\n};\n"],"names":["QuestionGenerator","generateQuestions","cards","options","masteredCardIndices","allDeckCards","questions","usedCardIndices","Set","forEach","card","excludeCards","has","idx","forceMultipleChoice","this","selectQuestionType","questionTypes","questionTypeMix","push","generateMultipleChoice","front","frontSides","back","backSides","generateFreeText","add","shuffleQuestions","difficulty","allCards","sides","cardIndex","questionText","buildQuestionText","correctAnswer","buildAnswerText","distractors","generateDistractors","id","Date","now","type","questionSides","shuffleOptions","level","acceptedAnswers","generateAcceptedAnswers","answerSides","excludeIndex","nonMasteredDistractors","masteredDistractors","masteredSet","distractor","includes","primaryPool","length","fallbackPool","selectFromPool","pool","needed","selected","scores","map","text","similarity","calculateSimilarity","sort","a","b","Math","floor","i","randomDistractor","random","remaining","slice","text1","text2","words1","toLowerCase","split","words2","set1","set2","intersection","filter","x","union","size","parts","side","value","join","variations","toUpperCase","noPunctuation","replace","trimmed","trim","types","mix","mcProbability","shuffled","shuffleIntensity","j","SmartSpacedScheduler","name","description","schedule","missedCards","upcomingCards","config","positions","position","calculatePosition","mergeWithAntiClustering","queueSize","base","minSpacing","range","maxSpacing","difficultyFactor","difficultyWeight","attemptFactor","min","missCount","timeFactor","lastSeen","spacing","max","jitter","result","insertedPositions","consecutiveMissed","finalPosition","clusterLimit","cardToInsert","convertMissedToCard","splice","progressRatio","redistributeForProgress","missedCard","originalCards","originalCard","find","c","side_a","side_b","targetRatio","totalNeeded","newCardsNeeded","insertPosition","LeitnerBoxScheduler","boxes","groupByBox","boxLevel","interval","getBoxInterval","index","groups","Map","set","get","baseInterval","aggressivenessMultiplier","gentle","balanced","intensive","aggressiveness","round","CardSchedulerFactory","static","getScheduler","algorithm","scheduler","schedulers","Error","registerScheduler","key","getAvailableAlgorithms","Array","from","entries","initialSessionState","currentQuestion","questionIndex","roundCards","correctCards","incorrectCards","currentStreak","maxStreak","startTime","responseStartTime","responseTimes","hasOwn","hasOwnProperty","classNames","classes","arguments","arg","appendClass","parseValue","isArray","apply","toString","Object","prototype","call","newClass","module","exports","default","window","MultipleChoiceOptions","memo","onSelect","showFeedback","feedback","_feedback","disabled","resetKey","selectedOption","setSelectedOption","useState","useEffect","handleOptionClick","useCallback","option","handleKeyDown","e","target","tagName","isContentEditable","keyMap","optionIndex","preventDefault","addEventListener","removeEventListener","jsxs","className","styles","role","children","status","getOptionStatus","isSelected","cn","onClick","title","jsx","displayName","defaultOptions","caseSensitive","allowTypos","maxEditDistance","synonyms","TextMatcher","isMatch","userInput","normalizedInput","normalizeText","acceptedAnswer","normalizedAnswer","levenshteinDistance","matchesSynonym","normalized1","normalized2","distance","maxLength","preserveCase","normalized","normalizePinyinTones","pinyinMap","toned","RegExp","str1","str2","matrix","charAt","input","answer","answerSynonyms","inputSynonyms","values","generateCommonTypos","word","typos","chars","extractKeywords","words","stopWords","FreeTextInput","onSubmit","setUserInput","hasSubmitted","setHasSubmitted","handleSubmit","allAcceptedAnswers","isCorrect","handleOverride","handleKeyPress","document","activeElement","stopPropagation","shiftKey","onChange","onKeyDown","placeholder","autoComplete","autoFocus","FeedbackSection","explanation","isMastered","onShowCardDetails","tabIndex","QuestionCard","question","_card","onAnswer","style","width","QuestionFlow","currentCard","onAnswerSubmit","onQuestionComplete","handleAnswerSubmit","handleShowDetails","getAttribute","AnimatePresence","mode","motion","div","initial","opacity","animate","exit","transition","duration","CardDetailsModal","visible","onClose","handleEscape","body","overflow","getSideContent","label","content","frontContent","backContent","allSides","Fragment","scale","y","stiffness","damping","item","LearnContainer","deck","settings","strugglingCardIndices","initialStrugglingCards","onComplete","onExit","onOpenSettings","deckId","sessionState","updateSessionState","handleAnswer","nextQuestion","cardTracking","setSessionState","setMasteredCardIndices","setStrugglingCardIndices","newlyMasteredCards","setNewlyMasteredCards","updates","prev","resetSession","_answer","cardIdx","responseTime","newResponseTimes","newCorrectCards","newIncorrectCards","delete","prevMastered","newMastered","prevStruggling","newStruggling","newStreak","newMaxStreak","metrics","useMemo","totalCards","correctCount","incorrectCount","progressPercentage","timeElapsed","masteredCount","useSessionState","isLoading","setIsLoading","setShowFeedback","setFeedback","showCardDetailsModal","setShowCardDetailsModal","setCurrentCard","setCurrentQuestion","servedCount","setServedCount","generateRound","generatedQuestion","nextGeneratedQuestion","getMasteredCards","useCardMasteryStore","setQuestions","currentQuestionIndex","setCurrentQuestionIndex","correctMCCards","setCorrectMCCards","cardQuestionCounts","setCardQuestionCounts","newQuestions","addFollowUpQuestion","parentQuestionId","q","followUpQuestion","enhancedFollowUp","isFollowUp","shouldAddFollowUp","progressiveLearning","progressiveLearningSpacing","count","otherQuestionsSince","reverse","findIndex","lastCardQuestionIndex","currentQ","newCounts","reset","hasNext","markMCCorrect","useQuestionGenerator","setMissedCards","getValidAlgorithm","currentAlgorithm","setCurrentAlgorithm","schedulingAlgorithm","newAlgorithm","trackMissedCard","cardId","newMap","existing","updated","markCardCorrect","scheduleCards","missedArray","changeAlgorithm","resetScheduler","availableAlgorithms","useCardScheduler","isCardMastered","async","cardsToLearn","strugglingCards","cardsPerRound","strugglingIndices","availableCards","additionalCards","cardsNeeded","initializeSession","handleQuestionComplete","targetCount","totalAnswered","accuracyPercent","results","totalQuestions","correctAnswers","incorrectAnswers","accuracy","averageResponseTime","reduce","passedCards","masteredCards","handleShowCardDetails","handleSettingsClick","container","loading","emptyState","settingsButton","SharedModeHeader","deckName","metadata","deck_name","onBackClick","onSettingsClick","showSettings"],"mappings":"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","x_google_ignoreList":[4]}