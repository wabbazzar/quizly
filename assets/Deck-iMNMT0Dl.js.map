{"version":3,"file":"Deck-iMNMT0Dl.js","sources":["../../src/components/deck/DeckHeader.tsx","../../src/components/deck/ModeSelector.tsx","../../src/components/deck/CardManagement.tsx","../../src/pages/Deck.tsx"],"sourcesContent":["import { FC, memo } from 'react';\nimport { DeckHeaderProps } from './types';\nimport { PageHeader } from '@/components/common/PageHeader';\n\nexport const DeckHeader: FC<DeckHeaderProps> = memo(({ deck, onBackClick, onSettingsClick }) => {\n  // Add safety check for deck\n  if (!deck || !deck.content || !deck.metadata) {\n    return null;\n  }\n\n  const statsText = `${deck.content.length} cards${deck.metadata.difficulty ? ` • ${deck.metadata.difficulty.replace('_', ' ')}` : ''}${deck.metadata.tags && deck.metadata.tags.length > 0 ? ` • ${deck.metadata.tags.slice(0, 2).join(', ')}` : ''}`;\n\n  return (\n    <PageHeader\n      title={deck.metadata.deck_name}\n      subtitle={deck.metadata.deck_subtitle || deck.metadata.description || statsText}\n      onBackClick={onBackClick}\n      backLabel=\"Home\"\n      onSettingsClick={onSettingsClick}\n      showSettings={true}\n    />\n  );\n});\n\nDeckHeader.displayName = 'DeckHeader';\n","import { FC, memo } from 'react';\nimport { motion } from 'framer-motion';\nimport { ModeSelectorProps } from './types';\nimport styles from './ModeSelector.module.css';\n\nexport const ModeSelector: FC<ModeSelectorProps> = memo(({ modes, onModeClick }) => {\n  return (\n    <section className={styles.modesSection}>\n      <motion.div\n        className={styles.modesGrid}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        transition={{ duration: 0.3 }}\n      >\n        {modes.map(mode => (\n          <motion.div\n            key={mode.id}\n            className={`${styles.modeCard} ${styles[mode.color]}`}\n            whileHover={{ scale: 1.02, y: -2 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={() => onModeClick(mode)}\n          >\n            <div className={styles.modeIconWrapper}>\n              <mode.icon className={styles.modeIcon} size={32} />\n            </div>\n            <h3 className={styles.modeName}>{mode.label}</h3>\n            <p className={styles.modeDescription}>{mode.description}</p>\n            <div className={styles.modeAction}>\n              <span className={styles.startText}>Start →</span>\n            </div>\n          </motion.div>\n        ))}\n      </motion.div>\n    </section>\n  );\n});\n\nModeSelector.displayName = 'ModeSelector';\n","import { FC, memo, useState, useRef } from 'react';\nimport { motion } from 'framer-motion';\nimport { Card } from '@/types';\nimport { CardManagementProps } from './types';\nimport {\n  BookOpenIcon,\n  CheckCircleIcon,\n  RefreshIcon,\n  DragHandleIcon,\n  TrophyIcon,\n} from '@/components/icons/StatusIcons';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport styles from './CardManagement.module.css';\n\nexport const CardManagement: FC<CardManagementProps> = memo(\n  ({ deck, learningCards, masteredCards, onCardClick, onToggleMastered }) => {\n    const { showNotification } = useNotificationStore();\n    const { markCardMastered, unmarkCardMastered } = useCardMasteryStore();\n    const [draggedCard, setDraggedCard] = useState<number | null>(null);\n    const [dragOverSection, setDragOverSection] = useState<'learning' | 'mastered' | null>(null);\n    const dragCardRef = useRef<number | null>(null);\n\n    // Add safety check for deck\n    if (!deck || !deck.content || !deck.metadata) {\n      return null;\n    }\n\n    const handleDragStart = (cardIdx: number) => {\n      setDraggedCard(cardIdx);\n      dragCardRef.current = cardIdx;\n    };\n\n    const handleDragEnd = () => {\n      setDraggedCard(null);\n      dragCardRef.current = null;\n      setDragOverSection(null);\n    };\n\n    const handleDragOver = (section: 'learning' | 'mastered') => (e: React.DragEvent) => {\n      e.preventDefault();\n      setDragOverSection(section);\n    };\n\n    const handleDragLeave = () => {\n      setDragOverSection(null);\n    };\n\n    const handleDrop = (section: 'learning' | 'mastered') => (e: React.DragEvent) => {\n      e.preventDefault();\n      const draggedIdx = dragCardRef.current;\n\n      const deckId = deck.metadata.deck_name; // Use deck_name as ID\n      if (draggedIdx === null || !deckId) return;\n\n      const isMastered = masteredCards.some(card => card.idx === draggedIdx);\n\n      if (section === 'mastered' && !isMastered) {\n        markCardMastered(deckId, draggedIdx, deck.content.length);\n        showNotification({\n          message: 'Card marked as mastered!',\n          type: 'success',\n          duration: 2000,\n        });\n      } else if (section === 'learning' && isMastered) {\n        unmarkCardMastered(deckId, draggedIdx);\n        showNotification({\n          message: 'Card moved back to learning',\n          type: 'info',\n          duration: 2000,\n        });\n      }\n\n      setDragOverSection(null);\n      handleDragEnd();\n    };\n\n    // Check if device supports touch (mobile/tablet)\n    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\n    // Get side labels from deck metadata, fallback to Side A/Side B\n    const sideALabel = deck.metadata.side_labels?.side_a || 'Side A';\n    const sideBLabel = deck.metadata.side_labels?.side_b || 'Side B';\n\n    const renderCard = (card: Card, isMastered: boolean) => (\n      <motion.div\n        key={card.idx}\n        className={`${styles.cardItem} ${isMastered ? styles.masteredCard : ''} ${draggedCard === card.idx ? styles.dragging : ''}`}\n        draggable={!isTouchDevice} // Only enable dragging on non-touch devices\n        onDragStart={!isTouchDevice ? () => handleDragStart(card.idx) : undefined}\n        onDragEnd={!isTouchDevice ? handleDragEnd : undefined}\n        initial={{ opacity: 0, x: -20 }}\n        animate={{ opacity: draggedCard === card.idx ? 0.5 : 1, x: 0 }}\n        transition={{ duration: 0.3 }}\n        onClick={() => onCardClick(card)}\n        whileHover={{ backgroundColor: isMastered ? 'rgba(16, 185, 129, 0.15)' : '#F7F8FA' }}\n        layout\n      >\n        {!isTouchDevice && <DragHandleIcon className={styles.cardDragHandle} size={20} />}\n        <div className={styles.cardNumber}>{card.idx + 1}</div>\n        <div className={styles.cardContent}>\n          <div className={styles.cardSide}>\n            <span className={styles.sideLabel}>{sideALabel}:</span>\n            <span className={styles.sideText}>{card.side_a}</span>\n          </div>\n          <div className={styles.cardSide}>\n            <span className={styles.sideLabel}>{sideBLabel}:</span>\n            <span className={styles.sideText}>{card.side_b}</span>\n          </div>\n        </div>\n        <button\n          className={isMastered ? styles.unmasterButton : styles.masterButton}\n          onClick={e => {\n            e.stopPropagation();\n            onToggleMastered(card.idx);\n          }}\n          title={isMastered ? 'Move back to learning' : 'Mark as mastered'}\n        >\n          {isMastered ? <RefreshIcon size={16} /> : <CheckCircleIcon size={16} />}\n        </button>\n      </motion.div>\n    );\n\n    return (\n      <section className={styles.cardsSection}>\n        <div className={styles.sectionHeader}>\n          <h2 className={styles.sectionTitle}>Cards Management ({deck.content.length} total)</h2>\n          <div className={styles.cardActions}>\n            {'ontouchstart' in window || navigator.maxTouchPoints > 0 ? null : (\n              <span className={styles.dragHint}>Drag cards to categorize them</span>\n            )}\n          </div>\n        </div>\n\n        <div className={styles.cardsManagement}>\n          {/* Learning Cards Section */}\n          <div\n            className={`${styles.cardCategory} ${styles.learningSection} ${dragOverSection === 'learning' ? styles.dragOver : ''}`}\n            onDragOver={handleDragOver('learning')}\n            onDrop={handleDrop('learning')}\n            onDragLeave={handleDragLeave}\n          >\n            <h3 className={styles.categoryTitle}>\n              <BookOpenIcon size={20} className={styles.categoryIcon} />\n              Learning ({learningCards.length})\n            </h3>\n            <div className={styles.cardsList}>\n              {learningCards.length > 0 ? (\n                learningCards.map(card => renderCard(card, false))\n              ) : (\n                <div className={styles.emptyState}>\n                  <p>No cards in learning</p>\n                  <span>\n                    {'ontouchstart' in window || navigator.maxTouchPoints > 0\n                      ? 'Tap cards to categorize them'\n                      : 'Drag cards here to start learning'}\n                  </span>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Mastered Cards Section */}\n          <div\n            className={`${styles.cardCategory} ${styles.masteredSection} ${dragOverSection === 'mastered' ? styles.dragOver : ''}`}\n            onDragOver={handleDragOver('mastered')}\n            onDrop={handleDrop('mastered')}\n            onDragLeave={handleDragLeave}\n          >\n            <h3 className={styles.categoryTitle}>\n              <TrophyIcon size={20} className={styles.categoryIcon} />\n              Mastered ({masteredCards.length})\n            </h3>\n            <div className={styles.cardsList}>\n              {masteredCards.length > 0 ? (\n                masteredCards.map(card => renderCard(card, true))\n              ) : (\n                <div className={styles.emptyState}>\n                  <p>No mastered cards</p>\n                  <span>\n                    {'ontouchstart' in window || navigator.maxTouchPoints > 0\n                      ? 'Cards appear here when marked as mastered'\n                      : 'Cards auto-populate here during learn mode or drag to mark as mastered'}\n                  </span>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </section>\n    );\n  }\n);\n\nCardManagement.displayName = 'CardManagement';\n","import { FC, useEffect, useState, useMemo, useCallback } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { motion } from 'framer-motion';\nimport { useDeckStore } from '@/store/deckStore';\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { Card } from '@/types';\nimport { DeckHeader } from '@/components/deck/DeckHeader';\nimport { ModeSelector } from '@/components/deck/ModeSelector';\nimport { CardManagement } from '@/components/deck/CardManagement';\nimport { ModeCard } from '@/components/deck/types';\nimport UnifiedSettings from '@/components/modals/UnifiedSettings';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport { FlashcardsIcon, LearnIcon, MatchIcon, ReadIcon } from '@/components/icons/ModeIcons';\nimport styles from './Deck.module.css';\n\nconst Deck: FC = () => {\n  const { deckId } = useParams<{ deckId: string }>();\n  const navigate = useNavigate();\n  const { currentDeck, loadDeck, isLoading, error } = useDeckStore();\n  const { getMasteredCards, resetDeckMastery, mastery } = useCardMasteryStore();\n  const { showNotification } = useNotificationStore();\n  const { getSettingsForMode } = useSettingsStore();\n  const [selectedCard, setSelectedCard] = useState<Card | null>(null);\n  const [showCardModal, setShowCardModal] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n\n  useEffect(() => {\n    if (deckId) {\n      loadDeck(deckId);\n    }\n  }, [deckId, loadDeck]);\n\n  // Calculate mastered cards - safe to do at component level with proper guards\n  const masteredCardIndices = useMemo(() => {\n    return deckId ? getMasteredCards(deckId) : [];\n  }, [deckId, getMasteredCards, mastery]); // Added mastery to dependencies to trigger recalculation\n\n  const learningCards = useMemo(() => {\n    if (!currentDeck?.content) return [];\n    return currentDeck.content.filter(card => !masteredCardIndices.includes(card.idx));\n  }, [currentDeck, masteredCardIndices]);\n\n  const masteredCardsList = useMemo(() => {\n    if (!currentDeck?.content) return [];\n    return currentDeck.content.filter(card => masteredCardIndices.includes(card.idx));\n  }, [currentDeck, masteredCardIndices]);\n\n  const modes: ModeCard[] = useMemo(\n    () => [\n      {\n        id: 'flashcards',\n        label: 'Flashcards',\n        icon: FlashcardsIcon,\n        color: 'primary',\n        description: 'Classic flip cards for memorization',\n        route: `/flashcards/${deckId}`,\n      },\n      {\n        id: 'learn',\n        label: 'Learn',\n        icon: LearnIcon,\n        color: 'secondary',\n        description: 'Interactive questions with smart scheduling',\n        route: `/learn/${deckId}`,\n      },\n      {\n        id: 'match',\n        label: 'Match',\n        icon: MatchIcon,\n        color: 'purple',\n        description: 'Memory game to match terms and definitions',\n        route: `/match/${deckId}`,\n      },\n      {\n        id: 'read',\n        label: 'Read',\n        icon: ReadIcon,\n        color: 'orange',\n        description: 'Structured reading with line-by-line translation',\n        route: `/read/${deckId}`,\n      },\n    ],\n    [deckId]\n  );\n\n  const handleModeClick = useCallback(\n    (mode: ModeCard) => {\n      // Check if Read mode is available for this deck\n      if (mode.id === 'read') {\n        if (!currentDeck?.reading || Object.keys(currentDeck.reading.dialogues).length === 0) {\n          showNotification({\n            message: 'No reading content available for this deck',\n            type: 'info',\n            duration: 3000,\n          });\n          return;\n        }\n      }\n      navigate(mode.route);\n    },\n    [navigate, showNotification, currentDeck]\n  );\n\n  const handleCardClick = useCallback((card: Card) => {\n    setSelectedCard(card);\n    setShowCardModal(true);\n  }, []);\n\n  const closeCardModal = useCallback(() => {\n    setShowCardModal(false);\n    setTimeout(() => setSelectedCard(null), 300);\n  }, []);\n\n  const handleToggleMastered = useCallback(\n    (cardIdx: number) => {\n      if (!deckId || !currentDeck) return;\n\n      const { markCardMastered, unmarkCardMastered } = useCardMasteryStore.getState();\n      const isMastered = masteredCardIndices.includes(cardIdx);\n\n      if (isMastered) {\n        unmarkCardMastered(deckId, cardIdx);\n      } else {\n        // Always use the actual current deck's card count\n        markCardMastered(deckId, cardIdx, currentDeck.content.length);\n      }\n\n      showNotification({\n        message: isMastered ? 'Card moved back to learning' : 'Card marked as mastered!',\n        type: isMastered ? 'info' : 'success',\n        duration: 2000,\n      });\n    },\n    [deckId, masteredCardIndices, currentDeck, showNotification]\n  );\n\n  if (isLoading) {\n    return null; // Let PageLazyBoundary handle loading state\n  }\n\n  if (error || !currentDeck) {\n    return (\n      <div className={styles.errorContainer}>\n        <h2>Error Loading Deck</h2>\n        <p>{error || 'Deck not found'}</p>\n        <button onClick={() => navigate('/')} className={styles.backButton}>\n          Back to Home\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.deckPage}>\n      <DeckHeader\n        deck={currentDeck}\n        onBackClick={() => navigate('/')}\n        onSettingsClick={() => setShowSettings(true)}\n      />\n\n      <ModeSelector modes={modes} onModeClick={handleModeClick} />\n\n      <CardManagement\n        deck={currentDeck}\n        learningCards={learningCards}\n        masteredCards={masteredCardsList}\n        onCardClick={handleCardClick}\n        onToggleMastered={handleToggleMastered}\n      />\n\n      {/* Card Modal */}\n      {showCardModal && selectedCard && (\n        <motion.div\n          className={styles.modalOverlay}\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          onClick={closeCardModal}\n        >\n          <motion.div\n            className={styles.modalContent}\n            initial={{ scale: 0.9, opacity: 0 }}\n            animate={{ scale: 1, opacity: 1 }}\n            exit={{ scale: 0.9, opacity: 0 }}\n            onClick={e => e.stopPropagation()}\n          >\n            <button className={styles.closeButton} onClick={closeCardModal}>\n              ×\n            </button>\n            <h3 className={styles.modalTitle}>Card Details</h3>\n            <div className={styles.modalCard}>\n              <div className={styles.modalSide}>\n                <h4>\n                  {currentDeck?.metadata?.side_labels?.side_a\n                    ? currentDeck.metadata.side_labels.side_a.charAt(0).toUpperCase() +\n                      currentDeck.metadata.side_labels.side_a.slice(1)\n                    : 'Side A (Front)'}\n                </h4>\n                <p>{selectedCard.side_a}</p>\n              </div>\n              <div className={styles.modalSide}>\n                <h4>\n                  {currentDeck?.metadata?.side_labels?.side_b\n                    ? currentDeck.metadata.side_labels.side_b.charAt(0).toUpperCase() +\n                      currentDeck.metadata.side_labels.side_b.slice(1)\n                    : 'Side B (Back)'}\n                </h4>\n                <p>{selectedCard.side_b}</p>\n              </div>\n              {selectedCard.side_c && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_c\n                      ? currentDeck.metadata.side_labels.side_c.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_c.slice(1)\n                      : 'Side C (Extra)'}\n                  </h4>\n                  <p>{selectedCard.side_c}</p>\n                </div>\n              )}\n              {selectedCard.side_d && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_d\n                      ? currentDeck.metadata.side_labels.side_d.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_d.slice(1)\n                      : 'Side D'}\n                  </h4>\n                  <p>{selectedCard.side_d}</p>\n                </div>\n              )}\n              {selectedCard.side_e && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_e\n                      ? currentDeck.metadata.side_labels.side_e.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_e.slice(1)\n                      : 'Side E'}\n                  </h4>\n                  <p>{selectedCard.side_e}</p>\n                </div>\n              )}\n              {selectedCard.side_f && (\n                <div className={styles.modalSide}>\n                  <h4>\n                    {currentDeck?.metadata?.side_labels?.side_f\n                      ? currentDeck.metadata.side_labels.side_f.charAt(0).toUpperCase() +\n                        currentDeck.metadata.side_labels.side_f.slice(1)\n                      : 'Side F'}\n                  </h4>\n                  <p>{selectedCard.side_f}</p>\n                </div>\n              )}\n            </div>\n          </motion.div>\n        </motion.div>\n      )}\n\n      {/* Deck Settings Modal */}\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={() => setShowSettings(false)}\n        deck={currentDeck}\n        mode=\"deck\"\n        settings={\n          deckId\n            ? getSettingsForMode(deckId, 'deck')\n            : {\n                frontSides: [],\n                backSides: [],\n                cardsPerRound: 10,\n                enableTimer: false,\n                enableAudio: false,\n                randomize: false,\n                progressionMode: 'sequential' as const,\n              }\n        }\n        onUpdateSettings={() => {}}\n        onResetMastery={() => {\n          if (!deckId) return;\n          resetDeckMastery(deckId);\n          showNotification({\n            message: 'Mastered cards reset for this deck.',\n            type: 'info',\n            duration: 2000,\n          });\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Deck;\n"],"names":["DeckHeader","memo","deck","onBackClick","onSettingsClick","content","metadata","statsText","length","difficulty","replace","tags","slice","join","jsx","PageHeader","title","deck_name","subtitle","deck_subtitle","description","backLabel","showSettings","displayName","ModeSelector","modes","onModeClick","className","styles","modesSection","children","motion","div","modesGrid","initial","opacity","animate","transition","duration","map","mode","jsxs","modeCard","color","whileHover","scale","y","whileTap","onClick","modeIconWrapper","icon","modeIcon","size","modeName","label","modeDescription","modeAction","startText","id","CardManagement","learningCards","masteredCards","onCardClick","onToggleMastered","showNotification","useNotificationStore","markCardMastered","unmarkCardMastered","useCardMasteryStore","draggedCard","setDraggedCard","useState","dragOverSection","setDragOverSection","dragCardRef","useRef","handleDragEnd","current","handleDragOver","section","e","preventDefault","handleDragLeave","handleDrop","draggedIdx","deckId","isMastered","some","card","idx","message","type","isTouchDevice","window","navigator","maxTouchPoints","sideALabel","side_labels","side_a","sideBLabel","side_b","renderCard","draggable","onDragStart","handleDragStart","cardIdx","onDragEnd","x","backgroundColor","layout","DragHandleIcon","stopPropagation","RefreshIcon","CheckCircleIcon","onDragOver","onDrop","onDragLeave","BookOpenIcon","TrophyIcon","Deck","useParams","navigate","useNavigate","currentDeck","loadDeck","isLoading","error","useDeckStore","getMasteredCards","resetDeckMastery","mastery","getSettingsForMode","useSettingsStore","selectedCard","setSelectedCard","showCardModal","setShowCardModal","setShowSettings","useEffect","masteredCardIndices","useMemo","filter","includes","masteredCardsList","FlashcardsIcon","route","LearnIcon","MatchIcon","ReadIcon","handleModeClick","useCallback","reading","Object","keys","dialogues","handleCardClick","closeCardModal","setTimeout","handleToggleMastered","getState","exit","charAt","toUpperCase","side_c","side_d","side_e","side_f","UnifiedSettings","visible","onClose","settings","frontSides","backSides","cardsPerRound","enableTimer","enableAudio","randomize","progressionMode","onUpdateSettings","onResetMastery"],"mappings":"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"}