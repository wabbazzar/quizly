{"version":3,"file":"Match.module-DBXJJT7X.js","sources":["../../src/components/modes/match/types.ts","../../src/store/matchSessionStore.ts","../../src/store/matchBestTimesStore.ts","../../src/components/ui/ProgressBar.tsx","../../src/components/ui/LoadingScreen.tsx","../../src/components/modes/match/animations/matchAnimations.ts","../../src/components/modes/match/MatchCard.tsx","../../src/components/modes/match/MatchGrid.tsx","../../src/components/modes/match/MatchResults.tsx","../../src/utils/soundUtils.ts","../../src/components/modes/match/MatchContainer.tsx"],"sourcesContent":["import { Card, Deck } from '@/types';\n\n// Match-specific settings interface with required properties\nexport interface MatchSettings {\n  gridSize: { rows: number; cols: number };\n  matchType: 'two_way' | 'three_way' | 'custom';\n  cardSides: MatchCardSide[];\n  enableTimer: boolean;\n  includeMastered: boolean;\n  enableAudio: boolean;\n  timerSeconds: number; // 0 for count-up timer\n}\n\n// Configuration for card side groupings in match mode\nexport interface MatchCardSide {\n  sides: string[]; // e.g., ['side_a'] or ['side_b', 'side_c']\n  label: string; // Display label for this grouping\n  count: number; // Number of cards showing this side combination\n}\n\n// Individual match card in the grid\nexport interface MatchCard {\n  id: string;\n  cardIndex: number; // Original card index from deck\n  displaySides: string[]; // Which sides are shown (e.g., ['side_a'])\n  content: string; // Rendered content for display\n  groupId: string; // Cards with same groupId should match\n  isMatched: boolean;\n  isSelected: boolean;\n  position: { row: number; col: number };\n}\n\n// Complete match session state\nexport interface MatchSessionState {\n  deckId: string;\n  currentRound: number;\n  startTime: number;\n  pausedTime: number;\n  isPaused: boolean;\n  grid: MatchCard[];\n  selectedCards: string[]; // IDs of currently selected cards\n  matchedPairs: string[][]; // Groups of matched card IDs\n  missedCardIndices: number[]; // Original card indices that were missed\n  roundStartTime: number;\n  bestTime: number | null; // Best completion time in milliseconds\n  settings: MatchSettings;\n}\n\n// Match session store interface\nexport interface MatchSessionStore {\n  session: MatchSessionState | null;\n\n  // Session management\n  startSession: (deckId: string, settings: MatchSettings) => void;\n  pauseSession: () => void;\n  resumeSession: () => void;\n  endSession: () => void;\n\n  // Game actions\n  selectCard: (cardId: string) => void;\n  clearSelection: () => void;\n  processMatch: () => { isMatch: boolean; matchedCards?: string[] };\n\n  // Round management\n  startNewRound: (missedCards?: number[]) => void;\n  generateGrid: (cards: Card[], settings: MatchSettings) => MatchCard[];\n\n  // Persistence\n  saveSession: () => void;\n  loadSession: (deckId: string) => MatchSessionState | null;\n}\n\n// Match container component props\nexport interface MatchContainerProps {\n  deck: Deck;\n  onBackClick?: () => void; // Optional override for back navigation\n}\n\n// Match grid component props\nexport interface MatchGridProps {\n  cards: MatchCard[];\n  onCardSelect: (cardId: string) => void;\n  selectedCards: string[];\n  matchedCards: string[][];\n  gridSize: { rows: number; cols: number };\n  isAnimating: boolean;\n  animatingCards?: string[]; // Cards currently in animation state\n  isMobile?: boolean; // Mobile device detection for optimizations\n}\n\n// Individual match card component props\nexport interface MatchCardProps {\n  card: MatchCard;\n  isSelected: boolean;\n  isMatched: boolean;\n  isAnimating: boolean;\n  isCurrentlyAnimating?: boolean; // Whether this specific card is animating\n  onSelect: (cardId: string) => void;\n  position: { row: number; col: number };\n  isMobile?: boolean; // Mobile device detection for optimizations\n  prefersReducedMotion?: boolean; // Accessibility setting for reduced motion\n}\n\n// Match timer component props\nexport interface MatchTimerProps {\n  startTime: number;\n  pausedTime: number;\n  isPaused: boolean;\n  isComplete: boolean;\n  onPause?: () => void;\n  onResume?: () => void;\n}\n\n// Match results interface\nexport interface MatchResults {\n  deckId: string;\n  totalTime: number; // Time in milliseconds\n  bestTime: number | null; // Previous best time\n  isNewBest: boolean;\n  totalMatches: number;\n  missedCardIndices: number[];\n  roundNumber: number;\n  startTime: number;\n  endTime: number;\n}\n\n// Match completion modal props\nexport interface MatchResultsProps {\n  visible: boolean;\n  results: MatchResults | null;\n  onContinueWithMissed: () => void;\n  onStartNewRound: () => void;\n  onBackToDeck: () => void;\n  onClose: () => void;\n}\n\n// Default match settings\nexport const DEFAULT_MATCH_SETTINGS: MatchSettings = {\n  gridSize: { rows: 3, cols: 4 },\n  matchType: 'two_way',\n  cardSides: [\n    { sides: ['side_a'], label: 'Front', count: 6 },\n    { sides: ['side_b'], label: 'Back', count: 6 },\n  ],\n  enableTimer: true,\n  includeMastered: false,\n  enableAudio: false,\n  timerSeconds: 0, // Count-up timer\n};\n\n// Match validation utility types\nexport interface MatchValidationResult {\n  isValid: boolean;\n  matchedCards: string[];\n  matchType: 'two_way' | 'three_way' | 'custom';\n}\n\n// Card generation utility types\nexport interface CardGenerationOptions {\n  deck: Deck;\n  settings: MatchSettings;\n  excludeMastered: boolean;\n  masteredIndices: number[];\n}\n\n// Grid layout utility types\nexport interface GridPosition {\n  row: number;\n  col: number;\n  index: number;\n}\n\n// Animation state management\nexport interface MatchAnimationState {\n  isAnimating: boolean;\n  animationType: 'select' | 'match' | 'mismatch' | 'complete' | null;\n  animatingCards: string[];\n}\n\n// Sound feedback types\nexport interface MatchSoundEvents {\n  onSelect: () => void;\n  onMatch: () => void;\n  onMismatch: () => void;\n  onComplete: () => void;\n}\n\n// Error types for match mode\nexport interface MatchError {\n  type: 'GENERATION_ERROR' | 'VALIDATION_ERROR' | 'PERSISTENCE_ERROR' | 'GRID_ERROR';\n  message: string;\n  code?: string;\n  details?: any;\n}\n\n// Session restoration types\nexport interface SessionRestoration {\n  shouldRestore: boolean;\n  session: MatchSessionState | null;\n  isExpired: boolean;\n  errorMessage?: string;\n}","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport {\n  MatchSessionState,\n  MatchSessionStore,\n  MatchSettings,\n  MatchCard,\n  DEFAULT_MATCH_SETTINGS,\n  MatchValidationResult,\n} from '@/components/modes/match/types';\nimport { Card } from '@/types';\n\nconst SESSION_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n// Utility function to generate unique card IDs\nconst generateCardId = (cardIndex: number, sideGroup: string, position: number): string => {\n  return `${cardIndex}-${sideGroup}-${position}`;\n};\n\n// Utility function to generate group ID for matching\nconst generateGroupId = (cardIndex: number): string => {\n  return `group-${cardIndex}`;\n};\n\n// Utility function to shuffle array\nconst shuffleArray = <T>(array: T[]): T[] => {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n};\n\n// Generate match cards from deck cards\nconst generateMatchCards = (\n  cards: Card[],\n  settings: MatchSettings,\n  excludeMastered: boolean = false,\n  masteredIndices: number[] = []\n): MatchCard[] => {\n  const { gridSize, matchType } = settings;\n  const totalSlots = gridSize.rows * gridSize.cols;\n\n  // Filter cards if excluding mastered\n  let availableCards = excludeMastered\n    ? cards.filter((_, index) => !masteredIndices.includes(index))\n    : cards;\n\n  // Calculate how many source cards we need based on match type\n  let cardsPerGroup = 2; // Default for two_way\n  if (matchType === 'three_way') {\n    cardsPerGroup = 3;\n  }\n\n  const maxGroups = Math.floor(totalSlots / cardsPerGroup);\n\n  // Ensure we have enough cards\n  if (availableCards.length < maxGroups) {\n    // If not enough cards, use all available and potentially repeat some\n    const needed = maxGroups - availableCards.length;\n    const repeated = shuffleArray(availableCards).slice(0, needed);\n    availableCards = [...availableCards, ...repeated];\n  }\n\n  // Select cards for this round\n  const selectedCards = shuffleArray(availableCards).slice(0, maxGroups);\n  const matchCards: MatchCard[] = [];\n\n  // Generate match cards based on match type\n  selectedCards.forEach((card) => {\n    const groupId = generateGroupId(card.idx);\n\n    if (matchType === 'two_way') {\n      // Create two cards: one showing side_a, one showing side_b\n      // Card 1: Shows side_a (the question/term)\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_a', 0),\n        cardIndex: card.idx,\n        displaySides: ['side_a'],\n        content: (card.side_a || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 2: Shows side_b (the answer/definition)\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_b', 1),\n        cardIndex: card.idx,\n        displaySides: ['side_b'],\n        content: (card.side_b || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n    } else if (matchType === 'three_way') {\n      // Create three cards: showing side_a, side_b, and side_c\n      // Card 1: Shows side_a\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_a', 0),\n        cardIndex: card.idx,\n        displaySides: ['side_a'],\n        content: (card.side_a || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 2: Shows side_b\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_b', 1),\n        cardIndex: card.idx,\n        displaySides: ['side_b'],\n        content: (card.side_b || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n\n      // Card 3: Shows side_c\n      matchCards.push({\n        id: generateCardId(card.idx, 'side_c', 2),\n        cardIndex: card.idx,\n        displaySides: ['side_c'],\n        content: (card.side_c || '').trim(),\n        groupId,\n        isMatched: false,\n        isSelected: false,\n        position: { row: 0, col: 0 },\n      });\n    } else {\n      // Custom mode: use the cardSides configuration from settings\n      if (settings.cardSides && settings.cardSides.length > 0) {\n        settings.cardSides.forEach((cardSide, index) => {\n          const sideKey = cardSide.sides[0]; // e.g., 'side_a', 'side_b', 'side_c'\n          const sideContent = (card as any)[sideKey] || '';\n\n          matchCards.push({\n            id: generateCardId(card.idx, sideKey, index),\n            cardIndex: card.idx,\n            displaySides: [sideKey],\n            content: sideContent.trim(),\n            groupId,\n            isMatched: false,\n            isSelected: false,\n            position: { row: 0, col: 0 },\n          });\n        });\n      } else {\n        // Fallback to two-way if not properly configured\n        matchCards.push({\n          id: generateCardId(card.idx, 'side_a', 0),\n          cardIndex: card.idx,\n          displaySides: ['side_a'],\n          content: (card.side_a || '').trim(),\n          groupId,\n          isMatched: false,\n          isSelected: false,\n          position: { row: 0, col: 0 },\n        });\n\n        matchCards.push({\n          id: generateCardId(card.idx, 'side_b', 1),\n          cardIndex: card.idx,\n          displaySides: ['side_b'],\n          content: (card.side_b || '').trim(),\n          groupId,\n          isMatched: false,\n          isSelected: false,\n          position: { row: 0, col: 0 },\n        });\n      }\n    }\n  });\n\n  // Shuffle and place cards on grid\n  const shuffledCards = shuffleArray(matchCards);\n\n  // Assign grid positions\n  shuffledCards.forEach((card, index) => {\n    const row = Math.floor(index / gridSize.cols);\n    const col = index % gridSize.cols;\n    card.position = { row, col };\n  });\n\n  return shuffledCards.slice(0, totalSlots);\n};\n\n// Validate if selected cards form a match\nconst validateMatch = (\n  selectedCards: MatchCard[],\n  matchType: 'two_way' | 'three_way' | 'custom'\n): MatchValidationResult => {\n  if (selectedCards.length < 2) {\n    return { isValid: false, matchedCards: [], matchType };\n  }\n\n  // Check if all selected cards have the same group ID\n  const firstGroupId = selectedCards[0].groupId;\n  const allSameGroup = selectedCards.every(card => card.groupId === firstGroupId);\n\n  // Check for match type requirements\n  let isValidCount = false;\n  switch (matchType) {\n    case 'two_way':\n      isValidCount = selectedCards.length === 2;\n      break;\n    case 'three_way':\n      isValidCount = selectedCards.length === 3;\n      break;\n    case 'custom':\n      isValidCount = selectedCards.length >= 2;\n      break;\n  }\n\n  const isValid = allSameGroup && isValidCount;\n  const matchedCards = isValid ? selectedCards.map(card => card.id) : [];\n\n  return { isValid, matchedCards, matchType };\n};\n\nexport const useMatchSessionStore = create<MatchSessionStore>()(\n  persist(\n    (set, get) => ({\n      session: null,\n\n      startSession: (deckId: string, settings: MatchSettings = DEFAULT_MATCH_SETTINGS) => {\n        const startTime = Date.now();\n        const newSession: MatchSessionState = {\n          deckId,\n          currentRound: 1,\n          startTime,\n          pausedTime: 0,\n          isPaused: false,\n          grid: [],\n          selectedCards: [],\n          matchedPairs: [],\n          missedCardIndices: [],\n          roundStartTime: startTime,\n          bestTime: null,\n          settings,\n        };\n\n        set({ session: newSession });\n      },\n\n      pauseSession: () => {\n        const { session } = get();\n        if (session && !session.isPaused) {\n          set({\n            session: {\n              ...session,\n              isPaused: true,\n              pausedTime: Date.now(),\n            },\n          });\n        }\n      },\n\n      resumeSession: () => {\n        const { session } = get();\n        if (session && session.isPaused) {\n          const pauseDuration = Date.now() - session.pausedTime;\n          set({\n            session: {\n              ...session,\n              isPaused: false,\n              pausedTime: 0,\n              roundStartTime: session.roundStartTime + pauseDuration,\n            },\n          });\n        }\n      },\n\n      endSession: () => {\n        set({ session: null });\n      },\n\n      selectCard: (cardId: string) => {\n        const { session } = get();\n        if (!session || session.isPaused) return;\n\n        const card = session.grid.find(c => c.id === cardId);\n        if (!card || card.isMatched) return;\n\n        let newSelectedCards: string[];\n        let newGrid = [...session.grid];\n\n        if (session.selectedCards.includes(cardId)) {\n          // Deselect card\n          newSelectedCards = session.selectedCards.filter(id => id !== cardId);\n          newGrid = newGrid.map(c =>\n            c.id === cardId ? { ...c, isSelected: false } : c\n          );\n        } else {\n          // Select card\n          newSelectedCards = [...session.selectedCards, cardId];\n          newGrid = newGrid.map(c =>\n            c.id === cardId ? { ...c, isSelected: true } : c\n          );\n        }\n\n        set({\n          session: {\n            ...session,\n            selectedCards: newSelectedCards,\n            grid: newGrid,\n          },\n        });\n      },\n\n      clearSelection: () => {\n        const { session } = get();\n        if (!session) return;\n\n        const newGrid = session.grid.map(card => ({\n          ...card,\n          isSelected: false,\n        }));\n\n        set({\n          session: {\n            ...session,\n            selectedCards: [],\n            grid: newGrid,\n          },\n        });\n      },\n\n      processMatch: () => {\n        const { session } = get();\n        if (!session || session.selectedCards.length === 0) {\n          return { isMatch: false };\n        }\n\n        const selectedCardObjects = session.grid.filter(card =>\n          session.selectedCards.includes(card.id)\n        );\n\n        const validationResult = validateMatch(\n          selectedCardObjects,\n          session.settings.matchType\n        );\n\n        if (validationResult.isValid) {\n          // Mark cards as matched\n          const newGrid = session.grid.map(card =>\n            validationResult.matchedCards.includes(card.id)\n              ? { ...card, isMatched: true, isSelected: false }\n              : { ...card, isSelected: false }\n          );\n\n          const newMatchedPairs = [...session.matchedPairs, validationResult.matchedCards];\n\n          set({\n            session: {\n              ...session,\n              grid: newGrid,\n              selectedCards: [],\n              matchedPairs: newMatchedPairs,\n            },\n          });\n\n          return { isMatch: true, matchedCards: validationResult.matchedCards };\n        } else {\n          // Clear selection for mismatch\n          get().clearSelection();\n          return { isMatch: false };\n        }\n      },\n\n      startNewRound: (missedCards?: number[]) => {\n        const { session } = get();\n        if (!session) return;\n\n        set({\n          session: {\n            ...session,\n            currentRound: session.currentRound + 1,\n            roundStartTime: Date.now(),\n            grid: [],\n            selectedCards: [],\n            matchedPairs: [],\n            missedCardIndices: missedCards || [],\n          },\n        });\n      },\n\n      generateGrid: (cards: Card[], settings: MatchSettings) => {\n        const { session } = get();\n        if (!session) return [];\n\n        const newGrid = generateMatchCards(cards, settings);\n\n        set({\n          session: {\n            ...session,\n            grid: newGrid,\n          },\n        });\n\n        return newGrid;\n      },\n\n      saveSession: () => {\n        // Session is automatically saved via persist middleware\n      },\n\n      loadSession: (deckId: string) => {\n        const { session } = get();\n        if (session && session.deckId === deckId) {\n          // Check if session is expired\n          if (Date.now() - session.startTime > SESSION_EXPIRY_MS) {\n            set({ session: null });\n            return null;\n          }\n          return session;\n        }\n        return null;\n      },\n    }),\n    {\n      name: 'match-session-store',\n      // Custom storage to handle complex objects\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          try {\n            const { state } = JSON.parse(str);\n            return { state };\n          } catch (error) {\n            console.warn('Failed to parse match session storage:', error);\n            return null;\n          }\n        },\n        setItem: (name, value) => {\n          try {\n            const { state } = value;\n            localStorage.setItem(name, JSON.stringify({ state }));\n          } catch (error) {\n            console.warn('Failed to save match session storage:', error);\n          }\n        },\n        removeItem: name => localStorage.removeItem(name),\n      },\n      // Only persist essential session data\n      partialize: state => ({\n        session: state.session,\n      }),\n    }\n  )\n);\n\n// Utility functions for external use\nexport {\n  generateMatchCards,\n  validateMatch,\n  shuffleArray,\n  generateCardId,\n  generateGroupId,\n};","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport interface MatchBestTime {\n  deckId: string;\n  bestTimeMs: number;\n  achievedAt: Date;\n  gridSize: { rows: number; cols: number };\n  matchType: 'two_way' | 'three_way' | 'custom';\n  totalMatches: number;\n}\n\ninterface MatchBestTimesStore {\n  // Best times data by deck ID\n  bestTimes: Record<string, MatchBestTime>;\n\n  // Actions\n  updateBestTime: (\n    deckId: string,\n    timeMs: number,\n    gridSize: { rows: number; cols: number },\n    matchType: 'two_way' | 'three_way' | 'custom',\n    totalMatches: number\n  ) => boolean; // Returns true if new best time was set\n  getBestTime: (deckId: string) => MatchBestTime | null;\n  hasBestTime: (deckId: string) => boolean;\n  clearBestTime: (deckId: string) => void;\n  clearAllBestTimes: () => void;\n  getAllBestTimes: () => MatchBestTime[];\n  getDeckStats: (deckId: string) => {\n    bestTime: MatchBestTime | null;\n    formattedTime: string;\n    hasRecord: boolean;\n  };\n}\n\n// Utility function to format time in MM:SS format\nexport const formatMatchTime = (timeMs: number): string => {\n  const totalSeconds = Math.floor(timeMs / 1000);\n  const minutes = Math.floor(totalSeconds / 60);\n  const seconds = totalSeconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n};\n\nexport const useMatchBestTimesStore = create<MatchBestTimesStore>()(\n  persist(\n    (set, get) => ({\n      bestTimes: {},\n\n      updateBestTime: (\n        deckId: string,\n        timeMs: number,\n        gridSize: { rows: number; cols: number },\n        matchType: 'two_way' | 'three_way' | 'custom',\n        totalMatches: number\n      ) => {\n        const currentBest = get().bestTimes[deckId];\n        const isNewBest = !currentBest || timeMs < currentBest.bestTimeMs;\n\n        if (isNewBest) {\n          set(state => ({\n            bestTimes: {\n              ...state.bestTimes,\n              [deckId]: {\n                deckId,\n                bestTimeMs: timeMs,\n                achievedAt: new Date(),\n                gridSize: { ...gridSize },\n                matchType,\n                totalMatches,\n              },\n            },\n          }));\n          return true;\n        }\n\n        return false;\n      },\n\n      getBestTime: (deckId: string) => {\n        return get().bestTimes[deckId] || null;\n      },\n\n      hasBestTime: (deckId: string) => {\n        return deckId in get().bestTimes;\n      },\n\n      clearBestTime: (deckId: string) => {\n        set(state => {\n          const newBestTimes = { ...state.bestTimes };\n          delete newBestTimes[deckId];\n          return { bestTimes: newBestTimes };\n        });\n      },\n\n      clearAllBestTimes: () => {\n        set({ bestTimes: {} });\n      },\n\n      getAllBestTimes: () => {\n        return Object.values(get().bestTimes);\n      },\n\n      getDeckStats: (deckId: string) => {\n        const bestTime = get().bestTimes[deckId] || null;\n        return {\n          bestTime,\n          formattedTime: bestTime ? formatMatchTime(bestTime.bestTimeMs) : '--:--',\n          hasRecord: !!bestTime,\n        };\n      },\n    }),\n    {\n      name: 'match-best-times-store',\n      // Custom storage to handle Date objects\n      storage: {\n        getItem: name => {\n          const str = localStorage.getItem(name);\n          if (!str) return null;\n\n          const parsed = JSON.parse(str);\n          if (parsed.state && parsed.state.bestTimes) {\n            // Convert date strings back to Date objects\n            Object.keys(parsed.state.bestTimes).forEach(deckId => {\n              const bestTime = parsed.state.bestTimes[deckId];\n              if (bestTime.achievedAt) {\n                bestTime.achievedAt = new Date(bestTime.achievedAt);\n              }\n            });\n          }\n          return parsed;\n        },\n        setItem: (name, value) => {\n          localStorage.setItem(name, JSON.stringify(value));\n        },\n        removeItem: name => {\n          localStorage.removeItem(name);\n        },\n      },\n    }\n  )\n);","import { FC, memo } from 'react';\nimport { ProgressBarProps } from './types';\nimport styles from './ProgressBar.module.css';\n\nexport const ProgressBar: FC<ProgressBarProps> = memo(\n  ({\n    value,\n    max = 100,\n    variant = 'default',\n    size = 'medium',\n    showLabel = false,\n    animated = true,\n  }) => {\n    const percentage = Math.min(Math.max((value / max) * 100, 0), 100);\n\n    const containerClasses = [styles.container, styles[size]].filter(Boolean).join(' ');\n\n    const barClasses = [styles.bar, styles[variant], animated && styles.animated]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={containerClasses}>\n        <div\n          className={styles.track}\n          role=\"progressbar\"\n          aria-valuenow={value}\n          aria-valuemin={0}\n          aria-valuemax={max}\n        >\n          <div className={barClasses} style={{ width: `${percentage}%` }} />\n        </div>\n        {showLabel && <span className={styles.label}>{Math.round(percentage)}%</span>}\n      </div>\n    );\n  }\n);\n\nProgressBar.displayName = 'ProgressBar';\n","import { FC, memo } from 'react';\nimport { LoadingScreenProps } from './types';\nimport { Spinner } from './Spinner';\nimport styles from './LoadingScreen.module.css';\n\nexport const LoadingScreen: FC<LoadingScreenProps> = memo(\n  ({ message = 'Loading...', fullScreen = true }) => {\n    const containerClasses = [styles.container, fullScreen && styles.fullScreen]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={containerClasses} role=\"status\" aria-live=\"polite\">\n        <div className={styles.content}>\n          <Spinner size=\"large\" variant=\"primary\" />\n          <p className={styles.message}>{message}</p>\n        </div>\n      </div>\n    );\n  }\n);\n\nLoadingScreen.displayName = 'LoadingScreen';\n","import { Variants, Transition } from 'framer-motion';\n\n/**\n * Animation configurations for Match Mode components\n *\n * Provides smooth, 60 FPS animations optimized for mobile performance:\n * - Match success feedback with celebration effects\n * - Card removal animations for successful matches\n * - Grid state transitions and updates\n * - Mobile performance optimizations using GPU acceleration\n */\n\n// Common transition settings optimized for performance\nconst FAST_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 300,\n  damping: 30,\n  mass: 0.8,\n};\n\nconst SMOOTH_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 200,\n  damping: 25,\n  mass: 1,\n};\n\nconst CELEBRATION_TRANSITION: Transition = {\n  type: 'spring',\n  stiffness: 400,\n  damping: 20,\n  mass: 0.6,\n};\n\n/**\n * Card match success animation variants\n * Provides satisfying feedback when cards are successfully matched\n */\nexport const matchSuccessVariants: Variants = {\n  initial: {\n    scale: 1,\n    rotate: 0,\n    opacity: 1,\n    filter: 'brightness(1) saturate(1)',\n    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',\n  },\n  matching: {\n    scale: [1, 1.05, 1.1],\n    rotate: [0, -2, 2, 0],\n    filter: 'brightness(1.2) saturate(1.3)',\n    boxShadow: [\n      '0 2px 8px rgba(0, 0, 0, 0.1)',\n      '0 8px 25px rgba(74, 144, 226, 0.3)',\n      '0 12px 35px rgba(74, 144, 226, 0.4)',\n    ],\n    transition: {\n      duration: 0.4,\n      times: [0, 0.5, 1],\n      ease: 'easeOut',\n    },\n  },\n  matched: {\n    scale: 0.95,\n    opacity: 0.7,\n    filter: 'brightness(0.9) saturate(0.8)',\n    borderColor: 'var(--semantic-success)',\n    backgroundColor: 'rgba(16, 185, 129, 0.1)',\n    transition: SMOOTH_TRANSITION,\n  },\n  removing: {\n    scale: [0.95, 1.1, 0],\n    rotate: [0, 5, -5, 0],\n    opacity: [0.7, 1, 0],\n    filter: 'brightness(1.3) saturate(1.5)',\n    y: [0, -10, -20],\n    transition: {\n      duration: 0.6,\n      times: [0, 0.3, 1],\n      ease: [0.4, 0, 0.2, 1],\n    },\n  },\n};\n\n/**\n * Card mismatch feedback animation variants\n * Subtle shake animation for incorrect matches\n */\nexport const matchMismatchVariants: Variants = {\n  initial: {\n    x: 0,\n    scale: 1,\n    filter: 'brightness(1)',\n  },\n  mismatch: {\n    x: [-2, 2, -2, 2, 0],\n    scale: [1, 0.98, 1],\n    filter: ['brightness(1)', 'brightness(1.1)', 'brightness(1)'],\n    transition: {\n      duration: 0.5,\n      times: [0, 0.25, 0.5, 0.75, 1],\n      ease: 'easeInOut',\n    },\n  },\n};\n\n/**\n * Card selection animation variants\n * Visual feedback for card tap/click interactions\n */\nexport const cardSelectionVariants: Variants = {\n  unselected: {\n    scale: 1,\n    borderColor: 'var(--border-color)',\n    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',\n    filter: 'brightness(1)',\n    y: 0,\n    transition: FAST_TRANSITION,\n  },\n  selected: {\n    scale: 1.02,\n    borderColor: 'var(--primary-main)',\n    boxShadow: '0 6px 20px rgba(74, 144, 226, 0.25)',\n    filter: 'brightness(1.05)',\n    y: -2,\n    transition: FAST_TRANSITION,\n  },\n  hover: {\n    scale: 1.01,\n    y: -1,\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Grid layout animation variants\n * Smooth transitions when grid content changes\n */\nexport const gridLayoutVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.9,\n  },\n  animate: {\n    opacity: 1,\n    scale: 1,\n    transition: {\n      duration: 0.3,\n      staggerChildren: 0.05,\n      delayChildren: 0.1,\n    },\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.95,\n    transition: {\n      duration: 0.2,\n      staggerChildren: 0.03,\n      staggerDirection: -1,\n    },\n  },\n};\n\n/**\n * Individual card entry animation variants\n * Staggered entrance for grid cards\n */\nexport const cardEntryVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.8,\n    y: 20,\n    rotateY: -90,\n  },\n  animate: {\n    opacity: 1,\n    scale: 1,\n    y: 0,\n    rotateY: 0,\n    transition: SMOOTH_TRANSITION,\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.8,\n    y: -10,\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Match celebration animation variants\n * Particles and effects for successful matches\n */\nexport const celebrationVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0,\n    rotate: 0,\n  },\n  celebrate: {\n    opacity: [0, 1, 1, 0],\n    scale: [0, 1.2, 1.5, 0],\n    rotate: [0, 180, 360],\n    transition: {\n      duration: 1,\n      times: [0, 0.2, 0.8, 1],\n      ease: 'easeOut',\n    },\n  },\n};\n\n/**\n * Progress bar animation variants\n * Smooth progress updates with elastic feel\n */\nexport const progressVariants: Variants = {\n  initial: {\n    scaleX: 0,\n    originX: 0,\n  },\n  animate: {\n    scaleX: 1,\n    transition: {\n      ...CELEBRATION_TRANSITION,\n      duration: 0.8,\n    },\n  },\n};\n\n/**\n * Game completion animation variants\n * Final celebration when all matches are found\n */\nexport const gameCompleteVariants: Variants = {\n  initial: {\n    opacity: 0,\n    scale: 0.5,\n    y: 50,\n  },\n  animate: {\n    opacity: 1,\n    scale: [0.5, 1.1, 1],\n    y: 0,\n    transition: {\n      duration: 0.6,\n      times: [0, 0.6, 1],\n      ease: 'easeOut',\n    },\n  },\n  exit: {\n    opacity: 0,\n    scale: 0.9,\n    y: -20,\n    transition: FAST_TRANSITION,\n  },\n};\n\n/**\n * Pause overlay animation variants\n * Smooth fade for pause state\n */\nexport const pauseOverlayVariants: Variants = {\n  initial: {\n    opacity: 0,\n    backdropFilter: 'blur(0px)',\n  },\n  animate: {\n    opacity: 1,\n    backdropFilter: 'blur(8px)',\n    transition: {\n      duration: 0.3,\n      ease: 'easeOut',\n    },\n  },\n  exit: {\n    opacity: 0,\n    backdropFilter: 'blur(0px)',\n    transition: {\n      duration: 0.2,\n      ease: 'easeIn',\n    },\n  },\n};\n\n/**\n * Performance-optimized spring configuration\n * Reduces motion for lower-end devices\n */\nexport const getOptimizedTransition = (isLowPerformance = false): Transition => {\n  if (isLowPerformance) {\n    return {\n      type: 'tween',\n      duration: 0.2,\n      ease: 'easeOut',\n    };\n  }\n\n  return SMOOTH_TRANSITION;\n};\n\n/**\n * Utility function to create staggered animations\n */\nexport const createStaggeredAnimation = (\n  delay = 0.05,\n  duration = 0.3\n): Transition => ({\n  duration,\n  staggerChildren: delay,\n  delayChildren: delay,\n});\n\n/**\n * Mobile performance optimizations\n * Reduces complexity for touch devices\n */\nexport const getMobileOptimizedVariants = (\n  variants: Variants,\n  isMobile = false\n): Variants => {\n  if (!isMobile) return variants;\n\n  // Simplify animations for mobile\n  return Object.entries(variants).reduce((acc, [key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      const mobileValue = { ...value };\n\n      // Remove complex transformations\n      if ('filter' in mobileValue) delete mobileValue.filter;\n      if ('boxShadow' in mobileValue && Array.isArray(mobileValue.boxShadow)) {\n        mobileValue.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';\n      }\n\n      // Reduce scale changes\n      if ('scale' in mobileValue && Array.isArray(mobileValue.scale)) {\n        const scaleArray = mobileValue.scale as number[];\n        mobileValue.scale = [scaleArray[0], scaleArray[scaleArray.length - 1]];\n      }\n\n      acc[key] = mobileValue;\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {} as Variants);\n};\n\n/**\n * Reduced motion variants for accessibility\n */\nexport const getReducedMotionVariants = (variants: Variants): Variants => {\n  return Object.entries(variants).reduce((acc, [key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      const reducedValue = { ...value };\n\n      // Remove scale and rotation animations\n      if ('scale' in reducedValue) reducedValue.scale = 1;\n      if ('rotate' in reducedValue) reducedValue.rotate = 0;\n      if ('rotateY' in reducedValue) reducedValue.rotateY = 0;\n\n      // Keep only opacity and basic position changes\n      const allowedProps = ['opacity', 'x', 'y', 'backgroundColor', 'borderColor'];\n      Object.keys(reducedValue).forEach(prop => {\n        if (!allowedProps.includes(prop) && prop !== 'transition') {\n          delete reducedValue[prop as keyof typeof reducedValue];\n        }\n      });\n\n      // Simplify transitions\n      if (reducedValue.transition) {\n        reducedValue.transition = { duration: 0.1 };\n      }\n\n      acc[key] = reducedValue;\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {} as Variants);\n};\n\nexport default {\n  matchSuccessVariants,\n  matchMismatchVariants,\n  cardSelectionVariants,\n  gridLayoutVariants,\n  cardEntryVariants,\n  celebrationVariants,\n  progressVariants,\n  gameCompleteVariants,\n  pauseOverlayVariants,\n  getOptimizedTransition,\n  createStaggeredAnimation,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n};","import { FC, memo, useCallback } from 'react';\nimport { motion } from 'framer-motion';\nimport { MatchCardProps } from './types';\nimport {\n  cardSelectionVariants,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n} from './animations/matchAnimations';\nimport styles from './MatchCard.module.css';\n\nconst MatchCard: FC<MatchCardProps> = memo(({\n  card,\n  isSelected,\n  isMatched,\n  isAnimating,\n  isCurrentlyAnimating = false,\n  onSelect,\n  position,\n  isMobile = false,\n  prefersReducedMotion = false,\n}) => {\n  // Handle card selection with haptic feedback for mobile devices\n  const handleCardClick = useCallback(() => {\n    if (isMatched || isAnimating) return;\n\n    onSelect(card.id);\n  }, [card.id, isMatched, isAnimating, onSelect]);\n\n  // Handle keyboard interaction\n  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      handleCardClick();\n    }\n  }, [handleCardClick]);\n\n  // Get appropriate animation variants\n  const getCardVariants = () => {\n    let variants = cardSelectionVariants;\n\n    if (prefersReducedMotion) {\n      variants = getReducedMotionVariants(variants);\n    } else if (isMobile) {\n      variants = getMobileOptimizedVariants(variants, true);\n    }\n\n    return variants;\n  };\n\n  // Determine current animation state\n  const getAnimationState = () => {\n    if (isCurrentlyAnimating) {\n      return isMatched ? 'removing' : 'matching';\n    }\n    if (isMatched) {\n      return 'matched';\n    }\n    if (isSelected) {\n      return 'selected';\n    }\n    return 'unselected';\n  };\n\n  const cardVariants = getCardVariants();\n  const animationState = getAnimationState();\n\n  return (\n    <motion.div\n      className={`${styles.card} ${isSelected ? styles.selected : ''} ${isMatched ? styles.matched : ''} ${isCurrentlyAnimating ? styles.animating : ''}`}\n      style={{\n        gridRow: position.row + 1,\n        gridColumn: position.col + 1,\n      }}\n      onClick={handleCardClick}\n      onKeyDown={handleKeyDown}\n      role=\"button\"\n      tabIndex={isMatched ? -1 : 0}\n      aria-label={`Match card: ${card.content}`}\n      aria-pressed={isSelected}\n      aria-disabled={isMatched}\n      data-testid={`match-card-${card.id}`}\n      // Enhanced Framer Motion animations\n      variants={cardVariants}\n      initial=\"unselected\"\n      animate={animationState}\n      exit=\"exit\"\n      whileHover={!isMatched && !prefersReducedMotion ? 'hover' : undefined}\n      whileTap={!isMatched && !prefersReducedMotion ? { scale: 0.98 } : undefined}\n      layout\n      layoutId={card.id}\n    >\n      <div className={styles.content}>\n        {card.content}\n      </div>\n\n      {/* Selection indicator */}\n      {isSelected && (\n        <motion.div\n          className={styles.selectionIndicator}\n          initial={{ scale: 0, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          exit={{ scale: 0, opacity: 0 }}\n          transition={{ duration: 0.2 }}\n        />\n      )}\n\n      {/* Match indicator */}\n      {isMatched && (\n        <motion.div\n          className={styles.matchIndicator}\n          initial={{ scale: 0, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          transition={{ duration: 0.3, delay: 0.1 }}\n        >\n          ‚úì\n        </motion.div>\n      )}\n\n      {/* Touch target overlay for better mobile interaction */}\n      <div className={styles.touchTarget} />\n    </motion.div>\n  );\n});\n\nMatchCard.displayName = 'MatchCard';\n\nexport default MatchCard;","import { FC, memo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { MatchGridProps } from './types';\nimport MatchCard from './MatchCard';\nimport {\n  gridLayoutVariants,\n  getMobileOptimizedVariants,\n  getReducedMotionVariants,\n} from './animations/matchAnimations';\nimport styles from './MatchGrid.module.css';\n\nconst MatchGrid: FC<MatchGridProps> = memo(({\n  cards,\n  onCardSelect,\n  selectedCards,\n  matchedCards,\n  gridSize,\n  isAnimating,\n  animatingCards = [],\n  isMobile = false,\n}) => {\n  // Flatten matched cards array for easier lookup\n  const matchedCardIds = new Set(matchedCards.flat());\n\n  // Check for reduced motion preference\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n  // Get appropriate animation variants\n  let gridVariants = gridLayoutVariants;\n  if (prefersReducedMotion) {\n    gridVariants = getReducedMotionVariants(gridLayoutVariants);\n  } else if (isMobile) {\n    gridVariants = getMobileOptimizedVariants(gridLayoutVariants, true);\n  }\n\n  return (\n    <motion.div\n      className={styles.grid}\n      style={{\n        gridTemplateRows: `repeat(${gridSize.rows}, 1fr)`,\n        gridTemplateColumns: `repeat(${gridSize.cols}, 1fr)`,\n      }}\n      variants={gridVariants}\n      initial=\"initial\"\n      animate=\"animate\"\n      exit=\"exit\"\n      role=\"grid\"\n      aria-label=\"Match game grid\"\n      data-testid=\"match-grid\"\n    >\n      <AnimatePresence mode=\"popLayout\">\n        {cards.map((card) => (\n          <MatchCard\n            key={card.id}\n            card={card}\n            isSelected={selectedCards.includes(card.id)}\n            isMatched={matchedCardIds.has(card.id)}\n            isAnimating={isAnimating}\n            isCurrentlyAnimating={animatingCards.includes(card.id)}\n            onSelect={onCardSelect}\n            position={card.position}\n            isMobile={isMobile}\n            prefersReducedMotion={prefersReducedMotion}\n          />\n        ))}\n      </AnimatePresence>\n    </motion.div>\n  );\n});\n\nMatchGrid.displayName = 'MatchGrid';\n\nexport default MatchGrid;","import { FC, memo, useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { motion } from 'framer-motion';\nimport { MatchResultsProps } from './types';\nimport { useMatchBestTimesStore, formatMatchTime } from '@/store/matchBestTimesStore';\nimport styles from './MatchResults.module.css';\n\nconst MatchResults: FC<MatchResultsProps> = memo(({\n  visible,\n  results,\n  onContinueWithMissed,\n  onStartNewRound,\n  onBackToDeck\n}) => {\n  const navigate = useNavigate();\n  const { updateBestTime, getBestTime } = useMatchBestTimesStore();\n  const [isNewBest, setIsNewBest] = useState(false);\n  const [previousBest, setPreviousBest] = useState<string | null>(null);\n\n  // Update best time and check if it's a new record\n  useEffect(() => {\n    if (!results || !visible) return;\n\n    const existingBest = getBestTime(results.deckId);\n    const wasNewBest = updateBestTime(\n      results.deckId,\n      results.totalTime,\n      { rows: 3, cols: 4 }, // Default grid size\n      'two_way', // Default match type\n      results.totalMatches\n    );\n\n    setIsNewBest(wasNewBest);\n    setPreviousBest(existingBest ? formatMatchTime(existingBest.bestTimeMs) : null);\n  }, [results, visible, updateBestTime, getBestTime]);\n\n  // Keyboard shortcuts: 1 = Play Again, 2 = Back to Deck, 3 = Home\n  useEffect(() => {\n    if (!visible) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if typing in an input/textarea\n      const target = e.target as HTMLElement | null;\n      if (\n        target &&\n        (target.tagName === 'INPUT' ||\n          target.tagName === 'TEXTAREA' ||\n          (target as any).isContentEditable)\n      ) {\n        return;\n      }\n\n      if (e.key === '1') {\n        e.preventDefault();\n        if (results?.missedCardIndices && results.missedCardIndices.length > 0) {\n          onContinueWithMissed();\n        } else {\n          onStartNewRound();\n        }\n      } else if (e.key === '2') {\n        e.preventDefault();\n        onBackToDeck();\n      } else if (e.key === '3') {\n        e.preventDefault();\n        navigate('/');\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [visible, results, onContinueWithMissed, onStartNewRound, onBackToDeck, navigate]);\n\n  if (!visible || !results) return null;\n\n  const getPerformanceMessage = () => {\n    const averageTimePerMatch = results.totalTime / results.totalMatches;\n\n    if (isNewBest) {\n      return { message: 'New Best Time!', emoji: 'üèÜ', color: 'excellent' };\n    } else if (averageTimePerMatch < 3000) { // Less than 3 seconds per match\n      return { message: 'Lightning Fast!', emoji: '‚ö°', color: 'excellent' };\n    } else if (averageTimePerMatch < 5000) {\n      return { message: 'Great Speed!', emoji: 'üåü', color: 'great' };\n    } else if (averageTimePerMatch < 8000) {\n      return { message: 'Good Work!', emoji: 'üëç', color: 'good' };\n    } else {\n      return { message: 'Complete!', emoji: 'üéâ', color: 'fair' };\n    }\n  };\n\n  const performance = getPerformanceMessage();\n  const currentTime = formatMatchTime(results.totalTime);\n  const hasMissedCards = results.missedCardIndices && results.missedCardIndices.length > 0;\n\n  return (\n    <motion.div\n      className={styles.sessionComplete}\n      initial={{ opacity: 0, scale: 0.9 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n      data-testid=\"match-results\"\n    >\n      <div className={styles.container}>\n        {/* Header */}\n        <header className={styles.header}>\n          <motion.div\n            className={styles.emoji}\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            transition={{ delay: 0.2, type: 'spring', stiffness: 200 }}\n          >\n            {performance.emoji}\n          </motion.div>\n          <h1 className={`${styles.title} ${styles[performance.color]}`}>\n            {performance.message}\n          </h1>\n          <p className={styles.subtitle}>\n            You completed Round {results.roundNumber} of matching!\n          </p>\n        </header>\n\n        {/* Results Summary */}\n        <div className={styles.resultsGrid}>\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.3 }}\n          >\n            <div className={styles.resultValue}>{currentTime}</div>\n            <div className={styles.resultLabel}>Time</div>\n          </motion.div>\n\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.4 }}\n          >\n            <div className={styles.resultValue}>{results.totalMatches}</div>\n            <div className={styles.resultLabel}>Matches</div>\n          </motion.div>\n\n          <motion.div\n            className={styles.resultCard}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.5 }}\n          >\n            <div className={styles.resultValue}>{results.roundNumber}</div>\n            <div className={styles.resultLabel}>Round</div>\n          </motion.div>\n\n          {previousBest && (\n            <motion.div\n              className={styles.resultCard}\n              initial={{ y: 20, opacity: 0 }}\n              animate={{ y: 0, opacity: 1 }}\n              transition={{ delay: 0.6 }}\n            >\n              <div className={styles.resultValue}>\n                {isNewBest ? previousBest : formatMatchTime(getBestTime(results.deckId)?.bestTimeMs || 0)}\n              </div>\n              <div className={styles.resultLabel}>\n                {isNewBest ? 'Previous Best' : 'Your Best'}\n              </div>\n            </motion.div>\n          )}\n        </div>\n\n        {/* Best Time Achievement */}\n        {isNewBest && previousBest && (\n          <motion.div\n            className={styles.achievementSection}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.7 }}\n          >\n            <div className={styles.achievementItem}>\n              <span className={`${styles.achievementIcon} ${styles.newBest}`}>üèÜ</span>\n              <span className={styles.achievementText}>\n                New personal best! You beat your previous time by{' '}\n                <strong>{formatMatchTime(getBestTime(results.deckId)?.bestTimeMs! - results.totalTime)}</strong>\n              </span>\n            </div>\n          </motion.div>\n        )}\n\n        {/* Missed Cards Info */}\n        {hasMissedCards && (\n          <motion.div\n            className={styles.missedSection}\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.8 }}\n          >\n            <div className={styles.missedItem}>\n              <span className={`${styles.missedIcon} ${styles.review}`}>üìö</span>\n              <span className={styles.missedText}>\n                <strong>{results.missedCardIndices.length}</strong> cards need more practice\n              </span>\n            </div>\n          </motion.div>\n        )}\n\n        {/* Action Buttons */}\n        <motion.div\n          className={styles.actions}\n          initial={{ y: 20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.9 }}\n        >\n          {hasMissedCards ? (\n            <>\n              <button\n                className={`${styles.actionButton} ${styles.primary}`}\n                onClick={onContinueWithMissed}\n                data-testid=\"practice-missed-button\"\n              >\n                Practice Missed Cards\n              </button>\n              <button\n                className={`${styles.actionButton} ${styles.secondary}`}\n                onClick={onStartNewRound}\n                data-testid=\"new-round-button\"\n              >\n                New Full Round\n              </button>\n            </>\n          ) : (\n            <button\n              className={`${styles.actionButton} ${styles.primary}`}\n              onClick={onStartNewRound}\n              data-testid=\"play-again-button\"\n            >\n              Play Again\n            </button>\n          )}\n          <button\n            className={`${styles.actionButton} ${styles.secondary}`}\n            onClick={onBackToDeck}\n            data-testid=\"back-button\"\n          >\n            Back to Deck\n          </button>\n          <button\n            className={`${styles.actionButton} ${styles.tertiary}`}\n            onClick={() => navigate('/')}\n            data-testid=\"home-button\"\n          >\n            Home\n          </button>\n        </motion.div>\n\n        {/* Speed tip for slower times */}\n        {results.totalTime / results.totalMatches > 8000 && (\n          <motion.p\n            className={styles.motivationalMessage}\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 1 }}\n          >\n            Tip: Try to improve your speed with each round. The more you practice, the faster you'll get!\n          </motion.p>\n        )}\n      </div>\n    </motion.div>\n  );\n});\n\nMatchResults.displayName = 'MatchResults';\n\nexport default MatchResults;","/**\n * Sound utilities for game feedback and audio interactions\n *\n * Provides:\n * - Match success and failure sound feedback\n * - Volume control and audio settings integration\n * - Web Audio API optimizations for performance\n * - Cross-browser compatibility and fallbacks\n * - Audio pool management for simultaneous sounds\n */\n\n// Sound effect types\nexport type SoundEffect =\n  | 'match_success'\n  | 'match_failure'\n  | 'card_select'\n  | 'card_flip'\n  | 'game_complete'\n  | 'timer_tick'\n  | 'button_click'\n  | 'notification';\n\n// Audio settings interface\nexport interface AudioSettings {\n  enabled: boolean;\n  volume: number; // 0.0 to 1.0\n  soundEffects: boolean;\n  backgroundMusic: boolean;\n}\n\n// Sound configuration\ninterface SoundConfig {\n  frequency?: number;\n  duration: number;\n  type: OscillatorType;\n  volume: number;\n  envelope?: {\n    attack: number;\n    decay: number;\n    sustain: number;\n    release: number;\n  };\n}\n\n// Pre-defined sound configurations\nconst SOUND_CONFIGS: Record<SoundEffect, SoundConfig> = {\n  match_success: {\n    frequency: 523.25, // C5\n    duration: 0.3,\n    type: 'sine',\n    volume: 0.6,\n    envelope: {\n      attack: 0.01,\n      decay: 0.1,\n      sustain: 0.3,\n      release: 0.2,\n    },\n  },\n  match_failure: {\n    frequency: 146.83, // D3\n    duration: 0.2,\n    type: 'sawtooth',\n    volume: 0.4,\n    envelope: {\n      attack: 0.01,\n      decay: 0.05,\n      sustain: 0.1,\n      release: 0.05,\n    },\n  },\n  card_select: {\n    frequency: 659.25, // E5\n    duration: 0.1,\n    type: 'triangle',\n    volume: 0.3,\n    envelope: {\n      attack: 0.01,\n      decay: 0.02,\n      sustain: 0.1,\n      release: 0.05,\n    },\n  },\n  card_flip: {\n    frequency: 440, // A4\n    duration: 0.15,\n    type: 'square',\n    volume: 0.25,\n    envelope: {\n      attack: 0.01,\n      decay: 0.05,\n      sustain: 0.05,\n      release: 0.05,\n    },\n  },\n  game_complete: {\n    frequency: 783.99, // G5\n    duration: 0.8,\n    type: 'sine',\n    volume: 0.8,\n    envelope: {\n      attack: 0.1,\n      decay: 0.2,\n      sustain: 0.4,\n      release: 0.3,\n    },\n  },\n  timer_tick: {\n    frequency: 1000, // High tick\n    duration: 0.05,\n    type: 'square',\n    volume: 0.2,\n    envelope: {\n      attack: 0.001,\n      decay: 0.01,\n      sustain: 0.01,\n      release: 0.02,\n    },\n  },\n  button_click: {\n    frequency: 400,\n    duration: 0.1,\n    type: 'triangle',\n    volume: 0.3,\n    envelope: {\n      attack: 0.01,\n      decay: 0.02,\n      sustain: 0.02,\n      release: 0.05,\n    },\n  },\n  notification: {\n    frequency: 800,\n    duration: 0.2,\n    type: 'sine',\n    volume: 0.5,\n    envelope: {\n      attack: 0.05,\n      decay: 0.1,\n      sustain: 0.05,\n      release: 0.1,\n    },\n  },\n};\n\n// Audio context and pool management\nclass SoundManager {\n  private audioContext: AudioContext | null = null;\n  private audioPool: Map<SoundEffect, AudioBuffer[]> = new Map();\n  private settings: AudioSettings = {\n    enabled: true,\n    volume: 0.7,\n    soundEffects: true,\n    backgroundMusic: false,\n  };\n\n  constructor() {\n    this.initializeAudioContext();\n  }\n\n  private async initializeAudioContext(): Promise<void> {\n    try {\n      // Create audio context with user gesture handling\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n\n      // Handle browser autoplay policies\n      if (this.audioContext.state === 'suspended') {\n        document.addEventListener('click', this.resumeAudioContext.bind(this), { once: true });\n        document.addEventListener('touchstart', this.resumeAudioContext.bind(this), { once: true });\n      }\n    } catch (error) {\n      console.warn('Audio context initialization failed:', error);\n      this.audioContext = null;\n    }\n  }\n\n  private async resumeAudioContext(): Promise<void> {\n    if (this.audioContext && this.audioContext.state === 'suspended') {\n      try {\n        await this.audioContext.resume();\n        console.log('Audio context resumed');\n      } catch (error) {\n        console.warn('Failed to resume audio context:', error);\n      }\n    }\n  }\n\n  /**\n   * Update audio settings\n   */\n  updateSettings(newSettings: Partial<AudioSettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n  }\n\n  /**\n   * Get current audio settings\n   */\n  getSettings(): AudioSettings {\n    return { ...this.settings };\n  }\n\n  /**\n   * Play a sound effect using Web Audio API\n   */\n  async playSound(soundEffect: SoundEffect, volumeMultiplier = 1): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects || !this.audioContext) {\n      return;\n    }\n\n    try {\n      const config = SOUND_CONFIGS[soundEffect];\n      const volume = Math.min(1, this.settings.volume * volumeMultiplier * config.volume);\n\n      await this.synthesizeAndPlay(config, volume);\n    } catch (error) {\n      console.warn(`Failed to play sound ${soundEffect}:`, error);\n    }\n  }\n\n  /**\n   * Synthesize and play sound using Web Audio API\n   */\n  private async synthesizeAndPlay(config: SoundConfig, volume: number): Promise<void> {\n    if (!this.audioContext) return;\n\n    const { frequency = 440, duration, type, envelope } = config;\n    const ctx = this.audioContext;\n    const currentTime = ctx.currentTime;\n\n    // Create oscillator and gain nodes\n    const oscillator = ctx.createOscillator();\n    const gainNode = ctx.createGain();\n\n    // Configure oscillator\n    oscillator.type = type;\n    oscillator.frequency.setValueAtTime(frequency, currentTime);\n\n    // Configure envelope (ADSR)\n    if (envelope) {\n      const { attack, decay, sustain, release } = envelope;\n      const sustainLevel = volume * sustain;\n      const attackTime = currentTime + attack;\n      const decayTime = attackTime + decay;\n      const releaseTime = currentTime + duration - release;\n\n      gainNode.gain.setValueAtTime(0, currentTime);\n      gainNode.gain.linearRampToValueAtTime(volume, attackTime);\n      gainNode.gain.linearRampToValueAtTime(sustainLevel, decayTime);\n      gainNode.gain.setValueAtTime(sustainLevel, releaseTime);\n      gainNode.gain.linearRampToValueAtTime(0, currentTime + duration);\n    } else {\n      // Simple volume envelope\n      gainNode.gain.setValueAtTime(volume, currentTime);\n      gainNode.gain.linearRampToValueAtTime(0, currentTime + duration);\n    }\n\n    // Connect audio graph\n    oscillator.connect(gainNode);\n    gainNode.connect(ctx.destination);\n\n    // Start and stop oscillator\n    oscillator.start(currentTime);\n    oscillator.stop(currentTime + duration);\n\n    // Clean up\n    oscillator.addEventListener('ended', () => {\n      oscillator.disconnect();\n      gainNode.disconnect();\n    });\n  }\n\n  /**\n   * Play match success sound with celebration effect\n   */\n  async playMatchSuccess(intensity = 1): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play ascending chord for celebration\n      const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5\n      const delays = [0, 0.1, 0.2];\n\n      for (let i = 0; i < frequencies.length; i++) {\n        setTimeout(() => {\n          this.synthesizeAndPlay({\n            frequency: frequencies[i],\n            duration: 0.4,\n            type: 'sine',\n            volume: 0.6 * intensity,\n            envelope: {\n              attack: 0.02,\n              decay: 0.1,\n              sustain: 0.4,\n              release: 0.3,\n            },\n          }, this.settings.volume);\n        }, delays[i] * 1000);\n      }\n    } catch (error) {\n      console.warn('Failed to play match success sound:', error);\n    }\n  }\n\n  /**\n   * Play match failure sound with disappointment effect\n   */\n  async playMatchFailure(): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play descending tone for failure\n      await this.synthesizeAndPlay({\n        frequency: 220, // A3\n        duration: 0.3,\n        type: 'sawtooth',\n        volume: 0.4,\n        envelope: {\n          attack: 0.01,\n          decay: 0.1,\n          sustain: 0.1,\n          release: 0.2,\n        },\n      }, this.settings.volume);\n    } catch (error) {\n      console.warn('Failed to play match failure sound:', error);\n    }\n  }\n\n  /**\n   * Play game completion sound with fanfare\n   */\n  async playGameComplete(): Promise<void> {\n    if (!this.settings.enabled || !this.settings.soundEffects) return;\n\n    try {\n      // Play victory fanfare\n      const melody = [\n        { freq: 523.25, delay: 0 },    // C5\n        { freq: 659.25, delay: 0.2 },  // E5\n        { freq: 783.99, delay: 0.4 },  // G5\n        { freq: 1046.5, delay: 0.6 },  // C6\n      ];\n\n      melody.forEach(({ freq, delay }) => {\n        setTimeout(() => {\n          this.synthesizeAndPlay({\n            frequency: freq,\n            duration: 0.5,\n            type: 'sine',\n            volume: 0.8,\n            envelope: {\n              attack: 0.05,\n              decay: 0.2,\n              sustain: 0.5,\n              release: 0.3,\n            },\n          }, this.settings.volume);\n        }, delay * 1000);\n      });\n    } catch (error) {\n      console.warn('Failed to play game complete sound:', error);\n    }\n  }\n\n  /**\n   * Enable haptic feedback for supported devices\n   */\n  vibrate(pattern: number | number[] = 50): void {\n    if ('vibrate' in navigator && this.settings.enabled) {\n      try {\n        navigator.vibrate(pattern);\n      } catch (error) {\n        console.warn('Haptic feedback failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Preload audio resources (if using audio files in the future)\n   */\n  async preload(): Promise<void> {\n    // Reserved for future audio file loading\n    console.log('Audio system initialized');\n  }\n\n  /**\n   * Cleanup audio resources\n   */\n  cleanup(): void {\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    this.audioPool.clear();\n  }\n}\n\n// Singleton instance\nconst soundManager = new SoundManager();\n\n// Export convenience functions\nexport const playSound = (effect: SoundEffect, volume = 1) =>\n  soundManager.playSound(effect, volume);\n\nexport const playMatchSuccess = (intensity = 1) =>\n  soundManager.playMatchSuccess(intensity);\n\nexport const playMatchFailure = () =>\n  soundManager.playMatchFailure();\n\nexport const playGameComplete = () =>\n  soundManager.playGameComplete();\n\nexport const updateAudioSettings = (settings: Partial<AudioSettings>) =>\n  soundManager.updateSettings(settings);\n\nexport const getAudioSettings = () =>\n  soundManager.getSettings();\n\nexport const vibrate = (pattern: number | number[] = 50) =>\n  soundManager.vibrate(pattern);\n\nexport const preloadAudio = () =>\n  soundManager.preload();\n\nexport const cleanupAudio = () =>\n  soundManager.cleanup();\n\n// Initialize audio system\nif (typeof window !== 'undefined') {\n  // Auto-initialize when imported in browser environment\n  soundManager.preload();\n}\n\nexport default soundManager;","import { FC, memo, useEffect, useState, useCallback, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { motion, AnimatePresence } from 'framer-motion';\n// import { useDeckStore } from '@/store/deckStore'; // Will be used in later phases\nimport { useCardMasteryStore } from '@/store/cardMasteryStore';\nimport { useMatchSessionStore } from '@/store/matchSessionStore';\nimport { useMatchBestTimesStore } from '@/store/matchBestTimesStore';\nimport { useNotificationStore } from '@/store/notificationStore';\nimport { SharedModeHeader } from '@/components/common/SharedModeHeader';\nimport { LoadingScreen } from '@/components/ui';\nimport { UnifiedSettings } from '@/components/modals/UnifiedSettings';\nimport MatchGrid from './MatchGrid';\n// Timer disabled for now\n// import MatchTimer from './MatchTimer';\nimport MatchResults from './MatchResults';\n// import useMatchLogic from './hooks/useMatchLogic'; // Will be used in later phases\nimport {\n  MatchContainerProps,\n  DEFAULT_MATCH_SETTINGS,\n  MatchResults as MatchResultsData,\n  MatchSettings,\n} from './types';\nimport {\n  pauseOverlayVariants,\n} from './animations/matchAnimations';\nimport {\n  playMatchSuccess,\n  playMatchFailure,\n  playGameComplete,\n  playSound,\n  vibrate,\n  updateAudioSettings,\n} from '@/utils/soundUtils';\nimport styles from './MatchContainer.module.css';\n\nconst MatchContainer: FC<MatchContainerProps> = memo(({ deck, onBackClick }) => {\n  const navigate = useNavigate();\n  const { getMasteredCards } = useCardMasteryStore();\n  const { updateBestTime } = useMatchBestTimesStore();\n  const { showNotification } = useNotificationStore();\n  const {\n    session,\n    startSession,\n    pauseSession,\n    resumeSession,\n    selectCard,\n    clearSelection,\n    processMatch,\n    generateGrid,\n    loadSession,\n    startNewRound,\n  } = useMatchSessionStore();\n\n  // Match logic hook (will be used in later phases)\n  // const { checkMatch, validateCardSelection } = useMatchLogic();\n\n  // Local state\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [showResults, setShowResults] = useState(false);\n  const [results, setResults] = useState<MatchResultsData | null>(null);\n  const [showSettings, setShowSettings] = useState(false);\n  const [animatingCards, setAnimatingCards] = useState<string[]>([]);\n  const [gameCompleted, setGameCompleted] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  // Audio settings (sync with session settings)\n  const isAudioEnabled = session?.settings.enableAudio ?? false;\n\n  // Initialize or restore session\n  useEffect(() => {\n    if (!deck || isInitialized) return;\n\n    const existingSession = loadSession(deck.id);\n\n    if (existingSession) {\n      // Check if the existing session is already complete\n      const allCardsMatched = existingSession.grid.every(card => card.isMatched);\n\n      if (allCardsMatched && existingSession.grid.length > 0) {\n        // Session is complete, show results immediately\n        const completionTime = Date.now() - existingSession.roundStartTime;\n        const gameResults: MatchResultsData = {\n          deckId: existingSession.deckId,\n          totalTime: completionTime,\n          bestTime: null,\n          isNewBest: false,\n          totalMatches: existingSession.matchedPairs.length,\n          missedCardIndices: existingSession.missedCardIndices,\n          roundNumber: existingSession.currentRound,\n          startTime: existingSession.roundStartTime,\n          endTime: Date.now(),\n        };\n\n        setResults(gameResults);\n        setShowResults(true);\n        setIsInitialized(true);\n      } else {\n        // Session exists but not complete, continue playing\n        setIsInitialized(true);\n      }\n    } else {\n      // Start new session\n      const masteredIndices = getMasteredCards(deck.id);\n      const settings = {\n        ...DEFAULT_MATCH_SETTINGS,\n        includeMastered: masteredIndices.length === 0, // Include mastered only if none exist\n      };\n\n      startSession(deck.id, settings);\n\n      // Generate initial grid\n      setTimeout(() => {\n        generateGrid(deck.content, settings);\n        setIsInitialized(true);\n      }, 100);\n    }\n  }, [deck, isInitialized, loadSession, startSession, generateGrid, getMasteredCards]);\n\n  // Check for mobile device\n  useEffect(() => {\n    const checkMobile = () => {\n      const mobile = window.innerWidth < 768 || 'ontouchstart' in window;\n      setIsMobile(mobile);\n    };\n\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  // Sync audio settings with match settings\n  useEffect(() => {\n    if (session?.settings.enableAudio !== undefined) {\n      updateAudioSettings({\n        enabled: session.settings.enableAudio,\n        soundEffects: session.settings.enableAudio,\n      });\n    }\n  }, [session?.settings.enableAudio]);\n\n  // Handle card selection\n  const handleCardSelect = useCallback(async (cardId: string) => {\n    if (!session || animatingCards.length > 0 || gameCompleted) return;\n\n    // Play card selection sound if audio is enabled\n    if (isAudioEnabled) {\n      playSound('card_select', 0.8);\n      vibrate(30);\n    }\n\n    selectCard(cardId);\n\n    // Check for match when we have the right number of cards selected\n    const expectedCards = session.settings.matchType === 'three_way' ? 3 : 2;\n\n    if (session.selectedCards.length + 1 === expectedCards) {\n      // We've selected enough cards, check for a match\n      setTimeout(async () => {\n        const result = processMatch();\n\n        if (result.isMatch && result.matchedCards) {\n          // Play match success sound if audio is enabled\n          if (isAudioEnabled) {\n            await playMatchSuccess(1.2);\n            vibrate([50, 50, 50]);\n          }\n\n          // Show success notification\n          showNotification({\n            message: 'Match found! üéâ',\n            type: 'success',\n            duration: 1500,\n          });\n\n          setAnimatingCards(result.matchedCards);\n\n          // Clear animation after match animation completes\n          setTimeout(() => {\n            setAnimatingCards([]);\n\n            // Check if game is complete\n            const remainingCards = session.grid.filter(\n              card => !card.isMatched && !result.matchedCards?.includes(card.id)\n            );\n\n            if (remainingCards.length === 0) {\n              handleGameComplete();\n            }\n          }, 600);\n        } else {\n          // Play match failure sound if audio is enabled\n          if (isAudioEnabled) {\n            await playMatchFailure();\n            vibrate(100);\n          }\n\n          // Show mismatch notification\n          showNotification({\n            message: 'No match! Try again.',\n            type: 'error',\n            duration: 1500,\n          });\n\n          // Clear selection after showing the mismatch\n          setTimeout(() => {\n            clearSelection();\n          }, 800);\n        }\n      }, 150);\n    }\n  }, [session, selectCard, processMatch, clearSelection, animatingCards, gameCompleted, showNotification]);\n\n  // Handle game completion\n  const handleGameComplete = useCallback(async () => {\n    if (!session || gameCompleted) return;\n\n    setGameCompleted(true);\n\n    // Play game completion sound if audio is enabled\n    if (isAudioEnabled) {\n      await playGameComplete();\n      vibrate([100, 50, 100, 50, 200]);\n    }\n\n    const completionTime = Date.now() - session.roundStartTime;\n    const endTime = Date.now();\n\n    // Update best time\n    const isNewBest = updateBestTime(\n      session.deckId,\n      completionTime,\n      session.settings.gridSize,\n      session.settings.matchType,\n      session.matchedPairs.length\n    );\n\n    // Create results data\n    const gameResults: MatchResultsData = {\n      deckId: session.deckId,\n      totalTime: completionTime,\n      bestTime: null, // Will be populated by MatchResults component\n      isNewBest,\n      totalMatches: session.matchedPairs.length,\n      missedCardIndices: session.missedCardIndices,\n      roundNumber: session.currentRound,\n      startTime: session.roundStartTime,\n      endTime,\n    };\n\n    setResults(gameResults);\n\n    // Show results modal immediately\n    setGameCompleted(false);\n    setShowResults(true);\n  }, [session, gameCompleted, updateBestTime]);\n\n  // Timer disabled - formatTime removed\n\n  // Handle pause/resume\n  const handlePause = useCallback(() => {\n    if (session?.isPaused) {\n      resumeSession();\n    } else {\n      pauseSession();\n    }\n  }, [session, pauseSession, resumeSession]);\n\n  // Handle back navigation\n  const handleBack = useCallback(() => {\n    if (onBackClick) {\n      onBackClick();\n    } else {\n      navigate(`/deck/${deck.id}`);\n    }\n  }, [navigate, deck.id, onBackClick]);\n\n  // Results modal handlers\n  const handleContinueWithMissed = useCallback(() => {\n    if (!session || !results) return;\n\n    setShowResults(false);\n    setResults(null);\n\n    // Start new round with missed cards only\n    startNewRound(results.missedCardIndices);\n  }, [session, results, startNewRound]);\n\n  const handleStartNewRound = useCallback(() => {\n    if (!session || !deck) return;\n\n    setShowResults(false);\n    setResults(null);\n\n    // Start completely new round\n    startNewRound();\n\n    // Generate new grid for the new round\n    setTimeout(() => {\n      generateGrid(deck.content, session.settings);\n    }, 100);\n  }, [session, deck, startNewRound, generateGrid]);\n\n  const handleCloseResults = useCallback(() => {\n    setShowResults(false);\n    setResults(null);\n  }, []);\n\n  // Settings handlers\n  const handleShowSettings = useCallback(() => {\n    setShowSettings(true);\n  }, []);\n\n  const handleCloseSettings = useCallback(() => {\n    setShowSettings(false);\n  }, []);\n\n  const handleUpdateSettings = useCallback((newSettings: any) => {\n    const matchSettings = newSettings as MatchSettings;\n    if (!session) return;\n\n    // Update session settings and regenerate grid if needed\n    const gridSizeChanged =\n      session.settings.gridSize.rows !== matchSettings.gridSize.rows ||\n      session.settings.gridSize.cols !== matchSettings.gridSize.cols;\n\n    const cardSidesChanged =\n      JSON.stringify(session.settings.cardSides) !== JSON.stringify(matchSettings.cardSides);\n\n    // If significant changes were made, regenerate grid\n    if (gridSizeChanged || cardSidesChanged) {\n      // Store updated settings\n      session.settings = matchSettings;\n\n      // Regenerate grid with new settings\n      generateGrid(deck.content, matchSettings);\n    } else {\n      // Just update settings for non-grid affecting changes\n      session.settings = matchSettings;\n    }\n  }, [session, deck, generateGrid]);\n\n  // Memoized grid calculations\n  const gridMetrics = useMemo(() => {\n    if (!session || !session.grid.length) {\n      return {\n        totalCards: 0,\n        matchedCards: 0,\n        progressPercentage: 0,\n        selectedCount: session?.selectedCards.length || 0,\n      };\n    }\n\n    const totalCards = session.grid.length;\n    const matchedCards = session.grid.filter(card => card.isMatched).length;\n    const progressPercentage = (matchedCards / totalCards) * 100;\n    const selectedCount = session.selectedCards.length;\n\n    return {\n      totalCards,\n      matchedCards,\n      progressPercentage,\n      selectedCount,\n    };\n  }, [session]);\n\n  // Timer functionality disabled for now\n\n  // Calculate matched card pairs for MatchGrid\n  const matchedCardPairs = useMemo(() => {\n    if (!session) return [];\n    return session.matchedPairs;\n  }, [session]);\n\n  // Loading state\n  if (!isInitialized || !session) {\n    return <LoadingScreen />;\n  }\n\n  return (\n    <div className={styles.container}>\n      <SharedModeHeader\n        deckName={deck.metadata.deck_name}\n        currentCard={gridMetrics.matchedCards}\n        totalCards={gridMetrics.totalCards}\n        onBackClick={handleBack}\n        onSettingsClick={handleShowSettings}\n        showSettings={true}\n        subtitle={session.currentRound > 1 ? `Round ${session.currentRound}` : undefined}\n      />\n\n      {/* Game stats */}\n      <div className={styles.gameStats}>\n        <div className={styles.progressSection}>\n          <div className={styles.progressBar}>\n            <motion.div\n              className={styles.progressFill}\n              initial={{ width: 0 }}\n              animate={{ width: `${gridMetrics.progressPercentage}%` }}\n              transition={{ duration: 0.3 }}\n            />\n          </div>\n          <div className={styles.statsText}>\n            <span>{gridMetrics.matchedCards} / {gridMetrics.totalCards} matched</span>\n          </div>\n\n          {/* Timer disabled for now */}\n          {/* <MatchTimer\n            isEnabled={timerData.enabled}\n            isPaused={timerData.isPaused}\n            initialTime={timerData.elapsedTime}\n            onTimeChange={handleTimerUpdate}\n            compact={isMobile}\n            theme=\"primary\"\n            className={styles.matchTimer}\n          /> */}\n        </div>\n\n        {/* Game controls */}\n        <div className={styles.gameControls}>\n          {/* Timer/Pause disabled for now */}\n          {/* {session.settings.enableTimer && (\n            <button\n              className={styles.pauseButton}\n              onClick={handlePause}\n              aria-label={session.isPaused ? 'Resume game' : 'Pause game'}\n            >\n              {session.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}\n            </button>\n          )} */}\n\n          {session.selectedCards.length > 0 && (\n            <button\n              className={styles.clearButton}\n              onClick={clearSelection}\n              aria-label=\"Clear selection\"\n            >\n              Clear Selection\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* Match grid */}\n      <main className={styles.gridContainer}>\n        <AnimatePresence mode=\"wait\">\n          {session.isPaused ? (\n            <motion.div\n              key=\"paused\"\n              className={styles.pausedOverlay}\n              variants={pauseOverlayVariants}\n              initial=\"initial\"\n              animate=\"animate\"\n              exit=\"exit\"\n            >\n              <div className={styles.pausedContent}>\n                <h2>Game Paused</h2>\n                <button\n                  className={styles.resumeButton}\n                  onClick={handlePause}\n                >\n                  Resume Game\n                </button>\n              </div>\n            </motion.div>\n          ) : (\n            <MatchGrid\n              key=\"grid\"\n              cards={session.grid}\n              onCardSelect={handleCardSelect}\n              selectedCards={session.selectedCards}\n              matchedCards={matchedCardPairs}\n              gridSize={session.settings.gridSize}\n              isAnimating={animatingCards.length > 0}\n              animatingCards={animatingCards}\n              isMobile={isMobile}\n            />\n          )}\n        </AnimatePresence>\n      </main>\n\n      {/* Game completion handled by MatchResults modal */}\n\n      {/* Selection feedback */}\n      {gridMetrics.selectedCount > 0 && (\n        <motion.div\n          className={styles.selectionFeedback}\n          initial={{ y: 50, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          exit={{ y: 50, opacity: 0 }}\n        >\n          {gridMetrics.selectedCount} card{gridMetrics.selectedCount > 1 ? 's' : ''} selected\n        </motion.div>\n      )}\n\n      {/* Results Modal */}\n      <MatchResults\n        visible={showResults}\n        results={results}\n        onContinueWithMissed={handleContinueWithMissed}\n        onStartNewRound={handleStartNewRound}\n        onBackToDeck={handleBack}\n        onClose={handleCloseResults}\n      />\n\n      {/* Settings Modal */}\n      <UnifiedSettings\n        visible={showSettings}\n        onClose={handleCloseSettings}\n        deck={deck}\n        mode=\"match\"\n        settings={session?.settings || DEFAULT_MATCH_SETTINGS}\n        onUpdateSettings={handleUpdateSettings}\n      />\n    </div>\n  );\n});\n\nMatchContainer.displayName = 'MatchContainer';\n\nexport default MatchContainer;"],"names":["DEFAULT_MATCH_SETTINGS","gridSize","rows","cols","matchType","cardSides","sides","label","count","enableTimer","includeMastered","enableAudio","timerSeconds","generateCardId","cardIndex","sideGroup","position","shuffleArray","array","shuffled","i","length","j","Math","floor","random","useMatchSessionStore","create","persist","set","get","session","startSession","deckId","settings","startTime","Date","now","currentRound","pausedTime","isPaused","grid","selectedCards","matchedPairs","missedCardIndices","roundStartTime","bestTime","pauseSession","resumeSession","pauseDuration","endSession","selectCard","cardId","card","find","c","id","isMatched","newSelectedCards","newGrid","includes","filter","map","isSelected","clearSelection","processMatch","isMatch","selectedCardObjects","validationResult","isValid","matchedCards","firstGroupId","groupId","allSameGroup","every","isValidCount","validateMatch","newMatchedPairs","startNewRound","missedCards","generateGrid","cards","excludeMastered","masteredIndices","totalSlots","availableCards","_","index","cardsPerGroup","maxGroups","needed","repeated","slice","matchCards","forEach","idx","push","displaySides","content","side_a","trim","row","col","side_b","side_c","cardSide","sideKey","sideContent","shuffledCards","generateMatchCards","saveSession","loadSession","name","storage","getItem","str","localStorage","state","JSON","parse","error","setItem","value","stringify","removeItem","partialize","formatMatchTime","timeMs","totalSeconds","seconds","toString","padStart","useMatchBestTimesStore","bestTimes","updateBestTime","totalMatches","currentBest","bestTimeMs","achievedAt","getBestTime","hasBestTime","clearBestTime","newBestTimes","clearAllBestTimes","getAllBestTimes","Object","values","getDeckStats","formattedTime","hasRecord","parsed","keys","ProgressBar","memo","max","variant","size","showLabel","animated","percentage","min","containerClasses","styles","container","Boolean","join","barClasses","bar","jsxs","className","children","jsx","track","role","style","width","round","displayName","LoadingScreen","message","fullScreen","Spinner","FAST_TRANSITION","type","stiffness","damping","mass","cardSelectionVariants","unselected","scale","borderColor","boxShadow","y","transition","selected","hover","gridLayoutVariants","initial","opacity","animate","duration","staggerChildren","delayChildren","exit","staggerDirection","pauseOverlayVariants","backdropFilter","ease","getMobileOptimizedVariants","variants","isMobile","entries","reduce","acc","key","mobileValue","Array","isArray","scaleArray","getReducedMotionVariants","reducedValue","rotate","rotateY","allowedProps","prop","MatchCard","isAnimating","isCurrentlyAnimating","onSelect","prefersReducedMotion","handleCardClick","useCallback","handleKeyDown","event","preventDefault","cardVariants","getCardVariants","animationState","motion","div","matched","animating","gridRow","gridColumn","onClick","onKeyDown","tabIndex","whileHover","whileTap","layout","layoutId","selectionIndicator","matchIndicator","delay","touchTarget","MatchGrid","onCardSelect","animatingCards","matchedCardIds","Set","flat","window","matchMedia","matches","gridVariants","gridTemplateRows","gridTemplateColumns","AnimatePresence","mode","has","MatchResults","visible","results","onContinueWithMissed","onStartNewRound","onBackToDeck","navigate","useNavigate","isNewBest","setIsNewBest","useState","previousBest","setPreviousBest","useEffect","existingBest","wasNewBest","totalTime","e","target","tagName","isContentEditable","addEventListener","removeEventListener","performance","averageTimePerMatch","emoji","color","getPerformanceMessage","currentTime","hasMissedCards","sessionComplete","header","title","subtitle","roundNumber","resultsGrid","resultCard","resultValue","resultLabel","achievementSection","achievementItem","achievementIcon","newBest","achievementText","missedSection","missedItem","missedIcon","review","missedText","actions","Fragment","actionButton","primary","secondary","tertiary","p","motivationalMessage","SOUND_CONFIGS","match_success","frequency","volume","envelope","attack","decay","sustain","release","match_failure","card_select","card_flip","game_complete","timer_tick","button_click","notification","soundManager","audioContext","audioPool","Map","enabled","soundEffects","backgroundMusic","constructor","this","initializeAudioContext","AudioContext","webkitAudioContext","document","resumeAudioContext","bind","once","resume","updateSettings","newSettings","getSettings","playSound","soundEffect","volumeMultiplier","config","synthesizeAndPlay","ctx","oscillator","createOscillator","gainNode","createGain","setValueAtTime","sustainLevel","attackTime","decayTime","releaseTime","gain","linearRampToValueAtTime","connect","destination","start","stop","disconnect","playMatchSuccess","intensity","frequencies","delays","setTimeout","playMatchFailure","playGameComplete","freq","vibrate","pattern","navigator","preload","cleanup","close","clear","MatchContainer","deck","onBackClick","getMasteredCards","useCardMasteryStore","showNotification","useNotificationStore","isInitialized","setIsInitialized","showResults","setShowResults","setResults","showSettings","setShowSettings","setAnimatingCards","gameCompleted","setGameCompleted","setIsMobile","isAudioEnabled","existingSession","allCardsMatched","completionTime","gameResults","endTime","checkMobile","mobile","innerWidth","handleCardSelect","async","effect","expectedCards","result","remainingCards","handleGameComplete","handlePause","handleBack","handleContinueWithMissed","handleStartNewRound","handleCloseResults","handleShowSettings","handleCloseSettings","handleUpdateSettings","matchSettings","gridSizeChanged","cardSidesChanged","gridMetrics","useMemo","totalCards","progressPercentage","selectedCount","matchedCardPairs","SharedModeHeader","deckName","metadata","deck_name","currentCard","onSettingsClick","onClose","UnifiedSettings","onUpdateSettings"],"mappings":"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"}